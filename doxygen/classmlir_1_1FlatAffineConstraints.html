<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MLIR: mlir::FlatAffineConstraints Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MLIR
   &#160;<span id="projectnumber">14.0.0git</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacemlir.html">mlir</a></li><li class="navelem"><a class="el" href="classmlir_1_1FlatAffineConstraints.html">FlatAffineConstraints</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pro-static-attribs">Static Protected Attributes</a> &#124;
<a href="classmlir_1_1FlatAffineConstraints-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">mlir::FlatAffineConstraints Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A flat list of affine equalities and inequalities in the form.  
 <a href="classmlir_1_1FlatAffineConstraints.html#details">More...</a></p>

<p><code>#include &quot;<a class="el" href="AffineStructures_8h_source.html">mlir/Analysis/AffineStructures.h</a>&quot;</code></p>
<div class="dynheader">
Inheritance diagram for mlir::FlatAffineConstraints:</div>
<div class="dyncontent">
<div class="center"><img src="classmlir_1_1FlatAffineConstraints__inherit__graph.png" border="0" usemap="#mlir_1_1FlatAffineConstraints_inherit__map" alt="Inheritance graph"/></div>
<map name="mlir_1_1FlatAffineConstraints_inherit__map" id="mlir_1_1FlatAffineConstraints_inherit__map">
<area shape="rect" id="node2" href="classmlir_1_1FlatAffineValueConstraints.html" title="An extension of FlatAffineConstraints in which dimensions and symbols can optionally be associated wi..." alt="" coords="5,80,233,107"/>
<area shape="rect" id="node3" href="classmlir_1_1FlatAffineRelation.html" title="A FlatAffineRelation represents a set of ordered pairs (domain &#45;&gt; range) where &quot;domain&quot; and &quot;range&quot; a..." alt="" coords="34,155,205,181"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for mlir::FlatAffineConstraints:</div>
<div class="dyncontent">
<div class="center"><img src="classmlir_1_1FlatAffineConstraints__coll__graph.png" border="0" usemap="#mlir_1_1FlatAffineConstraints_coll__map" alt="Collaboration graph"/></div>
<map name="mlir_1_1FlatAffineConstraints_coll__map" id="mlir_1_1FlatAffineConstraints_coll__map">
<area shape="rect" id="node2" href="classmlir_1_1Matrix.html" title="This is a class to represent a resizable matrix. " alt="" coords="5,5,103,32"/>
<area shape="rect" id="node3" href="classunsigned.html" title="unsigned" alt="" coords="127,5,208,32"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ac7022f51854ec1d369bb150035a1437f"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#ac7022f51854ec1d369bb150035a1437f">Kind</a> { <a class="el" href="classmlir_1_1FlatAffineConstraints.html#ac7022f51854ec1d369bb150035a1437fa5d3c39d196a997e225b4f3ee3e1da745">Kind::FlatAffineConstraints</a>, 
<a class="el" href="classmlir_1_1FlatAffineConstraints.html#ac7022f51854ec1d369bb150035a1437fa38bdec3fb5cb6b2e66b5acddb32f9cb4">Kind::FlatAffineValueConstraints</a>
 }<tr class="memdesc:ac7022f51854ec1d369bb150035a1437f"><td class="mdescLeft">&#160;</td><td class="mdescRight">All derived classes of <a class="el" href="classmlir_1_1FlatAffineConstraints.html" title="A flat list of affine equalities and inequalities in the form. ">FlatAffineConstraints</a>.  <a href="classmlir_1_1FlatAffineConstraints.html#ac7022f51854ec1d369bb150035a1437f">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ac7022f51854ec1d369bb150035a1437f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab47fbec6c4aff6faece95521b103fed2"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#ab47fbec6c4aff6faece95521b103fed2">IdKind</a> { <a class="el" href="classmlir_1_1FlatAffineConstraints.html#ab47fbec6c4aff6faece95521b103fed2a2ee94b4e0a594b0b54351659320e6ba7">Dimension</a>, 
<a class="el" href="classmlir_1_1FlatAffineConstraints.html#ab47fbec6c4aff6faece95521b103fed2ae3c7272b03244406768692d4fea34372">Symbol</a>, 
<a class="el" href="classmlir_1_1FlatAffineConstraints.html#ab47fbec6c4aff6faece95521b103fed2a5cbad5ec78394bb35d4d33f15993f778">Local</a>
 }<tr class="memdesc:ab47fbec6c4aff6faece95521b103fed2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Kind of identifier (column).  <a href="classmlir_1_1FlatAffineConstraints.html#ab47fbec6c4aff6faece95521b103fed2">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ab47fbec6c4aff6faece95521b103fed2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6eda5ed3d07648239f51a58d283af25f"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a6eda5ed3d07648239f51a58d283af25f">BoundType</a> { <a class="el" href="classmlir_1_1FlatAffineConstraints.html#a6eda5ed3d07648239f51a58d283af25fa819c60666bda38d2d84f3b3b1cc85353">EQ</a>, 
<a class="el" href="classmlir_1_1FlatAffineConstraints.html#a6eda5ed3d07648239f51a58d283af25fadbdfcad083981238050dde5e628d9906">LB</a>, 
<a class="el" href="classmlir_1_1FlatAffineConstraints.html#a6eda5ed3d07648239f51a58d283af25fa6f0c4e378019df95f41471d395927fd4">UB</a>
 }<tr class="memdesc:a6eda5ed3d07648239f51a58d283af25f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of bound: equal, lower bound or upper bound.  <a href="classmlir_1_1FlatAffineConstraints.html#a6eda5ed3d07648239f51a58d283af25f">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a6eda5ed3d07648239f51a58d283af25f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ad696d4f93b157c44fec1e3965e850433"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#ad696d4f93b157c44fec1e3965e850433">FlatAffineConstraints</a> (<a class="el" href="classunsigned.html">unsigned</a> numReservedInequalities, <a class="el" href="classunsigned.html">unsigned</a> numReservedEqualities, <a class="el" href="classunsigned.html">unsigned</a> numReservedCols, <a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="classmlir_1_1FlatAffineConstraints.html#a2202d24f4dfb178dd579cceb9a81d552">numDims</a>, <a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="classmlir_1_1FlatAffineConstraints.html#a8ec0168aae7454795c0a4939f2230642">numSymbols</a>, <a class="el" href="classunsigned.html">unsigned</a> numLocals)</td></tr>
<tr class="memdesc:ad696d4f93b157c44fec1e3965e850433"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a constraint system reserving memory for the specified number of constraints and identifiers.  <a href="#ad696d4f93b157c44fec1e3965e850433">More...</a><br /></td></tr>
<tr class="separator:ad696d4f93b157c44fec1e3965e850433"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac128caef8d1284314f3220982733a7df"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#ac128caef8d1284314f3220982733a7df">FlatAffineConstraints</a> (<a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="classmlir_1_1FlatAffineConstraints.html#a2202d24f4dfb178dd579cceb9a81d552">numDims</a>=0, <a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="classmlir_1_1FlatAffineConstraints.html#a8ec0168aae7454795c0a4939f2230642">numSymbols</a>=0, <a class="el" href="classunsigned.html">unsigned</a> numLocals=0)</td></tr>
<tr class="memdesc:ac128caef8d1284314f3220982733a7df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a constraint system with the specified number of dimensions and symbols.  <a href="#ac128caef8d1284314f3220982733a7df">More...</a><br /></td></tr>
<tr class="separator:ac128caef8d1284314f3220982733a7df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04009cfc4f3c97dbff1cf9594c0f7c9a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a04009cfc4f3c97dbff1cf9594c0f7c9a">FlatAffineConstraints</a> (<a class="el" href="classmlir_1_1IntegerSet.html">IntegerSet</a> set)</td></tr>
<tr class="memdesc:a04009cfc4f3c97dbff1cf9594c0f7c9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an affine constraint system from an <a class="el" href="classmlir_1_1IntegerSet.html" title="An integer set representing a conjunction of one or more affine equalities and inequalities. ">IntegerSet</a>.  <a href="#a04009cfc4f3c97dbff1cf9594c0f7c9a">More...</a><br /></td></tr>
<tr class="separator:a04009cfc4f3c97dbff1cf9594c0f7c9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8074122b77beb705d010169667ae9efe"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a8074122b77beb705d010169667ae9efe">FlatAffineConstraints</a> (const <a class="el" href="structmlir_1_1MutableAffineMap.html">MutableAffineMap</a> &amp;map)</td></tr>
<tr class="separator:a8074122b77beb705d010169667ae9efe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a948c10906e0c0a4ab77176a31035a73b"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a948c10906e0c0a4ab77176a31035a73b">~FlatAffineConstraints</a> ()=default</td></tr>
<tr class="separator:a948c10906e0c0a4ab77176a31035a73b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a09df05dc3bd81725f085f4268b7e6a"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classmlir_1_1FlatAffineConstraints.html#ac7022f51854ec1d369bb150035a1437f">Kind</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a4a09df05dc3bd81725f085f4268b7e6a">getKind</a> () const</td></tr>
<tr class="memdesc:a4a09df05dc3bd81725f085f4268b7e6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the kind of this <a class="el" href="classmlir_1_1FlatAffineConstraints.html" title="A flat list of affine equalities and inequalities in the form. ">FlatAffineConstraints</a>.  <a href="#a4a09df05dc3bd81725f085f4268b7e6a">More...</a><br /></td></tr>
<tr class="separator:a4a09df05dc3bd81725f085f4268b7e6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3edb59b14438aee23b65a97fec843573"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a3edb59b14438aee23b65a97fec843573">reset</a> (<a class="el" href="classunsigned.html">unsigned</a> numReservedInequalities, <a class="el" href="classunsigned.html">unsigned</a> numReservedEqualities, <a class="el" href="classunsigned.html">unsigned</a> numReservedCols, <a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="classmlir_1_1FlatAffineConstraints.html#a2202d24f4dfb178dd579cceb9a81d552">numDims</a>, <a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="classmlir_1_1FlatAffineConstraints.html#a8ec0168aae7454795c0a4939f2230642">numSymbols</a>, <a class="el" href="classunsigned.html">unsigned</a> numLocals=0)</td></tr>
<tr class="memdesc:a3edb59b14438aee23b65a97fec843573"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears any existing data and reserves memory for the specified constraints.  <a href="#a3edb59b14438aee23b65a97fec843573">More...</a><br /></td></tr>
<tr class="separator:a3edb59b14438aee23b65a97fec843573"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5a1350a0302ad695d2c11a065d59ee2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#ab5a1350a0302ad695d2c11a065d59ee2">reset</a> (<a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="classmlir_1_1FlatAffineConstraints.html#a2202d24f4dfb178dd579cceb9a81d552">numDims</a>=0, <a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="classmlir_1_1FlatAffineConstraints.html#a8ec0168aae7454795c0a4939f2230642">numSymbols</a>=0, <a class="el" href="classunsigned.html">unsigned</a> numLocals=0)</td></tr>
<tr class="separator:ab5a1350a0302ad695d2c11a065d59ee2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e4973d2d62dbf7779d1e350fec9911e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a6e4973d2d62dbf7779d1e350fec9911e">append</a> (const <a class="el" href="classmlir_1_1FlatAffineConstraints.html">FlatAffineConstraints</a> &amp;other)</td></tr>
<tr class="memdesc:a6e4973d2d62dbf7779d1e350fec9911e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends constraints from <code>other</code> into <code>this</code>.  <a href="#a6e4973d2d62dbf7779d1e350fec9911e">More...</a><br /></td></tr>
<tr class="separator:a6e4973d2d62dbf7779d1e350fec9911e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ddc2ce92fc0297fbc8bfc62241c4472"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a6ddc2ce92fc0297fbc8bfc62241c4472">isEmpty</a> () const</td></tr>
<tr class="memdesc:a6ddc2ce92fc0297fbc8bfc62241c4472"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks for emptiness by performing variable elimination on all identifiers, running the GCD test on each equality constraint, and checking for invalid constraints.  <a href="#a6ddc2ce92fc0297fbc8bfc62241c4472">More...</a><br /></td></tr>
<tr class="separator:a6ddc2ce92fc0297fbc8bfc62241c4472"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af318337e58529a47cd9c9e38e11b3e67"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#af318337e58529a47cd9c9e38e11b3e67">isEmptyByGCDTest</a> () const</td></tr>
<tr class="memdesc:af318337e58529a47cd9c9e38e11b3e67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Runs the GCD test on all equality constraints.  <a href="#af318337e58529a47cd9c9e38e11b3e67">More...</a><br /></td></tr>
<tr class="separator:af318337e58529a47cd9c9e38e11b3e67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef2b4af0478ccc4117618d8f530e41bb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#aef2b4af0478ccc4117618d8f530e41bb">isIntegerEmpty</a> () const</td></tr>
<tr class="memdesc:aef2b4af0478ccc4117618d8f530e41bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the set of constraints is found to have no solution, false if a solution exists.  <a href="#aef2b4af0478ccc4117618d8f530e41bb">More...</a><br /></td></tr>
<tr class="separator:aef2b4af0478ccc4117618d8f530e41bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7ef7a710ab1ff16234a3e4ba01e1d7f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Matrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#ab7ef7a710ab1ff16234a3e4ba01e1d7f">getBoundedDirections</a> () const</td></tr>
<tr class="memdesc:ab7ef7a710ab1ff16234a3e4ba01e1d7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a matrix where each row is a vector along which the polytope is bounded.  <a href="#ab7ef7a710ab1ff16234a3e4ba01e1d7f">More...</a><br /></td></tr>
<tr class="separator:ab7ef7a710ab1ff16234a3e4ba01e1d7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a068c098c9581e2b99d317a11fd0a3105"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t, 8 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a068c098c9581e2b99d317a11fd0a3105">findIntegerSample</a> () const</td></tr>
<tr class="memdesc:a068c098c9581e2b99d317a11fd0a3105"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find an integer sample point satisfying the constraints using a branch and bound algorithm with generalized basis reduction, with some additional processing using <a class="el" href="classmlir_1_1Simplex.html" title="This class implements a version of the Simplex and Generalized Basis Reduction algorithms, which can perform analysis of integer sets with affine inequalities and equalities. ">Simplex</a> for unbounded sets.  <a href="#a068c098c9581e2b99d317a11fd0a3105">More...</a><br /></td></tr>
<tr class="separator:a068c098c9581e2b99d317a11fd0a3105"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae447433822615a5748eb99dc75961579"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#ae447433822615a5748eb99dc75961579">containsPoint</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; point) const</td></tr>
<tr class="memdesc:ae447433822615a5748eb99dc75961579"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the given point satisfies the constraints, or false otherwise.  <a href="#ae447433822615a5748eb99dc75961579">More...</a><br /></td></tr>
<tr class="separator:ae447433822615a5748eb99dc75961579"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95feac8d46e898c9afc6e0ea965ac62e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a95feac8d46e898c9afc6e0ea965ac62e">getLocalReprs</a> (std::vector&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t, 8 &gt;&gt; &amp;dividends, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classunsigned.html">unsigned</a>, 4 &gt; &amp;denominators, std::vector&lt; <a class="el" href="classllvm_1_1Optional.html">llvm::Optional</a>&lt; std::pair&lt; <a class="el" href="classunsigned.html">unsigned</a>, <a class="el" href="classunsigned.html">unsigned</a> &gt;&gt;&gt; &amp;repr) const</td></tr>
<tr class="memdesc:a95feac8d46e898c9afc6e0ea965ac62e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find pairs of inequalities identified by their position indices, using which an explicit representation for each local variable can be computed.  <a href="#a95feac8d46e898c9afc6e0ea965ac62e">More...</a><br /></td></tr>
<tr class="separator:a95feac8d46e898c9afc6e0ea965ac62e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3874c61c1c0744d4b00241e280ff68eb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a3874c61c1c0744d4b00241e280ff68eb">getLocalReprs</a> (std::vector&lt; <a class="el" href="classllvm_1_1Optional.html">llvm::Optional</a>&lt; std::pair&lt; <a class="el" href="classunsigned.html">unsigned</a>, <a class="el" href="classunsigned.html">unsigned</a> &gt;&gt;&gt; &amp;repr) const</td></tr>
<tr class="separator:a3874c61c1c0744d4b00241e280ff68eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adac6b777c22096af2f6c331ccc16a282"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#adac6b777c22096af2f6c331ccc16a282">getLocalReprs</a> (std::vector&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t, 8 &gt;&gt; &amp;dividends, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classunsigned.html">unsigned</a>, 4 &gt; &amp;denominators) const</td></tr>
<tr class="separator:adac6b777c22096af2f6c331ccc16a282"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0932fcc3e8ee32f1af944a1f33a9abc3"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1FlatAffineConstraints.html">FlatAffineConstraints</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a0932fcc3e8ee32f1af944a1f33a9abc3">clone</a> () const</td></tr>
<tr class="separator:a0932fcc3e8ee32f1af944a1f33a9abc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaeb4c8e8b0bf86fa1609a32bd9028536"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#aaeb4c8e8b0bf86fa1609a32bd9028536">atEq</a> (<a class="el" href="classunsigned.html">unsigned</a> i, <a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="unionj.html">j</a>) const</td></tr>
<tr class="memdesc:aaeb4c8e8b0bf86fa1609a32bd9028536"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value at the specified equality row and column.  <a href="#aaeb4c8e8b0bf86fa1609a32bd9028536">More...</a><br /></td></tr>
<tr class="separator:aaeb4c8e8b0bf86fa1609a32bd9028536"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b80ebb1a0929a30c4401d297a420d9e"><td class="memItemLeft" align="right" valign="top">int64_t &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a0b80ebb1a0929a30c4401d297a420d9e">atEq</a> (<a class="el" href="classunsigned.html">unsigned</a> i, <a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="unionj.html">j</a>)</td></tr>
<tr class="separator:a0b80ebb1a0929a30c4401d297a420d9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a950735c15d0d1757984210922c7118c0"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a950735c15d0d1757984210922c7118c0">atIneq</a> (<a class="el" href="classunsigned.html">unsigned</a> i, <a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="unionj.html">j</a>) const</td></tr>
<tr class="memdesc:a950735c15d0d1757984210922c7118c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value at the specified inequality row and column.  <a href="#a950735c15d0d1757984210922c7118c0">More...</a><br /></td></tr>
<tr class="separator:a950735c15d0d1757984210922c7118c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae02ba9253168af09117779ede6e1020f"><td class="memItemLeft" align="right" valign="top">int64_t &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#ae02ba9253168af09117779ede6e1020f">atIneq</a> (<a class="el" href="classunsigned.html">unsigned</a> i, <a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="unionj.html">j</a>)</td></tr>
<tr class="separator:ae02ba9253168af09117779ede6e1020f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6dafa2401aead0909b87b92d41bfbbd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#ad6dafa2401aead0909b87b92d41bfbbd">getNumCols</a> () const</td></tr>
<tr class="memdesc:ad6dafa2401aead0909b87b92d41bfbbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of columns in the constraint system.  <a href="#ad6dafa2401aead0909b87b92d41bfbbd">More...</a><br /></td></tr>
<tr class="separator:ad6dafa2401aead0909b87b92d41bfbbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a963e712e6a344acbadfa413940487704"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a963e712e6a344acbadfa413940487704">getNumEqualities</a> () const</td></tr>
<tr class="separator:a963e712e6a344acbadfa413940487704"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50f382f6a3f7062ff36e3dce1920c4c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a50f382f6a3f7062ff36e3dce1920c4c9">getNumInequalities</a> () const</td></tr>
<tr class="separator:a50f382f6a3f7062ff36e3dce1920c4c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a597e435e789ef833a1e0cc80cd82a388"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a597e435e789ef833a1e0cc80cd82a388">getNumReservedEqualities</a> () const</td></tr>
<tr class="separator:a597e435e789ef833a1e0cc80cd82a388"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3617c7a6eef7e4c3d1b1845025900adf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a3617c7a6eef7e4c3d1b1845025900adf">getNumReservedInequalities</a> () const</td></tr>
<tr class="separator:a3617c7a6eef7e4c3d1b1845025900adf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0673b512906bb0fed9e4c7244f9f0217"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a0673b512906bb0fed9e4c7244f9f0217">getEquality</a> (<a class="el" href="classunsigned.html">unsigned</a> idx) const</td></tr>
<tr class="separator:a0673b512906bb0fed9e4c7244f9f0217"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92b9b04e17d80d48a79c0e09710c2be6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a92b9b04e17d80d48a79c0e09710c2be6">getInequality</a> (<a class="el" href="classunsigned.html">unsigned</a> idx) const</td></tr>
<tr class="separator:a92b9b04e17d80d48a79c0e09710c2be6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a520de7a96a9cdf5130756e58a42e6371"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a520de7a96a9cdf5130756e58a42e6371">addBound</a> (<a class="el" href="classmlir_1_1FlatAffineConstraints.html#a6eda5ed3d07648239f51a58d283af25f">BoundType</a> type, <a class="el" href="classunsigned.html">unsigned</a> pos, <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> boundMap)</td></tr>
<tr class="memdesc:a520de7a96a9cdf5130756e58a42e6371"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a bound for the identifier at the specified position with constraints being drawn from the specified bound map.  <a href="#a520de7a96a9cdf5130756e58a42e6371">More...</a><br /></td></tr>
<tr class="separator:a520de7a96a9cdf5130756e58a42e6371"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1ebc66e64e3cd0f7eb89514664f786d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#af1ebc66e64e3cd0f7eb89514664f786d">addBound</a> (<a class="el" href="classmlir_1_1FlatAffineConstraints.html#a6eda5ed3d07648239f51a58d283af25f">BoundType</a> type, <a class="el" href="classunsigned.html">unsigned</a> pos, int64_t <a class="el" href="InterfaceSupport_8h.html#a53ed1830bfcbea42b0e7b10281e03865">value</a>)</td></tr>
<tr class="memdesc:af1ebc66e64e3cd0f7eb89514664f786d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a constant bound for the specified identifier.  <a href="#af1ebc66e64e3cd0f7eb89514664f786d">More...</a><br /></td></tr>
<tr class="separator:af1ebc66e64e3cd0f7eb89514664f786d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad37e7bf9c07a76d9ea38b447d5c75742"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#ad37e7bf9c07a76d9ea38b447d5c75742">addBound</a> (<a class="el" href="classmlir_1_1FlatAffineConstraints.html#a6eda5ed3d07648239f51a58d283af25f">BoundType</a> type, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; expr, int64_t <a class="el" href="InterfaceSupport_8h.html#a53ed1830bfcbea42b0e7b10281e03865">value</a>)</td></tr>
<tr class="memdesc:ad37e7bf9c07a76d9ea38b447d5c75742"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a constant bound for the specified expression.  <a href="#ad37e7bf9c07a76d9ea38b447d5c75742">More...</a><br /></td></tr>
<tr class="separator:ad37e7bf9c07a76d9ea38b447d5c75742"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9ce04a3ec6c6baf9308f460ae14c751"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1IntegerSet.html">IntegerSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#ad9ce04a3ec6c6baf9308f460ae14c751">getAsIntegerSet</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context) const</td></tr>
<tr class="memdesc:ad9ce04a3ec6c6baf9308f460ae14c751"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the constraint system as an integer set.  <a href="#ad9ce04a3ec6c6baf9308f460ae14c751">More...</a><br /></td></tr>
<tr class="separator:ad9ce04a3ec6c6baf9308f460ae14c751"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27fe40151ae13ca4d10c425937ff70f2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a27fe40151ae13ca4d10c425937ff70f2">getSliceBounds</a> (<a class="el" href="classunsigned.html">unsigned</a> offset, <a class="el" href="classunsigned.html">unsigned</a> num, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt; *lbMaps, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt; *ubMaps)</td></tr>
<tr class="memdesc:a27fe40151ae13ca4d10c425937ff70f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the lower and upper bounds of the first <code>num</code> dimensional identifiers (starting at <code>offset</code>) as an affine map of the remaining identifiers (dimensional and symbolic).  <a href="#a27fe40151ae13ca4d10c425937ff70f2">More...</a><br /></td></tr>
<tr class="separator:a27fe40151ae13ca4d10c425937ff70f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a440a9b51c09ea27d100fb62fb32a7f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a9a440a9b51c09ea27d100fb62fb32a7f">addInequality</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; inEq)</td></tr>
<tr class="memdesc:a9a440a9b51c09ea27d100fb62fb32a7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an inequality (&gt;= 0) from the coefficients specified in <code>inEq</code>.  <a href="#a9a440a9b51c09ea27d100fb62fb32a7f">More...</a><br /></td></tr>
<tr class="separator:a9a440a9b51c09ea27d100fb62fb32a7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45df72c07b67e459ece93a1076344210"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a45df72c07b67e459ece93a1076344210">addEquality</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; eq)</td></tr>
<tr class="memdesc:a45df72c07b67e459ece93a1076344210"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an equality from the coefficients specified in <code>eq</code>.  <a href="#a45df72c07b67e459ece93a1076344210">More...</a><br /></td></tr>
<tr class="separator:a45df72c07b67e459ece93a1076344210"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d81cc0ca235dba7982f6cecc66f2506"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a9d81cc0ca235dba7982f6cecc66f2506">addLocalFloorDiv</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; dividend, int64_t divisor)</td></tr>
<tr class="memdesc:a9d81cc0ca235dba7982f6cecc66f2506"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a new local identifier as the floordiv of an affine function of other identifiers, the coefficients of which are provided in <code>dividend</code> and with respect to a positive constant <code>divisor</code>.  <a href="#a9d81cc0ca235dba7982f6cecc66f2506">More...</a><br /></td></tr>
<tr class="separator:a9d81cc0ca235dba7982f6cecc66f2506"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a926a9821dc4fa697619e08d65eeaeac5"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a926a9821dc4fa697619e08d65eeaeac5">swapId</a> (<a class="el" href="classunsigned.html">unsigned</a> posA, <a class="el" href="classunsigned.html">unsigned</a> posB)</td></tr>
<tr class="memdesc:a926a9821dc4fa697619e08d65eeaeac5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap the posA^th identifier with the posB^th identifier.  <a href="#a926a9821dc4fa697619e08d65eeaeac5">More...</a><br /></td></tr>
<tr class="separator:a926a9821dc4fa697619e08d65eeaeac5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79fc9ebec680aa4d6631f370d44489bd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a79fc9ebec680aa4d6631f370d44489bd">insertDimId</a> (<a class="el" href="classunsigned.html">unsigned</a> pos, <a class="el" href="classunsigned.html">unsigned</a> num=1)</td></tr>
<tr class="memdesc:a79fc9ebec680aa4d6631f370d44489bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert <code>num</code> identifiers of the specified kind at position <code>pos</code>.  <a href="#a79fc9ebec680aa4d6631f370d44489bd">More...</a><br /></td></tr>
<tr class="separator:a79fc9ebec680aa4d6631f370d44489bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27bc9f7ffaa98a041ecf68ec57bcefcd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a27bc9f7ffaa98a041ecf68ec57bcefcd">insertSymbolId</a> (<a class="el" href="classunsigned.html">unsigned</a> pos, <a class="el" href="classunsigned.html">unsigned</a> num=1)</td></tr>
<tr class="separator:a27bc9f7ffaa98a041ecf68ec57bcefcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa22f0aef1b34b0a585f7fb8a99b06388"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#aa22f0aef1b34b0a585f7fb8a99b06388">insertLocalId</a> (<a class="el" href="classunsigned.html">unsigned</a> pos, <a class="el" href="classunsigned.html">unsigned</a> num=1)</td></tr>
<tr class="separator:aa22f0aef1b34b0a585f7fb8a99b06388"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bf2f1aa4cfce8c357cfdb425c10bd36"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a2bf2f1aa4cfce8c357cfdb425c10bd36">insertId</a> (<a class="el" href="classmlir_1_1FlatAffineConstraints.html#ab47fbec6c4aff6faece95521b103fed2">IdKind</a> kind, <a class="el" href="classunsigned.html">unsigned</a> pos, <a class="el" href="classunsigned.html">unsigned</a> num=1)</td></tr>
<tr class="separator:a2bf2f1aa4cfce8c357cfdb425c10bd36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaaf4020f941e58d588596d8b7bfbb3b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#acaaf4020f941e58d588596d8b7bfbb3b">appendDimId</a> (<a class="el" href="classunsigned.html">unsigned</a> num=1)</td></tr>
<tr class="memdesc:acaaf4020f941e58d588596d8b7bfbb3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append <code>num</code> identifiers of the specified kind after the last identifier.  <a href="#acaaf4020f941e58d588596d8b7bfbb3b">More...</a><br /></td></tr>
<tr class="separator:acaaf4020f941e58d588596d8b7bfbb3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8d0cf47cf67fe28ad9641c0221ea5d0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#aa8d0cf47cf67fe28ad9641c0221ea5d0">appendSymbolId</a> (<a class="el" href="classunsigned.html">unsigned</a> num=1)</td></tr>
<tr class="separator:aa8d0cf47cf67fe28ad9641c0221ea5d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c5f81433086a0ba1a41fea86b246255"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a8c5f81433086a0ba1a41fea86b246255">appendLocalId</a> (<a class="el" href="classunsigned.html">unsigned</a> num=1)</td></tr>
<tr class="separator:a8c5f81433086a0ba1a41fea86b246255"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15f95bfc66876ee75db55381eafbb8f2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a15f95bfc66876ee75db55381eafbb8f2">composeMatchingMap</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> other)</td></tr>
<tr class="memdesc:a15f95bfc66876ee75db55381eafbb8f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Composes an affine map whose dimensions and symbols match one to one with the dimensions and symbols of this <a class="el" href="classmlir_1_1FlatAffineConstraints.html" title="A flat list of affine equalities and inequalities in the form. ">FlatAffineConstraints</a>.  <a href="#a15f95bfc66876ee75db55381eafbb8f2">More...</a><br /></td></tr>
<tr class="separator:a15f95bfc66876ee75db55381eafbb8f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63d1457dc3d54274c1519c6553be921d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a63d1457dc3d54274c1519c6553be921d">projectOut</a> (<a class="el" href="classunsigned.html">unsigned</a> pos, <a class="el" href="classunsigned.html">unsigned</a> num)</td></tr>
<tr class="memdesc:a63d1457dc3d54274c1519c6553be921d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Projects out (aka eliminates) <code>num</code> identifiers starting at position <code>pos</code>.  <a href="#a63d1457dc3d54274c1519c6553be921d">More...</a><br /></td></tr>
<tr class="separator:a63d1457dc3d54274c1519c6553be921d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c3d0c1b0bad5d54e4b5f91910c52503"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a8c3d0c1b0bad5d54e4b5f91910c52503">projectOut</a> (<a class="el" href="classunsigned.html">unsigned</a> pos)</td></tr>
<tr class="separator:a8c3d0c1b0bad5d54e4b5f91910c52503"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6953eccc1eb2884e95680dc7994c06b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#ac6953eccc1eb2884e95680dc7994c06b">removeId</a> (<a class="el" href="classmlir_1_1FlatAffineConstraints.html#ab47fbec6c4aff6faece95521b103fed2">IdKind</a> kind, <a class="el" href="classunsigned.html">unsigned</a> pos)</td></tr>
<tr class="memdesc:ac6953eccc1eb2884e95680dc7994c06b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes identifiers of the specified kind with the specified pos (or within the specified range) from the system.  <a href="#ac6953eccc1eb2884e95680dc7994c06b">More...</a><br /></td></tr>
<tr class="separator:ac6953eccc1eb2884e95680dc7994c06b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80a92ac0a8ca842b0c43d235ce86a4fc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a80a92ac0a8ca842b0c43d235ce86a4fc">removeIdRange</a> (<a class="el" href="classmlir_1_1FlatAffineConstraints.html#ab47fbec6c4aff6faece95521b103fed2">IdKind</a> kind, <a class="el" href="classunsigned.html">unsigned</a> idStart, <a class="el" href="classunsigned.html">unsigned</a> idLimit)</td></tr>
<tr class="separator:a80a92ac0a8ca842b0c43d235ce86a4fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7e3fb602c03ba136b94b31a58bca727"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#aa7e3fb602c03ba136b94b31a58bca727">removeId</a> (<a class="el" href="classunsigned.html">unsigned</a> pos)</td></tr>
<tr class="memdesc:aa7e3fb602c03ba136b94b31a58bca727"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the specified identifier from the system.  <a href="#aa7e3fb602c03ba136b94b31a58bca727">More...</a><br /></td></tr>
<tr class="separator:aa7e3fb602c03ba136b94b31a58bca727"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3d4894b1c67f1e06424e1453c585bbf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#ae3d4894b1c67f1e06424e1453c585bbf">removeEquality</a> (<a class="el" href="classunsigned.html">unsigned</a> pos)</td></tr>
<tr class="separator:ae3d4894b1c67f1e06424e1453c585bbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82531e4f08beebf1338bf1ac5207475b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a82531e4f08beebf1338bf1ac5207475b">removeInequality</a> (<a class="el" href="classunsigned.html">unsigned</a> pos)</td></tr>
<tr class="separator:a82531e4f08beebf1338bf1ac5207475b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24e9ea709b9d11a7cfd9899aa9fefc39"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a24e9ea709b9d11a7cfd9899aa9fefc39">removeEqualityRange</a> (<a class="el" href="classunsigned.html">unsigned</a> start, <a class="el" href="classunsigned.html">unsigned</a> end)</td></tr>
<tr class="memdesc:a24e9ea709b9d11a7cfd9899aa9fefc39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the (in)equalities at positions [start, end).  <a href="#a24e9ea709b9d11a7cfd9899aa9fefc39">More...</a><br /></td></tr>
<tr class="separator:a24e9ea709b9d11a7cfd9899aa9fefc39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6695090f5659966f8aeeb44f9491d861"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a6695090f5659966f8aeeb44f9491d861">removeInequalityRange</a> (<a class="el" href="classunsigned.html">unsigned</a> start, <a class="el" href="classunsigned.html">unsigned</a> end)</td></tr>
<tr class="separator:a6695090f5659966f8aeeb44f9491d861"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c88dcf47e95f1973d1f2bb5f40979e5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a1c88dcf47e95f1973d1f2bb5f40979e5">setAndEliminate</a> (<a class="el" href="classunsigned.html">unsigned</a> pos, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; values)</td></tr>
<tr class="memdesc:a1c88dcf47e95f1973d1f2bb5f40979e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the <code>values.size()</code> identifiers starting at <code>po</code>s to the specified values and removes them.  <a href="#a1c88dcf47e95f1973d1f2bb5f40979e5">More...</a><br /></td></tr>
<tr class="separator:a1c88dcf47e95f1973d1f2bb5f40979e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4924b4c54d6823f8e52933ca960c1ff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#ad4924b4c54d6823f8e52933ca960c1ff">setDimSymbolSeparation</a> (<a class="el" href="classunsigned.html">unsigned</a> newSymbolCount)</td></tr>
<tr class="memdesc:ad4924b4c54d6823f8e52933ca960c1ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the partition between dimensions and symbols.  <a href="#ad4924b4c54d6823f8e52933ca960c1ff">More...</a><br /></td></tr>
<tr class="separator:ad4924b4c54d6823f8e52933ca960c1ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00e1041e7db596d628253f1d8d7c8222"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a00e1041e7db596d628253f1d8d7c8222">constantFoldId</a> (<a class="el" href="classunsigned.html">unsigned</a> pos)</td></tr>
<tr class="memdesc:a00e1041e7db596d628253f1d8d7c8222"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to fold the specified identifier to a constant using a trivial equality detection; if successful, the constant is substituted for the identifier everywhere in the constraint system and then removed from the system.  <a href="#a00e1041e7db596d628253f1d8d7c8222">More...</a><br /></td></tr>
<tr class="separator:a00e1041e7db596d628253f1d8d7c8222"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad67b4c81a969b09cf5c4bc723cda93d5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#ad67b4c81a969b09cf5c4bc723cda93d5">constantFoldIdRange</a> (<a class="el" href="classunsigned.html">unsigned</a> pos, <a class="el" href="classunsigned.html">unsigned</a> num)</td></tr>
<tr class="memdesc:ad67b4c81a969b09cf5c4bc723cda93d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method calls <code>constantFoldId</code> for the specified range of identifiers, <code>num</code> identifiers starting at position <code>pos</code>.  <a href="#ad67b4c81a969b09cf5c4bc723cda93d5">More...</a><br /></td></tr>
<tr class="separator:ad67b4c81a969b09cf5c4bc723cda93d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afeb8348eba3bd5c81db503336ae2ebfc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#afeb8348eba3bd5c81db503336ae2ebfc">unionBoundingBox</a> (const <a class="el" href="classmlir_1_1FlatAffineConstraints.html">FlatAffineConstraints</a> &amp;other)</td></tr>
<tr class="memdesc:afeb8348eba3bd5c81db503336ae2ebfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the constraints to be the smallest bounding (enclosing) box that contains the points of <code>this</code> set and that of <code>other</code>, with the symbols being treated specially.  <a href="#afeb8348eba3bd5c81db503336ae2ebfc">More...</a><br /></td></tr>
<tr class="separator:afeb8348eba3bd5c81db503336ae2ebfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a747fa3994a809e5994fdc32035b54e4b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a747fa3994a809e5994fdc32035b54e4b">getNumConstraints</a> () const</td></tr>
<tr class="separator:a747fa3994a809e5994fdc32035b54e4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0937c7d6a0a23146fbc6d5caf5e95a8b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a0937c7d6a0a23146fbc6d5caf5e95a8b">getNumIds</a> () const</td></tr>
<tr class="separator:a0937c7d6a0a23146fbc6d5caf5e95a8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bb25117553419fb47427704e6c9bb84"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a0bb25117553419fb47427704e6c9bb84">getNumDimIds</a> () const</td></tr>
<tr class="separator:a0bb25117553419fb47427704e6c9bb84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff8074c726e597eb5a963a68451bb7fe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#aff8074c726e597eb5a963a68451bb7fe">getNumSymbolIds</a> () const</td></tr>
<tr class="separator:aff8074c726e597eb5a963a68451bb7fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a221a2c98d7a9019f0a93cb1b070152f3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a221a2c98d7a9019f0a93cb1b070152f3">getNumDimAndSymbolIds</a> () const</td></tr>
<tr class="separator:a221a2c98d7a9019f0a93cb1b070152f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab12365660bdc368e87b6fc73f12e3e86"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#ab12365660bdc368e87b6fc73f12e3e86">getNumLocalIds</a> () const</td></tr>
<tr class="separator:ab12365660bdc368e87b6fc73f12e3e86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac662ea0313d9bcac2e44925b6be670e8"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#ac662ea0313d9bcac2e44925b6be670e8">clearAndCopyFrom</a> (const <a class="el" href="classmlir_1_1FlatAffineConstraints.html">FlatAffineConstraints</a> &amp;other)</td></tr>
<tr class="memdesc:ac662ea0313d9bcac2e44925b6be670e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the contents of this <a class="el" href="classmlir_1_1FlatAffineConstraints.html" title="A flat list of affine equalities and inequalities in the form. ">FlatAffineConstraints</a> with <code>other</code>.  <a href="#ac662ea0313d9bcac2e44925b6be670e8">More...</a><br /></td></tr>
<tr class="separator:ac662ea0313d9bcac2e44925b6be670e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acee472dcf0f37342df02e5af53b7aa45"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#acee472dcf0f37342df02e5af53b7aa45">getConstantBoundOnDimSize</a> (<a class="el" href="classunsigned.html">unsigned</a> pos, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; int64_t &gt; *lb=nullptr, int64_t *boundFloorDivisor=nullptr, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; int64_t &gt; *ub=nullptr, <a class="el" href="classunsigned.html">unsigned</a> *minLbPos=nullptr, <a class="el" href="classunsigned.html">unsigned</a> *minUbPos=nullptr) const</td></tr>
<tr class="memdesc:acee472dcf0f37342df02e5af53b7aa45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the smallest known constant bound for the extent of the specified identifier (pos^th), i.e., the smallest known constant that is greater than or equal to 'exclusive upper bound' - 'lower bound' of the identifier.  <a href="#acee472dcf0f37342df02e5af53b7aa45">More...</a><br /></td></tr>
<tr class="separator:acee472dcf0f37342df02e5af53b7aa45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaee57edfdfaaff4c7a33c52ddbb94ca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#aeaee57edfdfaaff4c7a33c52ddbb94ca">getConstantBound</a> (<a class="el" href="classmlir_1_1FlatAffineConstraints.html#a6eda5ed3d07648239f51a58d283af25f">BoundType</a> type, <a class="el" href="classunsigned.html">unsigned</a> pos) const</td></tr>
<tr class="memdesc:aeaee57edfdfaaff4c7a33c52ddbb94ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the constant bound for the pos^th identifier if there is one; None otherwise.  <a href="#aeaee57edfdfaaff4c7a33c52ddbb94ca">More...</a><br /></td></tr>
<tr class="separator:aeaee57edfdfaaff4c7a33c52ddbb94ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad0cdbe1cff606a9b364e734ca09dc52"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>, <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#aad0cdbe1cff606a9b364e734ca09dc52">getLowerAndUpperBound</a> (<a class="el" href="classunsigned.html">unsigned</a> pos, <a class="el" href="classunsigned.html">unsigned</a> offset, <a class="el" href="classunsigned.html">unsigned</a> num, <a class="el" href="classunsigned.html">unsigned</a> symStartPos, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt; localExprs, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context) const</td></tr>
<tr class="memdesc:aad0cdbe1cff606a9b364e734ca09dc52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the lower and upper bound of the <code>offset</code> + <code>pos</code>th identifier treating [0, offset) U [offset + num, symStartPos) as dimensions and [symStartPos, getNumDimAndSymbolIds) as symbols, and <code>pos</code> lies in [0, num).  <a href="#aad0cdbe1cff606a9b364e734ca09dc52">More...</a><br /></td></tr>
<tr class="separator:aad0cdbe1cff606a9b364e734ca09dc52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a689a4d485fa39f9e1aa03e78c455a363"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a689a4d485fa39f9e1aa03e78c455a363">getLowerAndUpperBoundIndices</a> (<a class="el" href="classunsigned.html">unsigned</a> pos, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt; *lbIndices, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt; *ubIndices, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt; *eqIndices=nullptr, <a class="el" href="classunsigned.html">unsigned</a> offset=0, <a class="el" href="classunsigned.html">unsigned</a> num=0) const</td></tr>
<tr class="memdesc:a689a4d485fa39f9e1aa03e78c455a363"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gather positions of all lower and upper bounds of the identifier at <code>pos</code>, and optionally any equalities on it.  <a href="#a689a4d485fa39f9e1aa03e78c455a363">More...</a><br /></td></tr>
<tr class="separator:a689a4d485fa39f9e1aa03e78c455a363"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9dbede371ec7b45452b41c7ecc7045e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#ac9dbede371ec7b45452b41c7ecc7045e">removeIndependentConstraints</a> (<a class="el" href="classunsigned.html">unsigned</a> pos, <a class="el" href="classunsigned.html">unsigned</a> num)</td></tr>
<tr class="memdesc:ac9dbede371ec7b45452b41c7ecc7045e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes constraints that are independent of (i.e., do not have a coefficient) identifiers in the range [pos, pos + num).  <a href="#ac9dbede371ec7b45452b41c7ecc7045e">More...</a><br /></td></tr>
<tr class="separator:ac9dbede371ec7b45452b41c7ecc7045e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa635e50de116843fba9c4d6213ce14c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#afa635e50de116843fba9c4d6213ce14c">isHyperRectangular</a> (<a class="el" href="classunsigned.html">unsigned</a> pos, <a class="el" href="classunsigned.html">unsigned</a> num) const</td></tr>
<tr class="memdesc:afa635e50de116843fba9c4d6213ce14c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the set can be trivially detected as being hyper-rectangular on the specified contiguous set of identifiers.  <a href="#afa635e50de116843fba9c4d6213ce14c">More...</a><br /></td></tr>
<tr class="separator:afa635e50de116843fba9c4d6213ce14c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3a710d4a8812b2e76eb3908a5767dac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#ab3a710d4a8812b2e76eb3908a5767dac">removeTrivialRedundancy</a> ()</td></tr>
<tr class="memdesc:ab3a710d4a8812b2e76eb3908a5767dac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes duplicate constraints, trivially true constraints, and constraints that can be detected as redundant as a result of differing only in their constant term part.  <a href="#ab3a710d4a8812b2e76eb3908a5767dac">More...</a><br /></td></tr>
<tr class="separator:ab3a710d4a8812b2e76eb3908a5767dac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60b9abcf1ae4683b7ed214125d4d05c8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a60b9abcf1ae4683b7ed214125d4d05c8">removeRedundantInequalities</a> ()</td></tr>
<tr class="memdesc:a60b9abcf1ae4683b7ed214125d4d05c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">A more expensive check than <code>removeTrivialRedundancy</code> to detect redundant inequalities.  <a href="#a60b9abcf1ae4683b7ed214125d4d05c8">More...</a><br /></td></tr>
<tr class="separator:a60b9abcf1ae4683b7ed214125d4d05c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9d4b723904aafdfe34740b766c78789"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#ae9d4b723904aafdfe34740b766c78789">removeRedundantConstraints</a> ()</td></tr>
<tr class="memdesc:ae9d4b723904aafdfe34740b766c78789"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes redundant constraints using <a class="el" href="classmlir_1_1Simplex.html" title="This class implements a version of the Simplex and Generalized Basis Reduction algorithms, which can perform analysis of integer sets with affine inequalities and equalities. ">Simplex</a>.  <a href="#ae9d4b723904aafdfe34740b766c78789">More...</a><br /></td></tr>
<tr class="separator:ae9d4b723904aafdfe34740b766c78789"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27e9d04e72add0e58c934cae62413ac7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a27e9d04e72add0e58c934cae62413ac7">convertDimToLocal</a> (<a class="el" href="classunsigned.html">unsigned</a> dimStart, <a class="el" href="classunsigned.html">unsigned</a> dimLimit)</td></tr>
<tr class="memdesc:a27e9d04e72add0e58c934cae62413ac7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts identifiers in the column range [idStart, idLimit) to local variables.  <a href="#a27e9d04e72add0e58c934cae62413ac7">More...</a><br /></td></tr>
<tr class="separator:a27e9d04e72add0e58c934cae62413ac7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0b82371642e5a1db0e6125f07b3713f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#ae0b82371642e5a1db0e6125f07b3713f">mergeLocalIds</a> (<a class="el" href="classmlir_1_1FlatAffineConstraints.html">FlatAffineConstraints</a> &amp;other)</td></tr>
<tr class="memdesc:ae0b82371642e5a1db0e6125f07b3713f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds additional local ids to the sets such that they both have the union of the local ids in each set, without changing the set of points that lie in <code>this</code> and <code>other</code>.  <a href="#ae0b82371642e5a1db0e6125f07b3713f">More...</a><br /></td></tr>
<tr class="separator:ae0b82371642e5a1db0e6125f07b3713f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b4985a33143cd113df0f945c2bb6d8b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a4b4985a33143cd113df0f945c2bb6d8b">clearConstraints</a> ()</td></tr>
<tr class="memdesc:a4b4985a33143cd113df0f945c2bb6d8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all equalities and inequalities.  <a href="#a4b4985a33143cd113df0f945c2bb6d8b">More...</a><br /></td></tr>
<tr class="separator:a4b4985a33143cd113df0f945c2bb6d8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32f2f50452ba560992138f6df070045e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a32f2f50452ba560992138f6df070045e">print</a> (raw_ostream &amp;os) const</td></tr>
<tr class="separator:a32f2f50452ba560992138f6df070045e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9755c04bef03df1b8130b1a4e76ac605"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a9755c04bef03df1b8130b1a4e76ac605">dump</a> () const</td></tr>
<tr class="separator:a9755c04bef03df1b8130b1a4e76ac605"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:abe0c6f1821da05edc091e82d187e0e10"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1FlatAffineConstraints.html">FlatAffineConstraints</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#abe0c6f1821da05edc091e82d187e0e10">getUniverse</a> (<a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="classmlir_1_1FlatAffineConstraints.html#a2202d24f4dfb178dd579cceb9a81d552">numDims</a>=0, <a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="classmlir_1_1FlatAffineConstraints.html#a8ec0168aae7454795c0a4939f2230642">numSymbols</a>=0)</td></tr>
<tr class="memdesc:abe0c6f1821da05edc091e82d187e0e10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a system with no constraints, i.e., one which is satisfied by all points.  <a href="#abe0c6f1821da05edc091e82d187e0e10">More...</a><br /></td></tr>
<tr class="separator:abe0c6f1821da05edc091e82d187e0e10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a353de0786de4cb7459611d4219ba0bcd"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a353de0786de4cb7459611d4219ba0bcd">classof</a> (const <a class="el" href="classmlir_1_1FlatAffineConstraints.html">FlatAffineConstraints</a> *cst)</td></tr>
<tr class="separator:a353de0786de4cb7459611d4219ba0bcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a17a14cb3eb220c8b9926268a0f994110"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a17a14cb3eb220c8b9926268a0f994110">getIdKindOffset</a> (<a class="el" href="classmlir_1_1FlatAffineConstraints.html#ab47fbec6c4aff6faece95521b103fed2">IdKind</a> kind) const</td></tr>
<tr class="memdesc:a17a14cb3eb220c8b9926268a0f994110"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the index at which the specified kind of id starts.  <a href="#a17a14cb3eb220c8b9926268a0f994110">More...</a><br /></td></tr>
<tr class="separator:a17a14cb3eb220c8b9926268a0f994110"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea0d219f6b966b3fed07165f4e5e5ae3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#aea0d219f6b966b3fed07165f4e5e5ae3">assertAtMostNumIdKind</a> (<a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="InterfaceSupport_8h.html#a53ed1830bfcbea42b0e7b10281e03865">value</a>, <a class="el" href="classmlir_1_1FlatAffineConstraints.html#ab47fbec6c4aff6faece95521b103fed2">IdKind</a> kind) const</td></tr>
<tr class="memdesc:aea0d219f6b966b3fed07165f4e5e5ae3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assert that <code>value</code> is at most the number of ids of the specified kind.  <a href="#aea0d219f6b966b3fed07165f4e5e5ae3">More...</a><br /></td></tr>
<tr class="separator:aea0d219f6b966b3fed07165f4e5e5ae3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0803bcab8d26f4efbca03765c15973d3"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a0803bcab8d26f4efbca03765c15973d3">hasConsistentState</a> () const</td></tr>
<tr class="memdesc:a0803bcab8d26f4efbca03765c15973d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns false if the fields corresponding to various identifier counts, or equality/inequality buffer sizes aren't consistent; true otherwise.  <a href="#a0803bcab8d26f4efbca03765c15973d3">More...</a><br /></td></tr>
<tr class="separator:a0803bcab8d26f4efbca03765c15973d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a463bb136705774c5730444a1f0b48274"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a463bb136705774c5730444a1f0b48274">hasInvalidConstraint</a> () const</td></tr>
<tr class="memdesc:a463bb136705774c5730444a1f0b48274"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks all rows of equality/inequality constraints for trivial contradictions (for example: 1 == 0, 0 &gt;= 1), which may have surfaced after elimination.  <a href="#a463bb136705774c5730444a1f0b48274">More...</a><br /></td></tr>
<tr class="separator:a463bb136705774c5730444a1f0b48274"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48d2dbd6016eb6489a8bea183064194d"><td class="memTemplParams" colspan="2">template&lt;bool isLower&gt; </td></tr>
<tr class="memitem:a48d2dbd6016eb6489a8bea183064194d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; int64_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a48d2dbd6016eb6489a8bea183064194d">computeConstantLowerOrUpperBound</a> (<a class="el" href="classunsigned.html">unsigned</a> pos)</td></tr>
<tr class="memdesc:a48d2dbd6016eb6489a8bea183064194d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the constant lower bound bound if isLower is true, and the upper bound if isLower is false.  <a href="#a48d2dbd6016eb6489a8bea183064194d">More...</a><br /></td></tr>
<tr class="separator:a48d2dbd6016eb6489a8bea183064194d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38c97661a1c86284a9102a06018c7292"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a38c97661a1c86284a9102a06018c7292">flattenAlignedMapAndMergeLocals</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> map, std::vector&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t, 8 &gt;&gt; *flattenedExprs)</td></tr>
<tr class="memdesc:a38c97661a1c86284a9102a06018c7292"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an affine map that is aligned with this constraint system:  <a href="#a38c97661a1c86284a9102a06018c7292">More...</a><br /></td></tr>
<tr class="separator:a38c97661a1c86284a9102a06018c7292"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a881e2217448214b13d07e90b0b53bc0c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a881e2217448214b13d07e90b0b53bc0c">gaussianEliminateId</a> (<a class="el" href="classunsigned.html">unsigned</a> position)</td></tr>
<tr class="memdesc:a881e2217448214b13d07e90b0b53bc0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Eliminates a single identifier at <code>position</code> from equality and inequality constraints.  <a href="#a881e2217448214b13d07e90b0b53bc0c">More...</a><br /></td></tr>
<tr class="separator:a881e2217448214b13d07e90b0b53bc0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9208d76671184c970f66b656b3a5879"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#af9208d76671184c970f66b656b3a5879">removeRedundantLocalVars</a> ()</td></tr>
<tr class="memdesc:af9208d76671184c970f66b656b3a5879"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes local variables using equalities.  <a href="#af9208d76671184c970f66b656b3a5879">More...</a><br /></td></tr>
<tr class="separator:af9208d76671184c970f66b656b3a5879"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac976d9ff1b446d2c09838299bf465d4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#aac976d9ff1b446d2c09838299bf465d4">gaussianEliminateIds</a> (<a class="el" href="classunsigned.html">unsigned</a> posStart, <a class="el" href="classunsigned.html">unsigned</a> posLimit)</td></tr>
<tr class="memdesc:aac976d9ff1b446d2c09838299bf465d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Eliminates identifiers from equality and inequality constraints in column range [posStart, posLimit).  <a href="#aac976d9ff1b446d2c09838299bf465d4">More...</a><br /></td></tr>
<tr class="separator:aac976d9ff1b446d2c09838299bf465d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a74c3f513f68972c677b4a104fe68b5"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a8a74c3f513f68972c677b4a104fe68b5">fourierMotzkinEliminate</a> (<a class="el" href="classunsigned.html">unsigned</a> pos, bool darkShadow=false, bool *isResultIntegerExact=nullptr)</td></tr>
<tr class="memdesc:a8a74c3f513f68972c677b4a104fe68b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Eliminates the identifier at the specified position using Fourier-Motzkin variable elimination, but uses Gaussian elimination if there is an equality involving that identifier.  <a href="#a8a74c3f513f68972c677b4a104fe68b5">More...</a><br /></td></tr>
<tr class="separator:a8a74c3f513f68972c677b4a104fe68b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9131602623a80474f09f4c556a72c2fa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a9131602623a80474f09f4c556a72c2fa">gcdTightenInequalities</a> ()</td></tr>
<tr class="memdesc:a9131602623a80474f09f4c556a72c2fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tightens inequalities given that we are dealing with integer spaces.  <a href="#a9131602623a80474f09f4c556a72c2fa">More...</a><br /></td></tr>
<tr class="separator:a9131602623a80474f09f4c556a72c2fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72473a5174d309b4dca1dba327ff901e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a72473a5174d309b4dca1dba327ff901e">normalizeConstraintsByGCD</a> ()</td></tr>
<tr class="memdesc:a72473a5174d309b4dca1dba327ff901e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalized each constraints by the GCD of its coefficients.  <a href="#a72473a5174d309b4dca1dba327ff901e">More...</a><br /></td></tr>
<tr class="separator:a72473a5174d309b4dca1dba327ff901e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54db163f9d82617265f1a1166667d114"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a54db163f9d82617265f1a1166667d114">removeIdRange</a> (<a class="el" href="classunsigned.html">unsigned</a> idStart, <a class="el" href="classunsigned.html">unsigned</a> idLimit)</td></tr>
<tr class="memdesc:a54db163f9d82617265f1a1166667d114"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes identifiers in the column range [idStart, idLimit), and copies any remaining valid data into place, updates member variables, and resizes arrays as needed.  <a href="#a54db163f9d82617265f1a1166667d114">More...</a><br /></td></tr>
<tr class="separator:a54db163f9d82617265f1a1166667d114"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:ad724bee0d8c9f91d7e5884b098c5e929"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#ad724bee0d8c9f91d7e5884b098c5e929">numIds</a></td></tr>
<tr class="memdesc:ad724bee0d8c9f91d7e5884b098c5e929"><td class="mdescLeft">&#160;</td><td class="mdescRight">Total number of identifiers.  <a href="#ad724bee0d8c9f91d7e5884b098c5e929">More...</a><br /></td></tr>
<tr class="separator:ad724bee0d8c9f91d7e5884b098c5e929"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2202d24f4dfb178dd579cceb9a81d552"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a2202d24f4dfb178dd579cceb9a81d552">numDims</a></td></tr>
<tr class="memdesc:a2202d24f4dfb178dd579cceb9a81d552"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of identifiers corresponding to real dimensions.  <a href="#a2202d24f4dfb178dd579cceb9a81d552">More...</a><br /></td></tr>
<tr class="separator:a2202d24f4dfb178dd579cceb9a81d552"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ec0168aae7454795c0a4939f2230642"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a8ec0168aae7454795c0a4939f2230642">numSymbols</a></td></tr>
<tr class="memdesc:a8ec0168aae7454795c0a4939f2230642"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of identifiers corresponding to symbols (unknown but constant for analysis).  <a href="#a8ec0168aae7454795c0a4939f2230642">More...</a><br /></td></tr>
<tr class="separator:a8ec0168aae7454795c0a4939f2230642"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9b8780712cd511c02db2cac6fc642c3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Matrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#af9b8780712cd511c02db2cac6fc642c3">equalities</a></td></tr>
<tr class="memdesc:af9b8780712cd511c02db2cac6fc642c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Coefficients of affine equalities (in == 0 form).  <a href="#af9b8780712cd511c02db2cac6fc642c3">More...</a><br /></td></tr>
<tr class="separator:af9b8780712cd511c02db2cac6fc642c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab66ed19c85ef3b3b54a38b50edddc85d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Matrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#ab66ed19c85ef3b3b54a38b50edddc85d">inequalities</a></td></tr>
<tr class="memdesc:ab66ed19c85ef3b3b54a38b50edddc85d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Coefficients of affine inequalities (in &gt;= 0 form).  <a href="#ab66ed19c85ef3b3b54a38b50edddc85d">More...</a><br /></td></tr>
<tr class="separator:ab66ed19c85ef3b3b54a38b50edddc85d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-attribs"></a>
Static Protected Attributes</h2></td></tr>
<tr class="memitem:a436d362961b4fbd768187df180d6425d"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a436d362961b4fbd768187df180d6425d">kExplosionFactor</a> = 32</td></tr>
<tr class="memdesc:a436d362961b4fbd768187df180d6425d"><td class="mdescLeft">&#160;</td><td class="mdescRight">A parameter that controls detection of an unrealistic number of constraints.  <a href="#a436d362961b4fbd768187df180d6425d">More...</a><br /></td></tr>
<tr class="separator:a436d362961b4fbd768187df180d6425d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A flat list of affine equalities and inequalities in the form. </p>
<p>Inequality: c_0*x_0 + c_1*x_1 + .... + c_{n-1}*x_{n-1} &gt;= 0 Equality: c_0*x_0 + c_1*x_1 + .... + c_{n-1}*x_{n-1} == 0</p>
<p><a class="el" href="classmlir_1_1FlatAffineConstraints.html" title="A flat list of affine equalities and inequalities in the form. ">FlatAffineConstraints</a> stores coefficients in a contiguous buffer (one buffer for equalities and one for inequalities). The size of each buffer is numReservedCols * number of inequalities (or equalities). The reserved size is numReservedCols * numReservedInequalities (or numReservedEqualities). A coefficient (r, c) lives at the location numReservedCols * r + c in the buffer. The extra space between <a class="el" href="classmlir_1_1FlatAffineConstraints.html#ad6dafa2401aead0909b87b92d41bfbbd" title="Returns the number of columns in the constraint system. ">getNumCols()</a> and numReservedCols exists to prevent frequent movement of data when adding columns, especially at the end.</p>
<p>The identifiers x_0, x_1, ... appear in the order: dimensional identifiers, symbolic identifiers, and local identifiers. The local identifiers correspond to local/internal variables created when converting from <a class="el" href="classmlir_1_1AffineExpr.html" title="Base type for affine expression. ">AffineExpr</a>'s containing mod's and div's; they are thus needed to increase representational power. Each local identifier is always (by construction) a floordiv of a pure add/mul affine function of dimensional, symbolic, and other local identifiers, in a non-mutually recursive way. Hence, every local identifier can ultimately always be recovered as an affine function of dimensional and symbolic identifiers (involving floordiv's); note however that some floordiv combinations are converted to mod's by <a class="el" href="classmlir_1_1AffineExpr.html" title="Base type for affine expression. ">AffineExpr</a> construction. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8h_source.html#l00059">59</a> of file <a class="el" href="AffineStructures_8h_source.html">AffineStructures.h</a>.</p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a6eda5ed3d07648239f51a58d283af25f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6eda5ed3d07648239f51a58d283af25f">&#9670;&nbsp;</a></span>BoundType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classmlir_1_1FlatAffineConstraints.html#a6eda5ed3d07648239f51a58d283af25f">mlir::FlatAffineConstraints::BoundType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of bound: equal, lower bound or upper bound. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a6eda5ed3d07648239f51a58d283af25fa819c60666bda38d2d84f3b3b1cc85353"></a>EQ&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a6eda5ed3d07648239f51a58d283af25fadbdfcad083981238050dde5e628d9906"></a>LB&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a6eda5ed3d07648239f51a58d283af25fa6f0c4e378019df95f41471d395927fd4"></a>UB&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8h_source.html#l00216">216</a> of file <a class="el" href="AffineStructures_8h_source.html">AffineStructures.h</a>.</p>

</div>
</div>
<a id="ab47fbec6c4aff6faece95521b103fed2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab47fbec6c4aff6faece95521b103fed2">&#9670;&nbsp;</a></span>IdKind</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classmlir_1_1FlatAffineConstraints.html#ab47fbec6c4aff6faece95521b103fed2">mlir::FlatAffineConstraints::IdKind</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Kind of identifier (column). </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ab47fbec6c4aff6faece95521b103fed2a2ee94b4e0a594b0b54351659320e6ba7"></a>Dimension&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ab47fbec6c4aff6faece95521b103fed2ae3c7272b03244406768692d4fea34372"></a>Symbol&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ab47fbec6c4aff6faece95521b103fed2a5cbad5ec78394bb35d4d33f15993f778"></a>Local&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8h_source.html#l00065">65</a> of file <a class="el" href="AffineStructures_8h_source.html">AffineStructures.h</a>.</p>

</div>
</div>
<a id="ac7022f51854ec1d369bb150035a1437f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7022f51854ec1d369bb150035a1437f">&#9670;&nbsp;</a></span>Kind</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classmlir_1_1FlatAffineConstraints.html#ac7022f51854ec1d369bb150035a1437f">mlir::FlatAffineConstraints::Kind</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>All derived classes of <a class="el" href="classmlir_1_1FlatAffineConstraints.html" title="A flat list of affine equalities and inequalities in the form. ">FlatAffineConstraints</a>. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ac7022f51854ec1d369bb150035a1437fa5d3c39d196a997e225b4f3ee3e1da745"></a>FlatAffineConstraints&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ac7022f51854ec1d369bb150035a1437fa38bdec3fb5cb6b2e66b5acddb32f9cb4"></a>FlatAffineValueConstraints&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8h_source.html#l00062">62</a> of file <a class="el" href="AffineStructures_8h_source.html">AffineStructures.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ad696d4f93b157c44fec1e3965e850433"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad696d4f93b157c44fec1e3965e850433">&#9670;&nbsp;</a></span>FlatAffineConstraints() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mlir::FlatAffineConstraints::FlatAffineConstraints </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>numReservedInequalities</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>numReservedEqualities</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>numReservedCols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>numDims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>numSymbols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>numLocals</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a constraint system reserving memory for the specified number of constraints and identifiers. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8h_source.html#l00069">69</a> of file <a class="el" href="AffineStructures_8h_source.html">AffineStructures.h</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8h_source.html#l00545">numIds</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l02181">getSliceBounds()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l00235">reset()</a>.</p>

</div>
</div>
<a id="ac128caef8d1284314f3220982733a7df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac128caef8d1284314f3220982733a7df">&#9670;&nbsp;</a></span>FlatAffineConstraints() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mlir::FlatAffineConstraints::FlatAffineConstraints </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>numDims</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>numSymbols</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>numLocals</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a constraint system with the specified number of dimensions and symbols. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8h_source.html#l00082">82</a> of file <a class="el" href="AffineStructures_8h_source.html">AffineStructures.h</a>.</p>

</div>
</div>
<a id="a04009cfc4f3c97dbff1cf9594c0f7c9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04009cfc4f3c97dbff1cf9594c0f7c9a">&#9670;&nbsp;</a></span>FlatAffineConstraints() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FlatAffineConstraints::FlatAffineConstraints </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1IntegerSet.html">IntegerSet</a>&#160;</td>
          <td class="paramname"><em>set</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an affine constraint system from an <a class="el" href="classmlir_1_1IntegerSet.html" title="An integer set representing a conjunction of one or more affine equalities and inequalities. ">IntegerSet</a>. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l00159">159</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8cpp_source.html#l02519">addEquality()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02526">addInequality()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00286">append()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00327">appendLocalId()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">mlir::failed()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00120">mlir::getFlattenedAffineExprs()</a>, <a class="el" href="AffineStructures_8h_source.html#l00191">getNumCols()</a>, and <a class="el" href="AffineStructures_8h_source.html#l00357">getNumLocalIds()</a>.</p>

</div>
</div>
<a id="a8074122b77beb705d010169667ae9efe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8074122b77beb705d010169667ae9efe">&#9670;&nbsp;</a></span>FlatAffineConstraints() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mlir::FlatAffineConstraints::FlatAffineConstraints </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1MutableAffineMap.html">MutableAffineMap</a> &amp;&#160;</td>
          <td class="paramname"><em>map</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a948c10906e0c0a4ab77176a31035a73b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a948c10906e0c0a4ab77176a31035a73b">&#9670;&nbsp;</a></span>~FlatAffineConstraints()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual mlir::FlatAffineConstraints::~FlatAffineConstraints </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="AffineStructures_8h_source.html#l00092">getUniverse()</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a520de7a96a9cdf5130756e58a42e6371"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a520de7a96a9cdf5130756e58a42e6371">&#9670;&nbsp;</a></span>addBound() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> FlatAffineConstraints::addBound </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a6eda5ed3d07648239f51a58d283af25f">BoundType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>boundMap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a bound for the identifier at the specified position with constraints being drawn from the specified bound map. </p>
<p>In case of an EQ bound, the bound map is expected to have exactly one result. In case of a LB/UB, the bound map may have more than one result, for each of which an inequality is added. Note: The dimensions/symbols of this <a class="el" href="classmlir_1_1FlatAffineConstraints.html" title="A flat list of affine equalities and inequalities in the form. ">FlatAffineConstraints</a> must match the dimensions/symbols of the affine map. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l02376">2376</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8cpp_source.html#l02519">addEquality()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02526">addInequality()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">mlir::failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02352">flattenAlignedMapAndMergeLocals()</a>, <a class="el" href="AffineStructures_8h_source.html#l00191">getNumCols()</a>, <a class="el" href="AffineStructures_8h_source.html#l00356">getNumDimAndSymbolIds()</a>, <a class="el" href="AffineStructures_8h_source.html#l00354">getNumDimIds()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00294">mlir::AffineMap::getNumDims()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00306">mlir::AffineMap::getNumInputs()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00302">mlir::AffineMap::getNumResults()</a>, <a class="el" href="AffineStructures_8h_source.html#l00355">getNumSymbolIds()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00298">mlir::AffineMap::getNumSymbols()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">mlir::success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8h_source.html#l00644">mlir::FlatAffineValueConstraints::classof()</a>, <a class="el" href="Analysis_2Utils_8cpp_source.html#l00644">mlir::getMemRefSizeInBytes()</a>, and <a class="el" href="Transforms_2Utils_2Utils_8cpp_source.html#l00692">mlir::normalizeMemRefType()</a>.</p>

</div>
</div>
<a id="af1ebc66e64e3cd0f7eb89514664f786d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1ebc66e64e3cd0f7eb89514664f786d">&#9670;&nbsp;</a></span>addBound() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> FlatAffineConstraints::addBound </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a6eda5ed3d07648239f51a58d283af25f">BoundType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a constant bound for the specified identifier. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l02533">2533</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="Matrix_8cpp_source.html#l00063">mlir::Matrix::appendExtraRow()</a>, <a class="el" href="AffineStructures_8h_source.html#l00555">equalities</a>, <a class="el" href="AffineStructures_8h_source.html#l00191">getNumCols()</a>, <a class="el" href="AffineStructures_8h_source.html#l00558">inequalities</a>, and <a class="el" href="InterfaceSupport_8h_source.html#l00161">value</a>.</p>

</div>
</div>
<a id="ad37e7bf9c07a76d9ea38b447d5c75742"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad37e7bf9c07a76d9ea38b447d5c75742">&#9670;&nbsp;</a></span>addBound() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> FlatAffineConstraints::addBound </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a6eda5ed3d07648239f51a58d283af25f">BoundType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a constant bound for the specified expression. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l02548">2548</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="Matrix_8cpp_source.html#l00063">mlir::Matrix::appendExtraRow()</a>, <a class="el" href="AffineStructures_8h_source.html#l00191">getNumCols()</a>, <a class="el" href="Matrix_8cpp_source.html#l00049">mlir::Matrix::getNumRows()</a>, and <a class="el" href="AffineStructures_8h_source.html#l00558">inequalities</a>.</p>

</div>
</div>
<a id="a45df72c07b67e459ece93a1076344210"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45df72c07b67e459ece93a1076344210">&#9670;&nbsp;</a></span>addEquality()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> FlatAffineConstraints::addEquality </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>eq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds an equality from the coefficients specified in <code>eq</code>. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l02519">2519</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="Matrix_8cpp_source.html#l00063">mlir::Matrix::appendExtraRow()</a>, <a class="el" href="AffineStructures_8h_source.html#l00555">equalities</a>, and <a class="el" href="AffineStructures_8h_source.html#l00191">getNumCols()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l00698">mlir::FlatAffineValueConstraints::addAffineForOpDomain()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02376">addBound()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00351">addOrderingConstraints()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00286">append()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00564">composeMatchingMap()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00377">computeDirectionVector()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00159">FlatAffineConstraints()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l03403">getCommonConstraints()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l03922">mlir::getRelationFromMap()</a>.</p>

</div>
</div>
<a id="a9a440a9b51c09ea27d100fb62fb32a7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a440a9b51c09ea27d100fb62fb32a7f">&#9670;&nbsp;</a></span>addInequality()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> FlatAffineConstraints::addInequality </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>inEq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds an inequality (&gt;= 0) from the coefficients specified in <code>inEq</code>. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l02526">2526</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="Matrix_8cpp_source.html#l00063">mlir::Matrix::appendExtraRow()</a>, <a class="el" href="AffineStructures_8h_source.html#l00191">getNumCols()</a>, and <a class="el" href="AffineStructures_8h_source.html#l00558">inequalities</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l02376">addBound()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02564">addLocalFloorDiv()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00351">addOrderingConstraints()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00286">append()</a>, <a class="el" href="LoopSpecialization_8cpp_source.html#l00225">canonicalizeMinMaxOp()</a>, <a class="el" href="LoopSpecialization_8cpp_source.html#l00422">mlir::scf::canonicalizeMinMaxOpInLoop()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00159">FlatAffineConstraints()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l03403">getCommonConstraints()</a>, <a class="el" href="LoopSpecialization_8cpp_source.html#l00339">mlir::scf::rewritePeeledMinMaxOp()</a>, and <a class="el" href="PresburgerSet_8cpp_source.html#l00185">subtractRecursively()</a>.</p>

</div>
</div>
<a id="a9d81cc0ca235dba7982f6cecc66f2506"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d81cc0ca235dba7982f6cecc66f2506">&#9670;&nbsp;</a></span>addLocalFloorDiv()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> FlatAffineConstraints::addLocalFloorDiv </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>dividend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>divisor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a new local identifier as the floordiv of an affine function of other identifiers, the coefficients of which are provided in <code>dividend</code> and with respect to a positive constant <code>divisor</code>. </p>
<p>Adds a new local identifier as the floordiv of an affine function of other identifiers, the coefficients of which are provided in 'dividend' and with respect to a positive constant 'divisor'.</p>
<p>Two constraints are added to the system to capture equivalence with the floordiv: q = dividend floordiv c &lt;=&gt; c*q &lt;= dividend &lt;= c*q + c - 1.</p>
<p>Two constraints are added to the system to capture equivalence with the floordiv. q = expr floordiv c &lt;=&gt; c*q &lt;= expr &lt;= c*q + c - 1. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l02564">2564</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8cpp_source.html#l02526">addInequality()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00327">appendLocalId()</a>, <a class="el" href="ConvertLaunchFuncToLLVMCalls_8cpp_source.html#l00066">copy()</a>, <a class="el" href="AffineStructures_8h_source.html#l00191">getNumCols()</a>, and <a class="el" href="AffineStructures_8h_source.html#l00353">getNumIds()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l00698">mlir::FlatAffineValueConstraints::addAffineForOpDomain()</a>.</p>

</div>
</div>
<a id="a6e4973d2d62dbf7779d1e350fec9911e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e4973d2d62dbf7779d1e350fec9911e">&#9670;&nbsp;</a></span>append()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> FlatAffineConstraints::append </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1FlatAffineConstraints.html">FlatAffineConstraints</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends constraints from <code>other</code> into <code>this</code>. </p>
<p>This is equivalent to an intersection with no simplification of any sort attempted. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l00286">286</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8cpp_source.html#l02519">addEquality()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02526">addInequality()</a>, <a class="el" href="AffineStructures_8h_source.html#l00555">equalities</a>, <a class="el" href="AffineStructures_8h_source.html#l00207">getEquality()</a>, <a class="el" href="AffineStructures_8h_source.html#l00211">getInequality()</a>, <a class="el" href="AffineStructures_8h_source.html#l00191">getNumCols()</a>, <a class="el" href="AffineStructures_8h_source.html#l00354">getNumDimIds()</a>, <a class="el" href="AffineStructures_8h_source.html#l00193">getNumEqualities()</a>, <a class="el" href="AffineStructures_8h_source.html#l00195">getNumInequalities()</a>, <a class="el" href="Matrix_8cpp_source.html#l00049">mlir::Matrix::getNumRows()</a>, <a class="el" href="AffineStructures_8h_source.html#l00355">getNumSymbolIds()</a>, <a class="el" href="AffineStructures_8h_source.html#l00558">inequalities</a>, and <a class="el" href="Matrix_8cpp_source.html#l00059">mlir::Matrix::reserveRows()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l00799">mlir::FlatAffineValueConstraints::addAffineIfOpDomain()</a>, <a class="el" href="AffineStructures_8h_source.html#l00107">classof()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l03808">mlir::FlatAffineRelation::compose()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00159">FlatAffineConstraints()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02352">flattenAlignedMapAndMergeLocals()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00428">mlir::MemRefAccess::getAccessRelation()</a>, and <a class="el" href="PresburgerSet_8cpp_source.html#l00112">mlir::PresburgerSet::intersect()</a>.</p>

</div>
</div>
<a id="acaaf4020f941e58d588596d8b7bfbb3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acaaf4020f941e58d588596d8b7bfbb3b">&#9670;&nbsp;</a></span>appendDimId()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> FlatAffineConstraints::appendDimId </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>num</em> = <code>1</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Append <code>num</code> identifiers of the specified kind after the last identifier. </p>
<p>of that kind. Return the position of the first appended column. The coefficient columns corresponding to the added identifiers are initialized to zero. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l00303">303</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8h_source.html#l00354">getNumDimIds()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l00394">mlir::FlatAffineValueConstraints::insertId()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l03922">mlir::getRelationFromMap()</a>.</p>

</div>
</div>
<a id="a8c5f81433086a0ba1a41fea86b246255"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c5f81433086a0ba1a41fea86b246255">&#9670;&nbsp;</a></span>appendLocalId()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> FlatAffineConstraints::appendLocalId </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>num</em> = <code>1</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l00327">327</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8h_source.html#l00357">getNumLocalIds()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l00394">mlir::FlatAffineValueConstraints::insertId()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l02564">addLocalFloorDiv()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02073">convertDimToLocal()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00159">FlatAffineConstraints()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l02352">flattenAlignedMapAndMergeLocals()</a>.</p>

</div>
</div>
<a id="aa8d0cf47cf67fe28ad9641c0221ea5d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8d0cf47cf67fe28ad9641c0221ea5d0">&#9670;&nbsp;</a></span>appendSymbolId()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> FlatAffineConstraints::appendSymbolId </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>num</em> = <code>1</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l00315">315</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8h_source.html#l00355">getNumSymbolIds()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l00394">mlir::FlatAffineValueConstraints::insertId()</a>.</p>

</div>
</div>
<a id="aea0d219f6b966b3fed07165f4e5e5ae3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea0d219f6b966b3fed07165f4e5e5ae3">&#9670;&nbsp;</a></span>assertAtMostNumIdKind()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> FlatAffineConstraints::assertAtMostNumIdKind </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#ab47fbec6c4aff6faece95521b103fed2">IdKind</a>&#160;</td>
          <td class="paramname"><em>kind</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assert that <code>value</code> is at most the number of ids of the specified kind. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l00372">372</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8h_source.html#l00357">getNumLocalIds()</a>.</p>

</div>
</div>
<a id="aaeb4c8e8b0bf86fa1609a32bd9028536"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaeb4c8e8b0bf86fa1609a32bd9028536">&#9670;&nbsp;</a></span>atEq() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t mlir::FlatAffineConstraints::atEq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the value at the specified equality row and column. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8h_source.html#l00181">181</a> of file <a class="el" href="AffineStructures_8h_source.html">AffineStructures.h</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8h_source.html#l00555">equalities</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l02871">computeConstantLowerOrUpperBound()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02709">constantFoldId()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01626">detectAsMod()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00915">eliminateFromConstraint()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01925">eliminateRedundantLocalId()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01151">eqInvolvesSuffixDims()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00817">findConstraintWithNonZeroAt()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02666">findEqualityToConstant()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l03157">fourierMotzkinEliminate()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01110">getBoundedDirections()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02743">getConstantBoundOnDimSize()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l03701">getIndependentConstraints()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01733">getLowerAndUpperBoundIndices()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02181">getSliceBounds()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00882">hasInvalidConstraint()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01087">isEmptyByGCDTest()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02937">isHyperRectangular()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00836">normalizeConstraintByGCD()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02962">print()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01878">removeRedundantConstraints()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02031">removeRedundantLocalVars()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02691">setAndEliminate()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l02606">swapId()</a>.</p>

</div>
</div>
<a id="a0b80ebb1a0929a30c4401d297a420d9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b80ebb1a0929a30c4401d297a420d9e">&#9670;&nbsp;</a></span>atEq() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t&amp; mlir::FlatAffineConstraints::atEq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineStructures_8h_source.html#l00182">182</a> of file <a class="el" href="AffineStructures_8h_source.html">AffineStructures.h</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8h_source.html#l00555">equalities</a>.</p>

</div>
</div>
<a id="a950735c15d0d1757984210922c7118c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a950735c15d0d1757984210922c7118c0">&#9670;&nbsp;</a></span>atIneq() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t mlir::FlatAffineConstraints::atIneq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the value at the specified inequality row and column. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8h_source.html#l00185">185</a> of file <a class="el" href="AffineStructures_8h_source.html">AffineStructures.h</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8h_source.html#l00558">inequalities</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l02871">computeConstantLowerOrUpperBound()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l03233">createSeparationCondition()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00915">eliminateFromConstraint()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01925">eliminateRedundantLocalId()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01822">fillInequality()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00817">findConstraintWithNonZeroAt()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01228">findIntegerSample()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l03157">fourierMotzkinEliminate()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01537">gcdTightenInequalities()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00993">getBestIdToEliminate()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01110">getBoundedDirections()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02743">getConstantBoundOnDimSize()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01379">getDivRepr()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l03701">getIndependentConstraints()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01733">getLowerAndUpperBoundIndices()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00882">hasInvalidConstraint()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01158">ineqInvolvesSuffixDims()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02937">isHyperRectangular()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01830">negateInequality()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00836">normalizeConstraintByGCD()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02962">print()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01878">removeRedundantConstraints()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01838">removeRedundantInequalities()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l03002">removeTrivialRedundancy()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02691">setAndEliminate()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l02606">swapId()</a>.</p>

</div>
</div>
<a id="ae02ba9253168af09117779ede6e1020f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae02ba9253168af09117779ede6e1020f">&#9670;&nbsp;</a></span>atIneq() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t&amp; mlir::FlatAffineConstraints::atIneq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineStructures_8h_source.html#l00188">188</a> of file <a class="el" href="AffineStructures_8h_source.html">AffineStructures.h</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8h_source.html#l00558">inequalities</a>.</p>

</div>
</div>
<a id="a353de0786de4cb7459611d4219ba0bcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a353de0786de4cb7459611d4219ba0bcd">&#9670;&nbsp;</a></span>classof()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool mlir::FlatAffineConstraints::classof </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1FlatAffineConstraints.html">FlatAffineConstraints</a> *&#160;</td>
          <td class="paramname"><em>cst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineStructures_8h_source.html#l00107">107</a> of file <a class="el" href="AffineStructures_8h_source.html">AffineStructures.h</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8cpp_source.html#l00286">append()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00149">clone()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01343">containsPoint()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01228">findIntegerSample()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01110">getBoundedDirections()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01491">getLocalReprs()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01026">isEmpty()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01087">isEmptyByGCDTest()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01178">isIntegerEmpty()</a>, <a class="el" href="AffineStructures_8h_source.html#l00548">numDims</a>, <a class="el" href="AffineStructures_8h_source.html#l00552">numSymbols</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l00235">reset()</a>.</p>

</div>
</div>
<a id="ac662ea0313d9bcac2e44925b6be670e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac662ea0313d9bcac2e44925b6be670e8">&#9670;&nbsp;</a></span>clearAndCopyFrom()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> FlatAffineConstraints::clearAndCopyFrom </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1FlatAffineConstraints.html">FlatAffineConstraints</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces the contents of this <a class="el" href="classmlir_1_1FlatAffineConstraints.html" title="A flat list of affine equalities and inequalities in the form. ">FlatAffineConstraints</a> with <code>other</code>. </p>

<p>Reimplemented in <a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#afacc473110655fc94f713fa3733f8e9e">mlir::FlatAffineValueConstraints</a>.</p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l03067">3067</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l00074">getFlattenedAffineExprs()</a>, and <a class="el" href="AffineStructures_8h_source.html#l00357">getNumLocalIds()</a>.</p>

</div>
</div>
<a id="a4b4985a33143cd113df0f945c2bb6d8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b4985a33143cd113df0f945c2bb6d8b">&#9670;&nbsp;</a></span>clearConstraints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> FlatAffineConstraints::clearConstraints </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes all equalities and inequalities. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l03374">3374</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8h_source.html#l00555">equalities</a>, <a class="el" href="AffineStructures_8h_source.html#l00558">inequalities</a>, and <a class="el" href="Matrix_8cpp_source.html#l00080">mlir::Matrix::resizeVertically()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8h_source.html#l00357">getNumLocalIds()</a>.</p>

</div>
</div>
<a id="a0932fcc3e8ee32f1af944a1f33a9abc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0932fcc3e8ee32f1af944a1f33a9abc3">&#9670;&nbsp;</a></span>clone()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1FlatAffineConstraints.html">FlatAffineConstraints</a> &gt; FlatAffineConstraints::clone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l00149">149</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8h_source.html#l00107">classof()</a>, and <a class="el" href="AffineStructures_8h_source.html#l00644">mlir::FlatAffineValueConstraints::classof()</a>.</p>

</div>
</div>
<a id="a15f95bfc66876ee75db55381eafbb8f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15f95bfc66876ee75db55381eafbb8f2">&#9670;&nbsp;</a></span>composeMatchingMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> FlatAffineConstraints::composeMatchingMap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Composes an affine map whose dimensions and symbols match one to one with the dimensions and symbols of this <a class="el" href="classmlir_1_1FlatAffineConstraints.html" title="A flat list of affine equalities and inequalities in the form. ">FlatAffineConstraints</a>. </p>
<p>The results of the map <code>other</code> are added as the leading dimensions of this constraint system. Returns failure if <code>other</code> is a semi-affine map. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l00564">564</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8cpp_source.html#l02519">addEquality()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">mlir::failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02352">flattenAlignedMapAndMergeLocals()</a>, <a class="el" href="AffineStructures_8h_source.html#l00191">getNumCols()</a>, <a class="el" href="AffineStructures_8h_source.html#l00354">getNumDimIds()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00294">mlir::AffineMap::getNumDims()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00306">mlir::AffineMap::getNumInputs()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00302">mlir::AffineMap::getNumResults()</a>, <a class="el" href="AffineStructures_8h_source.html#l00355">getNumSymbolIds()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00298">mlir::AffineMap::getNumSymbols()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00337">mlir::FlatAffineValueConstraints::insertDimId()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">mlir::success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l00556">mlir::FlatAffineValueConstraints::composeMap()</a>, and <a class="el" href="Transforms_2Utils_2Utils_8cpp_source.html#l00692">mlir::normalizeMemRefType()</a>.</p>

</div>
</div>
<a id="a48d2dbd6016eb6489a8bea183064194d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48d2dbd6016eb6489a8bea183064194d">&#9670;&nbsp;</a></span>computeConstantLowerOrUpperBound()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool isLower&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; int64_t &gt; FlatAffineConstraints::computeConstantLowerOrUpperBound </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the constant lower bound bound if isLower is true, and the upper bound if isLower is false. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l02871">2871</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8h_source.html#l00181">atEq()</a>, <a class="el" href="AffineStructures_8h_source.html#l00185">atIneq()</a>, <a class="el" href="MathExtras_8h_source.html#l00023">mlir::ceilDiv()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02666">findEqualityToConstant()</a>, <a class="el" href="MathExtras_8h_source.html#l00032">mlir::floorDiv()</a>, <a class="el" href="AffineStructures_8h_source.html#l00191">getNumCols()</a>, <a class="el" href="AffineStructures_8h_source.html#l00353">getNumIds()</a>, <a class="el" href="AffineStructures_8h_source.html#l00195">getNumInequalities()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l03366">mlir::FlatAffineValueConstraints::projectOut()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l02927">getConstantBound()</a>, and <a class="el" href="AffineStructures_8h_source.html#l00357">getNumLocalIds()</a>.</p>

</div>
</div>
<a id="a00e1041e7db596d628253f1d8d7c8222"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00e1041e7db596d628253f1d8d7c8222">&#9670;&nbsp;</a></span>constantFoldId()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> FlatAffineConstraints::constantFoldId </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tries to fold the specified identifier to a constant using a trivial equality detection; if successful, the constant is substituted for the identifier everywhere in the constraint system and then removed from the system. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l02709">2709</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8h_source.html#l00181">atEq()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02666">findEqualityToConstant()</a>, <a class="el" href="AffineStructures_8h_source.html#l00191">getNumCols()</a>, <a class="el" href="AffineStructures_8h_source.html#l00353">getNumIds()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02691">setAndEliminate()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">mlir::success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l02722">constantFoldIdRange()</a>, and <a class="el" href="AffineStructures_8h_source.html#l00294">projectOut()</a>.</p>

</div>
</div>
<a id="ad67b4c81a969b09cf5c4bc723cda93d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad67b4c81a969b09cf5c4bc723cda93d5">&#9670;&nbsp;</a></span>constantFoldIdRange()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> FlatAffineConstraints::constantFoldIdRange </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method calls <code>constantFoldId</code> for the specified range of identifiers, <code>num</code> identifiers starting at position <code>pos</code>. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l02722">2722</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8cpp_source.html#l02709">constantFoldId()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00072">mlir::failed()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8h_source.html#l00294">projectOut()</a>.</p>

</div>
</div>
<a id="ae447433822615a5748eb99dc75961579"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae447433822615a5748eb99dc75961579">&#9670;&nbsp;</a></span>containsPoint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool FlatAffineConstraints::containsPoint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>point</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the given point satisfies the constraints, or false otherwise. </p>
<p>A point satisfies an equality iff the value of the equality at the expression is zero, and it satisfies an inequality iff the value of the inequality at that point is non-negative.</p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l01343">1343</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8h_source.html#l00207">getEquality()</a>, <a class="el" href="AffineStructures_8h_source.html#l00211">getInequality()</a>, <a class="el" href="AffineStructures_8h_source.html#l00193">getNumEqualities()</a>, <a class="el" href="AffineStructures_8h_source.html#l00195">getNumInequalities()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l01331">valueAt()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8h_source.html#l00107">classof()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l01228">findIntegerSample()</a>.</p>

</div>
</div>
<a id="a27e9d04e72add0e58c934cae62413ac7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27e9d04e72add0e58c934cae62413ac7">&#9670;&nbsp;</a></span>convertDimToLocal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> FlatAffineConstraints::convertDimToLocal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>dimStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>dimLimit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts identifiers in the column range [idStart, idLimit) to local variables. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l02073">2073</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8cpp_source.html#l00327">appendLocalId()</a>, <a class="el" href="AffineStructures_8h_source.html#l00354">getNumDimIds()</a>, <a class="el" href="AffineStructures_8h_source.html#l00353">getNumIds()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00982">mlir::FlatAffineValueConstraints::removeIdRange()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l02619">mlir::FlatAffineValueConstraints::swapId()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l03808">mlir::FlatAffineRelation::compose()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l03793">mlir::FlatAffineRelation::getDomainSet()</a>, <a class="el" href="AffineStructures_8h_source.html#l00357">getNumLocalIds()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l03801">mlir::FlatAffineRelation::getRangeSet()</a>.</p>

</div>
</div>
<a id="a9755c04bef03df1b8130b1a4e76ac605"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9755c04bef03df1b8130b1a4e76ac605">&#9670;&nbsp;</a></span>dump()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> FlatAffineConstraints::dump </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l02994">2994</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8cpp_source.html#l02962">print()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineAnalysis_8cpp_source.html#l00568">mlir::checkMemrefAccessDependence()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l03157">fourierMotzkinEliminate()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l03646">getAsIntegerSet()</a>, <a class="el" href="AffineStructures_8h_source.html#l00357">getNumLocalIds()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02181">getSliceBounds()</a>, and <a class="el" href="Analysis_2Utils_8cpp_source.html#l00221">mlir::ComputationSliceState::isSliceValid()</a>.</p>

</div>
</div>
<a id="a068c098c9581e2b99d317a11fd0a3105"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a068c098c9581e2b99d317a11fd0a3105">&#9670;&nbsp;</a></span>findIntegerSample()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t, 8 &gt; &gt; FlatAffineConstraints::findIntegerSample </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find an integer sample point satisfying the constraints using a branch and bound algorithm with generalized basis reduction, with some additional processing using <a class="el" href="classmlir_1_1Simplex.html" title="This class implements a version of the Simplex and Generalized Basis Reduction algorithms, which can perform analysis of integer sets with affine inequalities and equalities. ">Simplex</a> for unbounded sets. </p>
<p>Let this set be S.</p>
<p>Returns an integer sample point if one exists, or an empty Optional otherwise.</p>
<p>If S is bounded then we directly call into the GBR sampling algorithm. Otherwise, there are some unbounded directions, i.e., vectors v such that S extends to infinity along v or -v. In this case we use an algorithm described in the integer set library (isl) manual and used by the isl_set_sample function in that library. The algorithm is:</p>
<p>1) Apply a unimodular transform T to S to obtain S*T, such that all dimensions in which S*T is bounded lie in the linear span of a prefix of the dimensions.</p>
<p>2) Construct a set B by removing all constraints that involve the unbounded dimensions and then deleting the unbounded dimensions. Note that B is a Bounded set.</p>
<p>3) Try to obtain a sample from B using the GBR sampling algorithm. If no sample is found, return that S is empty.</p>
<p>4) Otherwise, substitute the obtained sample into S*T to obtain a set C. C is a full-dimensional Cone and always contains a sample.</p>
<p>5) Obtain an integer sample from C.</p>
<p>6) Return T*v, where v is the concatenation of the samples from B and C.</p>
<p>The following is a sketch of a proof that a) If the algorithm returns empty, then S is empty. b) If the algorithm returns a sample, it is a valid sample in S.</p>
<p>The algorithm returns empty only if B is empty, in which case S*T is certainly empty since B was obtained by removing constraints and then deleting unconstrained dimensions from S*T. Since T is unimodular, a vector v is in S*T iff T*v is in S. So in this case, since S*T is empty, S is empty too.</p>
<p>Otherwise, the algorithm substitutes the sample from B into S*T. All the constraints of S*T that did not involve unbounded dimensions are satisfied by this substitution. All dimensions in the linear span of the dimensions outside the prefix are unbounded in S*T (step 1). Substituting values for the bounded dimensions cannot make these dimensions bounded, and these are the only remaining dimensions in C, so C is unbounded along every vector (in the positive or negative direction, or both). C is hence a full-dimensional cone and therefore always contains an integer point.</p>
<p>Concatenating the samples from B and C gives a sample v in S*T, so the returned sample T*v is a sample in S. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l01228">1228</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinearTransform_8cpp_source.html#l00139">mlir::LinearTransform::applyTo()</a>, <a class="el" href="AffineStructures_8h_source.html#l00185">atIneq()</a>, <a class="el" href="Fraction_8h_source.html#l00057">mlir::ceil()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01343">containsPoint()</a>, <a class="el" href="Simplex_8cpp_source.html#l01099">mlir::Simplex::findIntegerSample()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01110">getBoundedDirections()</a>, <a class="el" href="AffineStructures_8h_source.html#l00353">getNumIds()</a>, <a class="el" href="AffineStructures_8h_source.html#l00195">getNumInequalities()</a>, <a class="el" href="Simplex_8cpp_source.html#l00736">mlir::Simplex::getRationalSample()</a>, <a class="el" href="Simplex_8cpp_source.html#l00337">mlir::Simplex::isEmpty()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01087">isEmptyByGCDTest()</a>, <a class="el" href="Simplex_8cpp_source.html#l00634">mlir::Simplex::isUnbounded()</a>, <a class="el" href="LinearTransform_8cpp_source.html#l00033">mlir::LinearTransform::makeTransformToColumnEchelon()</a>, <a class="el" href="AffineStructures_8h_source.html#l00545">numIds</a>, <a class="el" href="LinearTransform_8cpp_source.html#l00127">mlir::LinearTransform::preMultiplyColumn()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01166">removeConstraintsInvolvingSuffixDims()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00427">removeIdRange()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l02691">setAndEliminate()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8h_source.html#l00107">classof()</a>, <a class="el" href="PresburgerSet_8cpp_source.html#l00373">mlir::PresburgerSet::findIntegerSample()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l01178">isIntegerEmpty()</a>.</p>

</div>
</div>
<a id="a38c97661a1c86284a9102a06018c7292"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38c97661a1c86284a9102a06018c7292">&#9670;&nbsp;</a></span>flattenAlignedMapAndMergeLocals()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> FlatAffineConstraints::flattenAlignedMapAndMergeLocals </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t, 8 &gt;&gt; *&#160;</td>
          <td class="paramname"><em>flattenedExprs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given an affine map that is aligned with this constraint system: </p>
<ul>
<li>Flatten the map.</li>
<li>Add newly introduced local columns at the beginning of this constraint system (local column pos 0).</li>
<li>Add equalities that define the new local columns to this constraint system.</li>
<li>Return the flattened expressions via <code>flattenedExprs</code>.</li>
</ul>
<p>Note: This is a shared helper function of <code>addLowerOrUpperBound</code> and <code>composeMatchingMap</code>. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l02352">2352</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8cpp_source.html#l00286">append()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00327">appendLocalId()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">mlir::failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00120">mlir::getFlattenedAffineExprs()</a>, <a class="el" href="AffineStructures_8h_source.html#l00357">getNumLocalIds()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00351">insertLocalId()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">mlir::success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l02376">addBound()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00564">composeMatchingMap()</a>, and <a class="el" href="AffineStructures_8h_source.html#l00357">getNumLocalIds()</a>.</p>

</div>
</div>
<a id="a8a74c3f513f68972c677b4a104fe68b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a74c3f513f68972c677b4a104fe68b5">&#9670;&nbsp;</a></span>fourierMotzkinEliminate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> FlatAffineConstraints::fourierMotzkinEliminate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>darkShadow</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>isResultIntegerExact</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Eliminates the identifier at the specified position using Fourier-Motzkin variable elimination, but uses Gaussian elimination if there is an equality involving that identifier. </p>
<p>If the result of the elimination is integer exact, <code>*isResultIntegerExact</code> is set to true. If <code>darkShadow</code> is set to true, a potential under approximation (subset) of the rational shadow / exact integer shadow is computed. </p>
<p>Create the new system which has one identifier less. </p>

<p>Reimplemented in <a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a30b3ca6765edfa5677b1b23130e0187c">mlir::FlatAffineValueConstraints</a>.</p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l03157">3157</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8h_source.html#l00181">atEq()</a>, <a class="el" href="AffineStructures_8h_source.html#l00185">atIneq()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l03076">mlir::FlatAffineValueConstraints::clearAndCopyFrom()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02994">dump()</a>, <a class="el" href="AffineStructures_8h_source.html#l00501">gaussianEliminateId()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01537">gcdTightenInequalities()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l03093">getNewNumDimsSymbols()</a>, <a class="el" href="AffineStructures_8h_source.html#l00191">getNumCols()</a>, <a class="el" href="AffineStructures_8h_source.html#l00193">getNumEqualities()</a>, <a class="el" href="AffineStructures_8h_source.html#l00353">getNumIds()</a>, <a class="el" href="AffineStructures_8h_source.html#l00195">getNumInequalities()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00877">mlir::FlatAffineValueConstraints::hasConsistentState()</a>, <a class="el" href="MathExtras_8h_source.html#l00049">mlir::lcm()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00423">removeId()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00068">mlir::succeeded()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l03318">mlir::FlatAffineValueConstraints::fourierMotzkinEliminate()</a>, <a class="el" href="AffineStructures_8h_source.html#l00501">gaussianEliminateId()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01026">isEmpty()</a>, and <a class="el" href="AffineStructures_8h_source.html#l00896">mlir::FlatAffineValueConstraints::setValues()</a>.</p>

</div>
</div>
<a id="a881e2217448214b13d07e90b0b53bc0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a881e2217448214b13d07e90b0b53bc0c">&#9670;&nbsp;</a></span>gaussianEliminateId()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::FlatAffineConstraints::gaussianEliminateId </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>position</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Eliminates a single identifier at <code>position</code> from equality and inequality constraints. </p>
<p>Returns <code>success</code> if the identifier was eliminated, and <code>failure</code> otherwise. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8h_source.html#l00501">501</a> of file <a class="el" href="AffineStructures_8h_source.html">AffineStructures.h</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8cpp_source.html#l03157">fourierMotzkinEliminate()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01556">gaussianEliminateIds()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01537">gcdTightenInequalities()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00855">normalizeConstraintsByGCD()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00427">removeIdRange()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02031">removeRedundantLocalVars()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">mlir::success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l03157">fourierMotzkinEliminate()</a>.</p>

</div>
</div>
<a id="aac976d9ff1b446d2c09838299bf465d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac976d9ff1b446d2c09838299bf465d4">&#9670;&nbsp;</a></span>gaussianEliminateIds()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> FlatAffineConstraints::gaussianEliminateIds </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>posStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>posLimit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Eliminates identifiers from equality and inequality constraints in column range [posStart, posLimit). </p>
<p>Returns the number of variables eliminated. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l01556">1556</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8cpp_source.html#l00915">eliminateFromConstraint()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00817">findConstraintWithNonZeroAt()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01537">gcdTightenInequalities()</a>, <a class="el" href="AffineStructures_8h_source.html#l00193">getNumEqualities()</a>, <a class="el" href="AffineStructures_8h_source.html#l00195">getNumInequalities()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00877">mlir::FlatAffineValueConstraints::hasConsistentState()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00836">normalizeConstraintByGCD()</a>, <a class="el" href="AffineStructures_8h_source.html#l00545">numIds</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02640">removeEquality()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l00982">mlir::FlatAffineValueConstraints::removeIdRange()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8h_source.html#l00501">gaussianEliminateId()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01026">isEmpty()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l03331">projectOut()</a>.</p>

</div>
</div>
<a id="a9131602623a80474f09f4c556a72c2fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9131602623a80474f09f4c556a72c2fa">&#9670;&nbsp;</a></span>gcdTightenInequalities()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> FlatAffineConstraints::gcdTightenInequalities </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tightens inequalities given that we are dealing with integer spaces. </p>
<p>This is similar to the GCD test but applied to inequalities. The constant term can be reduced to the preceding multiple of the GCD of the coefficients, i.e., 64*i - 100 &gt;= 0 =&gt; 64*i - 128 &gt;= 0 (since 'i' is an integer). This is a fast method (linear in the number of coefficients).</p>
<p>This is analogous to the GCD test but applied to inequalities. The constant term can be reduced to the preceding multiple of the GCD of the coefficients, i.e., 64*i - 100 &gt;= 0 =&gt; 64*i - 128 &gt;= 0 (since 'i' is an integer). This is a fast method - linear in the number of coefficients. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l01537">1537</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8h_source.html#l00185">atIneq()</a>, <a class="el" href="MathExtras_8h_source.html#l00032">mlir::floorDiv()</a>, <a class="el" href="AffineStructures_8h_source.html#l00191">getNumCols()</a>, and <a class="el" href="AffineStructures_8h_source.html#l00195">getNumInequalities()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l03157">fourierMotzkinEliminate()</a>, <a class="el" href="AffineStructures_8h_source.html#l00501">gaussianEliminateId()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01556">gaussianEliminateIds()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l03331">projectOut()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01878">removeRedundantConstraints()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l03002">removeTrivialRedundancy()</a>.</p>

</div>
</div>
<a id="ad9ce04a3ec6c6baf9308f460ae14c751"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9ce04a3ec6c6baf9308f460ae14c751">&#9670;&nbsp;</a></span>getAsIntegerSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1IntegerSet.html">IntegerSet</a> FlatAffineConstraints::getAsIntegerSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the constraint system as an integer set. </p>
<p>Returns a null integer set if the system has no constraints, or if an integer set couldn't be constructed as a result of a local variable's explicit representation not being known and such a local variable appearing in any of the constraints. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l03646">3646</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8cpp_source.html#l03563">computeLocalVars()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02994">dump()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">mlir::failed()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l00958">mlir::IntegerSet::get()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00514">mlir::getAffineConstantExpr()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00892">mlir::getAffineExprFromFlatForm()</a>, <a class="el" href="AffineStructures_8h_source.html#l00207">getEquality()</a>, <a class="el" href="AffineStructures_8h_source.html#l00211">getInequality()</a>, <a class="el" href="AffineStructures_8h_source.html#l00350">getNumConstraints()</a>, <a class="el" href="AffineStructures_8h_source.html#l00356">getNumDimAndSymbolIds()</a>, <a class="el" href="AffineStructures_8h_source.html#l00354">getNumDimIds()</a>, <a class="el" href="AffineStructures_8h_source.html#l00193">getNumEqualities()</a>, <a class="el" href="AffineStructures_8h_source.html#l00353">getNumIds()</a>, <a class="el" href="AffineStructures_8h_source.html#l00195">getNumInequalities()</a>, <a class="el" href="AffineStructures_8h_source.html#l00357">getNumLocalIds()</a>, <a class="el" href="AffineStructures_8h_source.html#l00355">getNumSymbolIds()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l03640">isColZero()</a>, and <a class="el" href="AffineStructures_8h_source.html#l00548">numDims</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUtils_8cpp_source.html#l03233">createSeparationCondition()</a>, and <a class="el" href="Analysis_2Utils_8cpp_source.html#l01367">mlir::simplifyIntegerSet()</a>.</p>

</div>
</div>
<a id="ab7ef7a710ab1ff16234a3e4ba01e1d7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7ef7a710ab1ff16234a3e4ba01e1d7f">&#9670;&nbsp;</a></span>getBoundedDirections()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Matrix.html">Matrix</a> FlatAffineConstraints::getBoundedDirections </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a matrix where each row is a vector along which the polytope is bounded. </p>
<p>The span of the returned vectors is guaranteed to contain all such vectors. The returned vectors are NOT guaranteed to be linearly independent. This function should not be called on empty sets. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l01110">1110</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8h_source.html#l00181">atEq()</a>, <a class="el" href="AffineStructures_8h_source.html#l00185">atIneq()</a>, <a class="el" href="AffineStructures_8h_source.html#l00191">getNumCols()</a>, <a class="el" href="AffineStructures_8h_source.html#l00193">getNumEqualities()</a>, <a class="el" href="AffineStructures_8h_source.html#l00195">getNumInequalities()</a>, <a class="el" href="Simplex_8cpp_source.html#l00566">mlir::Simplex::isBoundedAlongConstraint()</a>, and <a class="el" href="Simplex_8cpp_source.html#l00337">mlir::Simplex::isEmpty()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8h_source.html#l00107">classof()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l01228">findIntegerSample()</a>.</p>

</div>
</div>
<a id="aeaee57edfdfaaff4c7a33c52ddbb94ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeaee57edfdfaaff4c7a33c52ddbb94ca">&#9670;&nbsp;</a></span>getConstantBound()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; int64_t &gt; FlatAffineConstraints::getConstantBound </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a6eda5ed3d07648239f51a58d283af25f">BoundType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the constant bound for the pos^th identifier if there is one; None otherwise. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l02927">2927</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8cpp_source.html#l02871">computeConstantLowerOrUpperBound()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineAnalysis_8cpp_source.html#l00377">computeDirectionVector()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01626">detectAsMod()</a>, <a class="el" href="AffineStructures_8h_source.html#l00357">getNumLocalIds()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02181">getSliceBounds()</a>, and <a class="el" href="Transforms_2Utils_2Utils_8cpp_source.html#l00692">mlir::normalizeMemRefType()</a>.</p>

</div>
</div>
<a id="acee472dcf0f37342df02e5af53b7aa45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acee472dcf0f37342df02e5af53b7aa45">&#9670;&nbsp;</a></span>getConstantBoundOnDimSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; int64_t &gt; FlatAffineConstraints::getConstantBoundOnDimSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; int64_t &gt; *&#160;</td>
          <td class="paramname"><em>lb</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t *&#160;</td>
          <td class="paramname"><em>boundFloorDivisor</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; int64_t &gt; *&#160;</td>
          <td class="paramname"><em>ub</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a> *&#160;</td>
          <td class="paramname"><em>minLbPos</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a> *&#160;</td>
          <td class="paramname"><em>minUbPos</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the smallest known constant bound for the extent of the specified identifier (pos^th), i.e., the smallest known constant that is greater than or equal to 'exclusive upper bound' - 'lower bound' of the identifier. </p>
<p>Returns a non-negative constant bound on the extent (upper bound - lower bound) of the specified identifier if it is found to be a constant; returns None if it's not a constant.</p>
<p>This constant bound is guaranteed to be non-negative. Returns None if it's not a constant. This method employs trivial (low complexity / cost) checks and detection. Symbolic identifiers are treated specially, i.e., it looks for constant differences between affine expressions involving only the symbolic identifiers. <code>lb</code> and <code>ub</code> (along with the <code>boundFloorDivisor</code>) are set to represent the lower and upper bound associated with the constant difference: <code>lb</code>, <code>ub</code> have the coefficients, and <code>boundFloorDivisor</code>, their divisor. <code>minLbPos</code> and <code>minUbPos</code> if non-null are set to the position of the constant lower bound and upper bound respectively (to the same if they are from an equality). Ex: if the lower bound is [(s0 + s2 - 1) floordiv 32] for a system with three symbolic identifiers, *lb = [1, 0, 1], lbDivisor = 32. See comments at function definition for examples.</p>
<p>This methods treats symbolic identifiers specially, i.e., it looks for constant differences between affine expressions involving only the symbolic identifiers. See comments at function definition for example. 'lb', if provided, is set to the lower bound associated with the constant difference. Note that 'lb' is purely symbolic and thus will contain the coefficients of the symbolic identifiers and the constant coefficient. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l02743">2743</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8h_source.html#l00181">atEq()</a>, <a class="el" href="AffineStructures_8h_source.html#l00185">atIneq()</a>, <a class="el" href="MathExtras_8h_source.html#l00023">mlir::ceilDiv()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02666">findEqualityToConstant()</a>, <a class="el" href="AffineStructures_8h_source.html#l00207">getEquality()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01733">getLowerAndUpperBoundIndices()</a>, <a class="el" href="AffineStructures_8h_source.html#l00191">getNumCols()</a>, <a class="el" href="AffineStructures_8h_source.html#l00356">getNumDimAndSymbolIds()</a>, <a class="el" href="AffineStructures_8h_source.html#l00354">getNumDimIds()</a>, <a class="el" href="AffineStructures_8h_source.html#l00195">getNumInequalities()</a>, and <a class="el" href="AffineStructures_8h_source.html#l00355">getNumSymbolIds()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUtils_8cpp_source.html#l03315">createFullTiles()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l03233">createSeparationCondition()</a>, <a class="el" href="AffineStructures_8h_source.html#l00357">getNumLocalIds()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l03429">unionBoundingBox()</a>.</p>

</div>
</div>
<a id="a0673b512906bb0fed9e4c7244f9f0217"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0673b512906bb0fed9e4c7244f9f0217">&#9670;&nbsp;</a></span>getEquality()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt;int64_t&gt; mlir::FlatAffineConstraints::getEquality </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineStructures_8h_source.html#l00207">207</a> of file <a class="el" href="AffineStructures_8h_source.html">AffineStructures.h</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8h_source.html#l00555">equalities</a>, and <a class="el" href="Matrix_8cpp_source.html#l00103">mlir::Matrix::getRow()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l00286">append()</a>, <a class="el" href="LinearTransform_8cpp_source.html#l00139">mlir::LinearTransform::applyTo()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01343">containsPoint()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l03646">getAsIntegerSet()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l03403">getCommonConstraints()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02743">getConstantBoundOnDimSize()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02093">getLowerAndUpperBound()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01733">getLowerAndUpperBoundIndices()</a>, <a class="el" href="Simplex_8cpp_source.html#l00506">mlir::Simplex::intersectFlatAffineConstraints()</a>, <a class="el" href="Simplex_8cpp_source.html#l00031">mlir::Simplex::Simplex()</a>, and <a class="el" href="PresburgerSet_8cpp_source.html#l00185">subtractRecursively()</a>.</p>

</div>
</div>
<a id="a17a14cb3eb220c8b9926268a0f994110"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17a14cb3eb220c8b9926268a0f994110">&#9670;&nbsp;</a></span>getIdKindOffset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> FlatAffineConstraints::getIdKindOffset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#ab47fbec6c4aff6faece95521b103fed2">IdKind</a>&#160;</td>
          <td class="paramname"><em>kind</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the index at which the specified kind of id starts. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l00384">384</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8h_source.html#l00357">getNumLocalIds()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l01951">mergeLocalIds()</a>.</p>

</div>
</div>
<a id="a92b9b04e17d80d48a79c0e09710c2be6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92b9b04e17d80d48a79c0e09710c2be6">&#9670;&nbsp;</a></span>getInequality()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt;int64_t&gt; mlir::FlatAffineConstraints::getInequality </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineStructures_8h_source.html#l00211">211</a> of file <a class="el" href="AffineStructures_8h_source.html">AffineStructures.h</a>.</p>

<p class="reference">References <a class="el" href="Matrix_8cpp_source.html#l00103">mlir::Matrix::getRow()</a>, and <a class="el" href="AffineStructures_8h_source.html#l00558">inequalities</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l00286">append()</a>, <a class="el" href="LinearTransform_8cpp_source.html#l00139">mlir::LinearTransform::applyTo()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01343">containsPoint()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l03233">createSeparationCondition()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l03646">getAsIntegerSet()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l03403">getCommonConstraints()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l03593">mlir::FlatAffineValueConstraints::getIneqAsAffineValueMap()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02093">getLowerAndUpperBound()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01733">getLowerAndUpperBoundIndices()</a>, <a class="el" href="Simplex_8cpp_source.html#l00506">mlir::Simplex::intersectFlatAffineConstraints()</a>, <a class="el" href="Simplex_8cpp_source.html#l00031">mlir::Simplex::Simplex()</a>, and <a class="el" href="PresburgerSet_8cpp_source.html#l00185">subtractRecursively()</a>.</p>

</div>
</div>
<a id="a4a09df05dc3bd81725f085f4268b7e6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a09df05dc3bd81725f085f4268b7e6a">&#9670;&nbsp;</a></span>getKind()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classmlir_1_1FlatAffineConstraints.html#ac7022f51854ec1d369bb150035a1437f">Kind</a> mlir::FlatAffineConstraints::getKind </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the kind of this <a class="el" href="classmlir_1_1FlatAffineConstraints.html" title="A flat list of affine equalities and inequalities in the form. ">FlatAffineConstraints</a>. </p>

<p>Reimplemented in <a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#ac6234845a4fa3eb9444e56cab0fe5b0e">mlir::FlatAffineValueConstraints</a>.</p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8h_source.html#l00105">105</a> of file <a class="el" href="AffineStructures_8h_source.html">AffineStructures.h</a>.</p>

<p class="reference">References <a class="el" href="classmlir_1_1FlatAffineConstraints.html#ac7022f51854ec1d369bb150035a1437fa5d3c39d196a997e225b4f3ee3e1da745">FlatAffineConstraints</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8h_source.html#l00644">mlir::FlatAffineValueConstraints::classof()</a>.</p>

</div>
</div>
<a id="a95feac8d46e898c9afc6e0ea965ac62e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95feac8d46e898c9afc6e0ea965ac62e">&#9670;&nbsp;</a></span>getLocalReprs() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> FlatAffineConstraints::getLocalReprs </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t, 8 &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>dividends</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classunsigned.html">unsigned</a>, 4 &gt; &amp;&#160;</td>
          <td class="paramname"><em>denominators</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classllvm_1_1Optional.html">llvm::Optional</a>&lt; std::pair&lt; <a class="el" href="classunsigned.html">unsigned</a>, <a class="el" href="classunsigned.html">unsigned</a> &gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>repr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find pairs of inequalities identified by their position indices, using which an explicit representation for each local variable can be computed. </p>
<p>The pairs are stored as indices of upperbound, lowerbound inequalities. If no such pair can be found, it is stored as llvm::None.</p>
<p>The dividends of the explicit representations are stored in <code>dividends</code> and the denominators in <code>denominators</code>. If no explicit representation could be found for the <code>i^th</code> local identifier, <code>denominators[i]</code> is set to 0. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l01491">1491</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8h_source.html#l00356">getNumDimAndSymbolIds()</a>, <a class="el" href="AffineStructures_8h_source.html#l00353">getNumIds()</a>, and <a class="el" href="AffineStructures_8h_source.html#l00357">getNumLocalIds()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8h_source.html#l00107">classof()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01476">getLocalReprs()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01951">mergeLocalIds()</a>, and <a class="el" href="PresburgerSet_8cpp_source.html#l00185">subtractRecursively()</a>.</p>

</div>
</div>
<a id="a3874c61c1c0744d4b00241e280ff68eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3874c61c1c0744d4b00241e280ff68eb">&#9670;&nbsp;</a></span>getLocalReprs() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> FlatAffineConstraints::getLocalReprs </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classllvm_1_1Optional.html">llvm::Optional</a>&lt; std::pair&lt; <a class="el" href="classunsigned.html">unsigned</a>, <a class="el" href="classunsigned.html">unsigned</a> &gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>repr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l01476">1476</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8cpp_source.html#l01491">getLocalReprs()</a>, and <a class="el" href="AffineStructures_8h_source.html#l00357">getNumLocalIds()</a>.</p>

</div>
</div>
<a id="adac6b777c22096af2f6c331ccc16a282"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adac6b777c22096af2f6c331ccc16a282">&#9670;&nbsp;</a></span>getLocalReprs() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> FlatAffineConstraints::getLocalReprs </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t, 8 &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>dividends</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classunsigned.html">unsigned</a>, 4 &gt; &amp;&#160;</td>
          <td class="paramname"><em>denominators</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l01483">1483</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8cpp_source.html#l01491">getLocalReprs()</a>, and <a class="el" href="AffineStructures_8h_source.html#l00357">getNumLocalIds()</a>.</p>

</div>
</div>
<a id="aad0cdbe1cff606a9b364e734ca09dc52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad0cdbe1cff606a9b364e734ca09dc52">&#9670;&nbsp;</a></span>getLowerAndUpperBound()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>, <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt; FlatAffineConstraints::getLowerAndUpperBound </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>symStartPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt;&#160;</td>
          <td class="paramname"><em>localExprs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the lower and upper bound of the <code>offset</code> + <code>pos</code>th identifier treating [0, offset) U [offset + num, symStartPos) as dimensions and [symStartPos, getNumDimAndSymbolIds) as symbols, and <code>pos</code> lies in [0, num). </p>
<p>The multi-dimensional maps in the returned pair represent the max and min of potentially multiple affine expressions. The upper bound is exclusive. <code>localExprs</code> holds pre-computed <a class="el" href="classmlir_1_1AffineExpr.html" title="Base type for affine expression. ">AffineExpr</a>'s for all local identifiers in the system. </p>
<p>Add to 'b' from 'a' in set [0, offset) U [offset + num, symbStartPos). </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l02093">2093</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="MathExtras_8h_source.html#l00032">mlir::floorDiv()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l00932">mlir::AffineMap::get()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00892">mlir::getAffineExprFromFlatForm()</a>, <a class="el" href="AffineStructures_8h_source.html#l00207">getEquality()</a>, <a class="el" href="AffineStructures_8h_source.html#l00211">getInequality()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01733">getLowerAndUpperBoundIndices()</a>, <a class="el" href="AffineStructures_8h_source.html#l00356">getNumDimAndSymbolIds()</a>, <a class="el" href="AffineStructures_8h_source.html#l00354">getNumDimIds()</a>, and <a class="el" href="AffineStructures_8h_source.html#l00357">getNumLocalIds()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8h_source.html#l00357">getNumLocalIds()</a>.</p>

</div>
</div>
<a id="a689a4d485fa39f9e1aa03e78c455a363"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a689a4d485fa39f9e1aa03e78c455a363">&#9670;&nbsp;</a></span>getLowerAndUpperBoundIndices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> FlatAffineConstraints::getLowerAndUpperBoundIndices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt; *&#160;</td>
          <td class="paramname"><em>lbIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt; *&#160;</td>
          <td class="paramname"><em>ubIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt; *&#160;</td>
          <td class="paramname"><em>eqIndices</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>num</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gather positions of all lower and upper bounds of the identifier at <code>pos</code>, and optionally any equalities on it. </p>
<p>Gather all lower and upper bounds of the identifier at <code>pos</code>, and optionally any equalities on it.</p>
<p>In addition, the bounds are to be independent of identifiers in position range [<code>offset</code>, <code>offset</code> + <code>num</code>). </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l01733">1733</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8h_source.html#l00181">atEq()</a>, <a class="el" href="AffineStructures_8h_source.html#l00185">atIneq()</a>, <a class="el" href="AffineStructures_8h_source.html#l00207">getEquality()</a>, <a class="el" href="AffineStructures_8h_source.html#l00211">getInequality()</a>, <a class="el" href="AffineStructures_8h_source.html#l00191">getNumCols()</a>, <a class="el" href="AffineStructures_8h_source.html#l00193">getNumEqualities()</a>, <a class="el" href="AffineStructures_8h_source.html#l00353">getNumIds()</a>, and <a class="el" href="AffineStructures_8h_source.html#l00195">getNumInequalities()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l01435">computeSingleVarRepr()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l03233">createSeparationCondition()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02743">getConstantBoundOnDimSize()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02093">getLowerAndUpperBound()</a>, and <a class="el" href="AffineStructures_8h_source.html#l00357">getNumLocalIds()</a>.</p>

</div>
</div>
<a id="ad6dafa2401aead0909b87b92d41bfbbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6dafa2401aead0909b87b92d41bfbbd">&#9670;&nbsp;</a></span>getNumCols()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> mlir::FlatAffineConstraints::getNumCols </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of columns in the constraint system. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8h_source.html#l00191">191</a> of file <a class="el" href="AffineStructures_8h_source.html">AffineStructures.h</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8h_source.html#l00545">numIds</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l00698">mlir::FlatAffineValueConstraints::addAffineForOpDomain()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02376">addBound()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02519">addEquality()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02526">addInequality()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02564">addLocalFloorDiv()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00351">addOrderingConstraints()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00286">append()</a>, <a class="el" href="LoopSpecialization_8cpp_source.html#l00225">canonicalizeMinMaxOp()</a>, <a class="el" href="LoopSpecialization_8cpp_source.html#l00422">mlir::scf::canonicalizeMinMaxOpInLoop()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00564">composeMatchingMap()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02871">computeConstantLowerOrUpperBound()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00377">computeDirectionVector()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02709">constantFoldId()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l03233">createSeparationCondition()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01626">detectAsMod()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00915">eliminateFromConstraint()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01822">fillInequality()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00817">findConstraintWithNonZeroAt()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00159">FlatAffineConstraints()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l03157">fourierMotzkinEliminate()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01537">gcdTightenInequalities()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l02608">generateCopy()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01110">getBoundedDirections()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02743">getConstantBoundOnDimSize()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01379">getDivRepr()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l03593">mlir::FlatAffineValueConstraints::getIneqAsAffineValueMap()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01733">getLowerAndUpperBoundIndices()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l03922">mlir::getRelationFromMap()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00882">hasInvalidConstraint()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01087">isEmptyByGCDTest()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02937">isHyperRectangular()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01830">negateInequality()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00836">normalizeConstraintByGCD()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02962">print()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l03331">projectOut()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00947">removeIdRange()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01878">removeRedundantConstraints()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01838">removeRedundantInequalities()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l03002">removeTrivialRedundancy()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02691">setAndEliminate()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l03429">unionBoundingBox()</a>.</p>

</div>
</div>
<a id="a747fa3994a809e5994fdc32035b54e4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a747fa3994a809e5994fdc32035b54e4b">&#9670;&nbsp;</a></span>getNumConstraints()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> mlir::FlatAffineConstraints::getNumConstraints </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineStructures_8h_source.html#l00350">350</a> of file <a class="el" href="AffineStructures_8h_source.html">AffineStructures.h</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8h_source.html#l00193">getNumEqualities()</a>, and <a class="el" href="AffineStructures_8h_source.html#l00195">getNumInequalities()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l03646">getAsIntegerSet()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01026">isEmpty()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l02962">print()</a>.</p>

</div>
</div>
<a id="a221a2c98d7a9019f0a93cb1b070152f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a221a2c98d7a9019f0a93cb1b070152f3">&#9670;&nbsp;</a></span>getNumDimAndSymbolIds()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> mlir::FlatAffineConstraints::getNumDimAndSymbolIds </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineStructures_8h_source.html#l00356">356</a> of file <a class="el" href="AffineStructures_8h_source.html">AffineStructures.h</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8h_source.html#l00552">numSymbols</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l02376">addBound()</a>, <a class="el" href="Analysis_2Utils_8cpp_source.html#l00811">mlir::computeSliceUnion()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00662">mlir::FlatAffineValueConstraints::convertLoopIVSymbolsToDims()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l03315">createFullTiles()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l03233">createSeparationCondition()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01626">detectAsMod()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01925">eliminateRedundantLocalId()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l03646">getAsIntegerSet()</a>, <a class="el" href="Analysis_2Utils_8cpp_source.html#l01046">mlir::getComputationSliceState()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02743">getConstantBoundOnDimSize()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l03593">mlir::FlatAffineValueConstraints::getIneqAsAffineValueMap()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01491">getLocalReprs()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02093">getLowerAndUpperBound()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l03958">mlir::getRelationFromMap()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02181">getSliceBounds()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00500">mergeAndAlignIds()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00626">mlir::FlatAffineValueConstraints::mergeSymbolIds()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02031">removeRedundantLocalVars()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l00613">turnSymbolIntoDim()</a>.</p>

</div>
</div>
<a id="a0bb25117553419fb47427704e6c9bb84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bb25117553419fb47427704e6c9bb84">&#9670;&nbsp;</a></span>getNumDimIds()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> mlir::FlatAffineConstraints::getNumDimIds </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineStructures_8h_source.html#l00354">354</a> of file <a class="el" href="AffineStructures_8h_source.html">AffineStructures.h</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8h_source.html#l00548">numDims</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l02376">addBound()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00750">mlir::FlatAffineValueConstraints::addDomainFromSliceMaps()</a>, <a class="el" href="Analysis_2Utils_8cpp_source.html#l00763">addMissingLoopIVBounds()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00351">addOrderingConstraints()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00286">append()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00303">appendDimId()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00309">mlir::FlatAffineValueConstraints::appendDimId()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l03898">mlir::FlatAffineRelation::appendRangeId()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00436">areIdsAligned()</a>, <a class="el" href="PresburgerSet_8cpp_source.html#l00042">assertDimensionsCompatible()</a>, <a class="el" href="LoopSpecialization_8cpp_source.html#l00422">mlir::scf::canonicalizeMinMaxOpInLoop()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00564">composeMatchingMap()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00377">computeDirectionVector()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l03563">computeLocalVars()</a>, <a class="el" href="Analysis_2Utils_8cpp_source.html#l00811">mlir::computeSliceUnion()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02073">convertDimToLocal()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00662">mlir::FlatAffineValueConstraints::convertLoopIVSymbolsToDims()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01626">detectAsMod()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02666">findEqualityToConstant()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l02608">generateCopy()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00428">mlir::MemRefAccess::getAccessRelation()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l03646">getAsIntegerSet()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l03403">getCommonConstraints()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02743">getConstantBoundOnDimSize()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l03593">mlir::FlatAffineValueConstraints::getIneqAsAffineValueMap()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02093">getLowerAndUpperBound()</a>, <a class="el" href="AffineStructures_8h_source.html#l00885">mlir::FlatAffineValueConstraints::getMaybeDimAndSymbolValues()</a>, <a class="el" href="AffineStructures_8h_source.html#l00877">mlir::FlatAffineValueConstraints::getMaybeDimValues()</a>, <a class="el" href="AffineStructures_8h_source.html#l00881">mlir::FlatAffineValueConstraints::getMaybeSymbolValues()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l03093">getNewNumDimsSymbols()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00253">getNumCommonLoops()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l03922">mlir::getRelationFromMap()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02181">getSliceBounds()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00180">mlir::linalg::getUpperBoundForIndex()</a>, <a class="el" href="Analysis_2Utils_8cpp_source.html#l00291">mlir::ComputationSliceState::isMaximal()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00500">mergeAndAlignIds()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01951">mergeLocalIds()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00626">mlir::FlatAffineValueConstraints::mergeSymbolIds()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02962">print()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l03903">mlir::FlatAffineRelation::removeIdRange()</a>, <a class="el" href="PresburgerSet_8cpp_source.html#l00185">subtractRecursively()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00613">turnSymbolIntoDim()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l03429">unionBoundingBox()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l03540">mlir::FlatAffineValueConstraints::unionBoundingBox()</a>.</p>

</div>
</div>
<a id="a963e712e6a344acbadfa413940487704"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a963e712e6a344acbadfa413940487704">&#9670;&nbsp;</a></span>getNumEqualities()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> mlir::FlatAffineConstraints::getNumEqualities </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineStructures_8h_source.html#l00193">193</a> of file <a class="el" href="AffineStructures_8h_source.html">AffineStructures.h</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8h_source.html#l00555">equalities</a>, and <a class="el" href="Matrix_8cpp_source.html#l00049">mlir::Matrix::getNumRows()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l00286">append()</a>, <a class="el" href="LinearTransform_8cpp_source.html#l00139">mlir::LinearTransform::applyTo()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01343">containsPoint()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01626">detectAsMod()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01925">eliminateRedundantLocalId()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00817">findConstraintWithNonZeroAt()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02666">findEqualityToConstant()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l03157">fourierMotzkinEliminate()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01556">gaussianEliminateIds()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l03646">getAsIntegerSet()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01110">getBoundedDirections()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l03403">getCommonConstraints()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l03701">getIndependentConstraints()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01733">getLowerAndUpperBoundIndices()</a>, <a class="el" href="AffineStructures_8h_source.html#l00350">getNumConstraints()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00882">hasInvalidConstraint()</a>, <a class="el" href="Simplex_8cpp_source.html#l00506">mlir::Simplex::intersectFlatAffineConstraints()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01087">isEmptyByGCDTest()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02937">isHyperRectangular()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00855">normalizeConstraintsByGCD()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02962">print()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01166">removeConstraintsInvolvingSuffixDims()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01878">removeRedundantConstraints()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02031">removeRedundantLocalVars()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02691">setAndEliminate()</a>, <a class="el" href="Simplex_8cpp_source.html#l00031">mlir::Simplex::Simplex()</a>, <a class="el" href="PresburgerSet_8cpp_source.html#l00185">subtractRecursively()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l02606">swapId()</a>.</p>

</div>
</div>
<a id="a0937c7d6a0a23146fbc6d5caf5e95a8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0937c7d6a0a23146fbc6d5caf5e95a8b">&#9670;&nbsp;</a></span>getNumIds()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> mlir::FlatAffineConstraints::getNumIds </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineStructures_8h_source.html#l00353">353</a> of file <a class="el" href="AffineStructures_8h_source.html">AffineStructures.h</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8h_source.html#l00545">numIds</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l02564">addLocalFloorDiv()</a>, <a class="el" href="LinearTransform_8cpp_source.html#l00139">mlir::LinearTransform::applyTo()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00436">areIdsAligned()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00453">areIdsUnique()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02871">computeConstantLowerOrUpperBound()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00377">computeDirectionVector()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01435">computeSingleVarRepr()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02709">constantFoldId()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02073">convertDimToLocal()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01791">detectAsFloorDiv()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01626">detectAsMod()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01151">eqInvolvesSuffixDims()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02666">findEqualityToConstant()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01228">findIntegerSample()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l03157">fourierMotzkinEliminate()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l03318">mlir::FlatAffineValueConstraints::fourierMotzkinEliminate()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l02608">generateCopy()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l03646">getAsIntegerSet()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00993">getBestIdToEliminate()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01379">getDivRepr()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l03701">getIndependentConstraints()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l03593">mlir::FlatAffineValueConstraints::getIneqAsAffineValueMap()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01491">getLocalReprs()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01733">getLowerAndUpperBoundIndices()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02181">getSliceBounds()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00877">mlir::FlatAffineValueConstraints::hasConsistentState()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01158">ineqInvolvesSuffixDims()</a>, <a class="el" href="Simplex_8cpp_source.html#l00506">mlir::Simplex::intersectFlatAffineConstraints()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01026">isEmpty()</a>, <a class="el" href="Analysis_2Utils_8cpp_source.html#l00221">mlir::ComputationSliceState::isSliceValid()</a>, <a class="el" href="Transforms_2Utils_2Utils_8cpp_source.html#l00692">mlir::normalizeMemRefType()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02962">print()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l03331">projectOut()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l03731">removeIndependentConstraints()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02031">removeRedundantLocalVars()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02691">setAndEliminate()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l02606">swapId()</a>.</p>

</div>
</div>
<a id="a50f382f6a3f7062ff36e3dce1920c4c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50f382f6a3f7062ff36e3dce1920c4c9">&#9670;&nbsp;</a></span>getNumInequalities()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> mlir::FlatAffineConstraints::getNumInequalities </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineStructures_8h_source.html#l00195">195</a> of file <a class="el" href="AffineStructures_8h_source.html">AffineStructures.h</a>.</p>

<p class="reference">References <a class="el" href="Matrix_8cpp_source.html#l00049">mlir::Matrix::getNumRows()</a>, and <a class="el" href="AffineStructures_8h_source.html#l00558">inequalities</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l00286">append()</a>, <a class="el" href="LinearTransform_8cpp_source.html#l00139">mlir::LinearTransform::applyTo()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02871">computeConstantLowerOrUpperBound()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01343">containsPoint()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01925">eliminateRedundantLocalId()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00817">findConstraintWithNonZeroAt()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01228">findIntegerSample()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l03157">fourierMotzkinEliminate()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01556">gaussianEliminateIds()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01537">gcdTightenInequalities()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l03646">getAsIntegerSet()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00993">getBestIdToEliminate()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01110">getBoundedDirections()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l03403">getCommonConstraints()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02743">getConstantBoundOnDimSize()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01379">getDivRepr()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l03701">getIndependentConstraints()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l03593">mlir::FlatAffineValueConstraints::getIneqAsAffineValueMap()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01733">getLowerAndUpperBoundIndices()</a>, <a class="el" href="AffineStructures_8h_source.html#l00350">getNumConstraints()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00882">hasInvalidConstraint()</a>, <a class="el" href="Simplex_8cpp_source.html#l00506">mlir::Simplex::intersectFlatAffineConstraints()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02937">isHyperRectangular()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00855">normalizeConstraintsByGCD()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02962">print()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01166">removeConstraintsInvolvingSuffixDims()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01878">removeRedundantConstraints()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01838">removeRedundantInequalities()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02031">removeRedundantLocalVars()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l03002">removeTrivialRedundancy()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02691">setAndEliminate()</a>, <a class="el" href="Simplex_8cpp_source.html#l00031">mlir::Simplex::Simplex()</a>, <a class="el" href="PresburgerSet_8cpp_source.html#l00185">subtractRecursively()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l02606">swapId()</a>.</p>

</div>
</div>
<a id="ab12365660bdc368e87b6fc73f12e3e86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab12365660bdc368e87b6fc73f12e3e86">&#9670;&nbsp;</a></span>getNumLocalIds()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> mlir::FlatAffineConstraints::getNumLocalIds </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineStructures_8h_source.html#l00357">357</a> of file <a class="el" href="AffineStructures_8h_source.html">AffineStructures.h</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8cpp_source.html#l00372">assertAtMostNumIdKind()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l03067">clearAndCopyFrom()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l03374">clearConstraints()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02871">computeConstantLowerOrUpperBound()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02073">convertDimToLocal()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02994">dump()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02352">flattenAlignedMapAndMergeLocals()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02927">getConstantBound()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02743">getConstantBoundOnDimSize()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00384">getIdKindOffset()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02093">getLowerAndUpperBound()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01733">getLowerAndUpperBoundIndices()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00864">hasConsistentState()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00882">hasInvalidConstraint()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02937">isHyperRectangular()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01951">mergeLocalIds()</a>, <a class="el" href="AffineStructures_8h_source.html#l00545">numIds</a>, <a class="el" href="AffineStructures_8h_source.html#l00552">numSymbols</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02962">print()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l03731">removeIndependentConstraints()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01878">removeRedundantConstraints()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01838">removeRedundantInequalities()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l03002">removeTrivialRedundancy()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l00327">appendLocalId()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l03563">computeLocalVars()</a>, <a class="el" href="Analysis_2Utils_8cpp_source.html#l00811">mlir::computeSliceUnion()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01925">eliminateRedundantLocalId()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00159">FlatAffineConstraints()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02352">flattenAlignedMapAndMergeLocals()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l03646">getAsIntegerSet()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l03403">getCommonConstraints()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l03593">mlir::FlatAffineValueConstraints::getIneqAsAffineValueMap()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01476">getLocalReprs()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02093">getLowerAndUpperBound()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02181">getSliceBounds()</a>, <a class="el" href="Analysis_2Utils_8cpp_source.html#l00221">mlir::ComputationSliceState::isSliceValid()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01951">mergeLocalIds()</a>, <a class="el" href="Transforms_2Utils_2Utils_8cpp_source.html#l00692">mlir::normalizeMemRefType()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02962">print()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00947">removeIdRange()</a>, <a class="el" href="PresburgerSet_8cpp_source.html#l00185">subtractRecursively()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l03429">unionBoundingBox()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l03540">mlir::FlatAffineValueConstraints::unionBoundingBox()</a>.</p>

</div>
</div>
<a id="a597e435e789ef833a1e0cc80cd82a388"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a597e435e789ef833a1e0cc80cd82a388">&#9670;&nbsp;</a></span>getNumReservedEqualities()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> mlir::FlatAffineConstraints::getNumReservedEqualities </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineStructures_8h_source.html#l00199">199</a> of file <a class="el" href="AffineStructures_8h_source.html">AffineStructures.h</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8h_source.html#l00555">equalities</a>, and <a class="el" href="Matrix_8cpp_source.html#l00055">mlir::Matrix::getNumReservedRows()</a>.</p>

</div>
</div>
<a id="a3617c7a6eef7e4c3d1b1845025900adf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3617c7a6eef7e4c3d1b1845025900adf">&#9670;&nbsp;</a></span>getNumReservedInequalities()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> mlir::FlatAffineConstraints::getNumReservedInequalities </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineStructures_8h_source.html#l00203">203</a> of file <a class="el" href="AffineStructures_8h_source.html">AffineStructures.h</a>.</p>

<p class="reference">References <a class="el" href="Matrix_8cpp_source.html#l00055">mlir::Matrix::getNumReservedRows()</a>, and <a class="el" href="AffineStructures_8h_source.html#l00558">inequalities</a>.</p>

</div>
</div>
<a id="aff8074c726e597eb5a963a68451bb7fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff8074c726e597eb5a963a68451bb7fe">&#9670;&nbsp;</a></span>getNumSymbolIds()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> mlir::FlatAffineConstraints::getNumSymbolIds </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineStructures_8h_source.html#l00355">355</a> of file <a class="el" href="AffineStructures_8h_source.html">AffineStructures.h</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8h_source.html#l00552">numSymbols</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l02376">addBound()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00286">append()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00315">appendSymbolId()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00321">mlir::FlatAffineValueConstraints::appendSymbolId()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00436">areIdsAligned()</a>, <a class="el" href="PresburgerSet_8cpp_source.html#l00042">assertDimensionsCompatible()</a>, <a class="el" href="LoopSpecialization_8cpp_source.html#l00422">mlir::scf::canonicalizeMinMaxOpInLoop()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00564">composeMatchingMap()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l03563">computeLocalVars()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01626">detectAsMod()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l02608">generateCopy()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l03646">getAsIntegerSet()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l03403">getCommonConstraints()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02743">getConstantBoundOnDimSize()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l03593">mlir::FlatAffineValueConstraints::getIneqAsAffineValueMap()</a>, <a class="el" href="AffineStructures_8h_source.html#l00885">mlir::FlatAffineValueConstraints::getMaybeDimAndSymbolValues()</a>, <a class="el" href="AffineStructures_8h_source.html#l00881">mlir::FlatAffineValueConstraints::getMaybeSymbolValues()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l03093">getNewNumDimsSymbols()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02181">getSliceBounds()</a>, <a class="el" href="Analysis_2Utils_8cpp_source.html#l00221">mlir::ComputationSliceState::isSliceValid()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01951">mergeLocalIds()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00626">mlir::FlatAffineValueConstraints::mergeSymbolIds()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02962">print()</a>, <a class="el" href="PresburgerSet_8cpp_source.html#l00185">subtractRecursively()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00613">turnSymbolIntoDim()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l03429">unionBoundingBox()</a>.</p>

</div>
</div>
<a id="a27fe40151ae13ca4d10c425937ff70f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27fe40151ae13ca4d10c425937ff70f2">&#9670;&nbsp;</a></span>getSliceBounds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> FlatAffineConstraints::getSliceBounds </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt; *&#160;</td>
          <td class="paramname"><em>lbMaps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt; *&#160;</td>
          <td class="paramname"><em>ubMaps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the lower and upper bounds of the first <code>num</code> dimensional identifiers (starting at <code>offset</code>) as an affine map of the remaining identifiers (dimensional and symbolic). </p>
<p>Computes the lower and upper bounds of the first 'num' dimensional identifiers (starting at 'offset') as affine maps of the remaining identifiers (dimensional and symbolic identifiers).</p>
<p>This method is able to detect identifiers as floordiv's and mod's of affine expressions of other identifiers with respect to (positive) constants. Sets bound map to a null <a class="el" href="classmlir_1_1AffineMap.html" title="A multi-dimensional affine map Affine map&#39;s are immutable like Type&#39;s, and they are uniqued...">AffineMap</a> if such a bound can't be found (or yet unimplemented).</p>
<p>Local identifiers are themselves explicitly computed as affine functions of other identifiers in this process if needed. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l02181">2181</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8h_source.html#l00181">atEq()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01791">detectAsFloorDiv()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01626">detectAsMod()</a>, <a class="el" href="AsmPrinter_8cpp_source.html#l02748">mlir::AffineMap::dump()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02994">dump()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00817">findConstraintWithNonZeroAt()</a>, <a class="el" href="AffineStructures_8h_source.html#l00069">FlatAffineConstraints()</a>, <a class="el" href="MathExtras_8h_source.html#l00032">mlir::floorDiv()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l00932">mlir::AffineMap::get()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00514">mlir::getAffineConstantExpr()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00489">mlir::getAffineDimExpr()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00499">mlir::getAffineSymbolExpr()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02927">getConstantBound()</a>, <a class="el" href="AffineStructures_8h_source.html#l00356">getNumDimAndSymbolIds()</a>, <a class="el" href="AffineStructures_8h_source.html#l00354">getNumDimIds()</a>, <a class="el" href="AffineStructures_8h_source.html#l00353">getNumIds()</a>, <a class="el" href="AffineStructures_8h_source.html#l00357">getNumLocalIds()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00302">mlir::AffineMap::getNumResults()</a>, <a class="el" href="AffineStructures_8h_source.html#l00355">getNumSymbolIds()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00855">normalizeConstraintsByGCD()</a>, and <a class="el" href="IR_2AffineExpr_8cpp_source.html#l01390">mlir::simplifyAffineExpr()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopSpecialization_8cpp_source.html#l00225">canonicalizeMinMaxOp()</a>, <a class="el" href="Analysis_2Utils_8cpp_source.html#l00811">mlir::computeSliceUnion()</a>, <a class="el" href="Analysis_2Utils_8cpp_source.html#l01046">mlir::getComputationSliceState()</a>, and <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00180">mlir::linalg::getUpperBoundForIndex()</a>.</p>

</div>
</div>
<a id="abe0c6f1821da05edc091e82d187e0e10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe0c6f1821da05edc091e82d187e0e10">&#9670;&nbsp;</a></span>getUniverse()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classmlir_1_1FlatAffineConstraints.html">FlatAffineConstraints</a> mlir::FlatAffineConstraints::getUniverse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>numDims</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>numSymbols</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a system with no constraints, i.e., one which is satisfied by all points. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8h_source.html#l00092">92</a> of file <a class="el" href="AffineStructures_8h_source.html">AffineStructures.h</a>.</p>

<p class="reference">References <a class="el" href="classmlir_1_1FlatAffineConstraints.html#ac7022f51854ec1d369bb150035a1437fa5d3c39d196a997e225b4f3ee3e1da745">FlatAffineConstraints</a>, <a class="el" href="AffineStructures_8h_source.html#l00548">numDims</a>, <a class="el" href="AffineStructures_8h_source.html#l00552">numSymbols</a>, and <a class="el" href="classmlir_1_1FlatAffineConstraints.html#a948c10906e0c0a4ab77176a31035a73b">~FlatAffineConstraints()</a>.</p>

<p class="reference">Referenced by <a class="el" href="PresburgerSet_8cpp_source.html#l00333">mlir::PresburgerSet::complement()</a>, and <a class="el" href="PresburgerSet_8cpp_source.html#l00095">mlir::PresburgerSet::getUniverse()</a>.</p>

</div>
</div>
<a id="a0803bcab8d26f4efbca03765c15973d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0803bcab8d26f4efbca03765c15973d3">&#9670;&nbsp;</a></span>hasConsistentState()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool FlatAffineConstraints::hasConsistentState </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns false if the fields corresponding to various identifier counts, or equality/inequality buffer sizes aren't consistent; true otherwise. </p>
<p>This is meant to be used within an assert internally. </p>

<p>Reimplemented in <a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a3202cddcf31d0798de72cac6742248b0">mlir::FlatAffineValueConstraints</a>.</p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l00864">864</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8h_source.html#l00555">equalities</a>, <a class="el" href="Matrix_8cpp_source.html#l00211">mlir::Matrix::hasConsistentState()</a>, <a class="el" href="AffineStructures_8h_source.html#l00558">inequalities</a>, <a class="el" href="AffineStructures_8h_source.html#l00548">numDims</a>, <a class="el" href="AffineStructures_8h_source.html#l00545">numIds</a>, and <a class="el" href="AffineStructures_8h_source.html#l00552">numSymbols</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8h_source.html#l00357">getNumLocalIds()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00877">mlir::FlatAffineValueConstraints::hasConsistentState()</a>, and <a class="el" href="AffineStructures_8h_source.html#l00896">mlir::FlatAffineValueConstraints::setValues()</a>.</p>

</div>
</div>
<a id="a463bb136705774c5730444a1f0b48274"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a463bb136705774c5730444a1f0b48274">&#9670;&nbsp;</a></span>hasInvalidConstraint()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool FlatAffineConstraints::hasInvalidConstraint </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks all rows of equality/inequality constraints for trivial contradictions (for example: 1 == 0, 0 &gt;= 1), which may have surfaced after elimination. </p>
<p>Returns true if an invalid constraint is found; false otherwise. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l00882">882</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8h_source.html#l00181">atEq()</a>, <a class="el" href="AffineStructures_8h_source.html#l00185">atIneq()</a>, <a class="el" href="AffineStructures_8h_source.html#l00191">getNumCols()</a>, <a class="el" href="AffineStructures_8h_source.html#l00193">getNumEqualities()</a>, <a class="el" href="AffineStructures_8h_source.html#l00195">getNumInequalities()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l00877">mlir::FlatAffineValueConstraints::hasConsistentState()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8h_source.html#l00357">getNumLocalIds()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l01026">isEmpty()</a>.</p>

</div>
</div>
<a id="a79fc9ebec680aa4d6631f370d44489bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79fc9ebec680aa4d6631f370d44489bd">&#9670;&nbsp;</a></span>insertDimId()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> FlatAffineConstraints::insertDimId </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>num</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert <code>num</code> identifiers of the specified kind at position <code>pos</code>. </p>
<p>Positions are relative to the kind of identifier. The coefficient columns corresponding to the added identifiers are initialized to zero. Return the absolute column position (i.e., not relative to the kind of identifier) of the first added identifier. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l00333">333</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8cpp_source.html#l00394">mlir::FlatAffineValueConstraints::insertId()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8h_source.html#l00644">mlir::FlatAffineValueConstraints::classof()</a>.</p>

</div>
</div>
<a id="a2bf2f1aa4cfce8c357cfdb425c10bd36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bf2f1aa4cfce8c357cfdb425c10bd36">&#9670;&nbsp;</a></span>insertId()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> FlatAffineConstraints::insertId </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#ab47fbec6c4aff6faece95521b103fed2">IdKind</a>&#160;</td>
          <td class="paramname"><em>kind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>num</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented in <a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a7dde72b54f749643d4002efc28a643a0">mlir::FlatAffineValueConstraints</a>.</p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l00355">355</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8h_source.html#l00644">mlir::FlatAffineValueConstraints::classof()</a>.</p>

</div>
</div>
<a id="aa22f0aef1b34b0a585f7fb8a99b06388"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa22f0aef1b34b0a585f7fb8a99b06388">&#9670;&nbsp;</a></span>insertLocalId()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> FlatAffineConstraints::insertLocalId </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>num</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l00351">351</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8cpp_source.html#l00394">mlir::FlatAffineValueConstraints::insertId()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l02352">flattenAlignedMapAndMergeLocals()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l01951">mergeLocalIds()</a>.</p>

</div>
</div>
<a id="a27bc9f7ffaa98a041ecf68ec57bcefcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27bc9f7ffaa98a041ecf68ec57bcefcd">&#9670;&nbsp;</a></span>insertSymbolId()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> FlatAffineConstraints::insertSymbolId </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>num</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l00342">342</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8cpp_source.html#l00394">mlir::FlatAffineValueConstraints::insertId()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8h_source.html#l00644">mlir::FlatAffineValueConstraints::classof()</a>.</p>

</div>
</div>
<a id="a6ddc2ce92fc0297fbc8bfc62241c4472"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ddc2ce92fc0297fbc8bfc62241c4472">&#9670;&nbsp;</a></span>isEmpty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool FlatAffineConstraints::isEmpty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks for emptiness by performing variable elimination on all identifiers, running the GCD test on each equality constraint, and checking for invalid constraints. </p>
<p>Returns true if the GCD test fails for any equality, or if any invalid constraints are discovered on any row. Returns false otherwise. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l01026">1026</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8cpp_source.html#l03157">fourierMotzkinEliminate()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01556">gaussianEliminateIds()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00993">getBestIdToEliminate()</a>, <a class="el" href="AffineStructures_8h_source.html#l00350">getNumConstraints()</a>, <a class="el" href="AffineStructures_8h_source.html#l00353">getNumIds()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00882">hasInvalidConstraint()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01087">isEmptyByGCDTest()</a>, <a class="el" href="AffineStructures_8h_source.html#l00570">kExplosionFactor</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l02031">removeRedundantLocalVars()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopSpecialization_8cpp_source.html#l00225">canonicalizeMinMaxOp()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00568">mlir::checkMemrefAccessDependence()</a>, <a class="el" href="AffineStructures_8h_source.html#l00107">classof()</a>, <a class="el" href="PresburgerSet_8cpp_source.html#l00112">mlir::PresburgerSet::intersect()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01838">removeRedundantInequalities()</a>, and <a class="el" href="Analysis_2Utils_8cpp_source.html#l01367">mlir::simplifyIntegerSet()</a>.</p>

</div>
</div>
<a id="af318337e58529a47cd9c9e38e11b3e67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af318337e58529a47cd9c9e38e11b3e67">&#9670;&nbsp;</a></span>isEmptyByGCDTest()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool FlatAffineConstraints::isEmptyByGCDTest </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Runs the GCD test on all equality constraints. </p>
<p>Returns true if this test fails on any equality. Returns false otherwise. This test can be used to disprove the existence of a solution. If it returns true, no integer solution to the equality constraints can exist. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l01087">1087</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8h_source.html#l00181">atEq()</a>, <a class="el" href="AffineStructures_8h_source.html#l00191">getNumCols()</a>, <a class="el" href="AffineStructures_8h_source.html#l00193">getNumEqualities()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l00877">mlir::FlatAffineValueConstraints::hasConsistentState()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8h_source.html#l00107">classof()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01228">findIntegerSample()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01026">isEmpty()</a>, and <a class="el" href="PresburgerSet_8cpp_source.html#l00185">subtractRecursively()</a>.</p>

</div>
</div>
<a id="afa635e50de116843fba9c4d6213ce14c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa635e50de116843fba9c4d6213ce14c">&#9670;&nbsp;</a></span>isHyperRectangular()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool FlatAffineConstraints::isHyperRectangular </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the set can be trivially detected as being hyper-rectangular on the specified contiguous set of identifiers. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l02937">2937</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8h_source.html#l00181">atEq()</a>, <a class="el" href="AffineStructures_8h_source.html#l00185">atIneq()</a>, <a class="el" href="AffineStructures_8h_source.html#l00191">getNumCols()</a>, <a class="el" href="AffineStructures_8h_source.html#l00193">getNumEqualities()</a>, and <a class="el" href="AffineStructures_8h_source.html#l00195">getNumInequalities()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUtils_8cpp_source.html#l00586">checkIfHyperRectangular()</a>, and <a class="el" href="AffineStructures_8h_source.html#l00357">getNumLocalIds()</a>.</p>

</div>
</div>
<a id="aef2b4af0478ccc4117618d8f530e41bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef2b4af0478ccc4117618d8f530e41bb">&#9670;&nbsp;</a></span>isIntegerEmpty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool FlatAffineConstraints::isIntegerEmpty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the set of constraints is found to have no solution, false if a solution exists. </p>
<p>Uses the same algorithm as <code>findIntegerSample</code>. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l01178">1178</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8cpp_source.html#l01228">findIntegerSample()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8h_source.html#l00107">classof()</a>, and <a class="el" href="PresburgerSet_8cpp_source.html#l00364">mlir::PresburgerSet::isIntegerEmpty()</a>.</p>

</div>
</div>
<a id="ae0b82371642e5a1db0e6125f07b3713f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0b82371642e5a1db0e6125f07b3713f">&#9670;&nbsp;</a></span>mergeLocalIds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> FlatAffineConstraints::mergeLocalIds </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1FlatAffineConstraints.html">FlatAffineConstraints</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds additional local ids to the sets such that they both have the union of the local ids in each set, without changing the set of points that lie in <code>this</code> and <code>other</code>. </p>
<p>The ordering of the local ids in the sets may also be changed. After merging, if the <code>i^th</code> local variable in one set has a known division representation, then the <code>i^th</code> local variable in the other set either has the same division representation or no known division representation.</p>
<p>The number of dimensions and symbol ids in <code>this</code> and <code>other</code> should match.</p>
<p>To detect local ids that always take the same in both sets, each local id is represented as a floordiv with constant denominator in terms of other ids. After extracting these divisions, local ids with the same division representation are considered duplicate and are merged. It is possible that division representation for some local id cannot be obtained, and thus these local ids are not considered for detecting duplicates. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l01951">1951</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="ConvertLaunchFuncToLLVMCalls_8cpp_source.html#l00066">copy()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01925">eliminateRedundantLocalId()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00384">getIdKindOffset()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01491">getLocalReprs()</a>, <a class="el" href="AffineStructures_8h_source.html#l00354">getNumDimIds()</a>, <a class="el" href="AffineStructures_8h_source.html#l00357">getNumLocalIds()</a>, <a class="el" href="AffineStructures_8h_source.html#l00355">getNumSymbolIds()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l00351">insertLocalId()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l03808">mlir::FlatAffineRelation::compose()</a>, <a class="el" href="AffineStructures_8h_source.html#l00357">getNumLocalIds()</a>, <a class="el" href="PresburgerSet_8cpp_source.html#l00112">mlir::PresburgerSet::intersect()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00500">mergeAndAlignIds()</a>, and <a class="el" href="PresburgerSet_8cpp_source.html#l00185">subtractRecursively()</a>.</p>

</div>
</div>
<a id="a72473a5174d309b4dca1dba327ff901e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72473a5174d309b4dca1dba327ff901e">&#9670;&nbsp;</a></span>normalizeConstraintsByGCD()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> FlatAffineConstraints::normalizeConstraintsByGCD </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Normalized each constraints by the GCD of its coefficients. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l00855">855</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8h_source.html#l00193">getNumEqualities()</a>, <a class="el" href="AffineStructures_8h_source.html#l00195">getNumInequalities()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l00836">normalizeConstraintByGCD()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8h_source.html#l00501">gaussianEliminateId()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02181">getSliceBounds()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l03331">projectOut()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l03002">removeTrivialRedundancy()</a>.</p>

</div>
</div>
<a id="a32f2f50452ba560992138f6df070045e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32f2f50452ba560992138f6df070045e">&#9670;&nbsp;</a></span>print()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> FlatAffineConstraints::print </td>
          <td>(</td>
          <td class="paramtype">raw_ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l02962">2962</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8h_source.html#l00181">atEq()</a>, <a class="el" href="AffineStructures_8h_source.html#l00185">atIneq()</a>, <a class="el" href="AffineStructures_8h_source.html#l00191">getNumCols()</a>, <a class="el" href="AffineStructures_8h_source.html#l00350">getNumConstraints()</a>, <a class="el" href="AffineStructures_8h_source.html#l00354">getNumDimIds()</a>, <a class="el" href="AffineStructures_8h_source.html#l00193">getNumEqualities()</a>, <a class="el" href="AffineStructures_8h_source.html#l00353">getNumIds()</a>, <a class="el" href="AffineStructures_8h_source.html#l00195">getNumInequalities()</a>, <a class="el" href="AffineStructures_8h_source.html#l00357">getNumLocalIds()</a>, <a class="el" href="AffineStructures_8h_source.html#l00355">getNumSymbolIds()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l00877">mlir::FlatAffineValueConstraints::hasConsistentState()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l02994">dump()</a>, <a class="el" href="AffineStructures_8h_source.html#l00357">getNumLocalIds()</a>, and <a class="el" href="PresburgerSet_8cpp_source.html#l00384">mlir::PresburgerSet::print()</a>.</p>

</div>
</div>
<a id="a63d1457dc3d54274c1519c6553be921d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63d1457dc3d54274c1519c6553be921d">&#9670;&nbsp;</a></span>projectOut() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> FlatAffineConstraints::projectOut </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Projects out (aka eliminates) <code>num</code> identifiers starting at position <code>pos</code>. </p>
<p>The resulting constraint system is the shadow along the dimensions that still exist. This method may not always be integer exact. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l03331">3331</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8cpp_source.html#l03318">mlir::FlatAffineValueConstraints::fourierMotzkinEliminate()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01556">gaussianEliminateIds()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01537">gcdTightenInequalities()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00993">getBestIdToEliminate()</a>, <a class="el" href="AffineStructures_8h_source.html#l00191">getNumCols()</a>, <a class="el" href="AffineStructures_8h_source.html#l00353">getNumIds()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l00855">normalizeConstraintsByGCD()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Transforms_2Utils_2Utils_8cpp_source.html#l00692">mlir::normalizeMemRefType()</a>.</p>

</div>
</div>
<a id="a8c3d0c1b0bad5d54e4b5f91910c52503"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c3d0c1b0bad5d54e4b5f91910c52503">&#9670;&nbsp;</a></span>projectOut() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::FlatAffineConstraints::projectOut </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineStructures_8h_source.html#l00294">294</a> of file <a class="el" href="AffineStructures_8h_source.html">AffineStructures.h</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8cpp_source.html#l02709">constantFoldId()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02722">constantFoldIdRange()</a>, <a class="el" href="AffineStructures_8h_source.html#l00294">projectOut()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02640">removeEquality()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02648">removeEqualityRange()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00423">removeId()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00427">removeIdRange()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02644">removeInequality()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02654">removeInequalityRange()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02691">setAndEliminate()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02624">setDimSymbolSeparation()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l03429">unionBoundingBox()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8h_source.html#l00294">projectOut()</a>.</p>

</div>
</div>
<a id="ae3d4894b1c67f1e06424e1453c585bbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3d4894b1c67f1e06424e1453c585bbf">&#9670;&nbsp;</a></span>removeEquality()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> FlatAffineConstraints::removeEquality </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l02640">2640</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8h_source.html#l00555">equalities</a>, and <a class="el" href="Matrix_8cpp_source.html#l00164">mlir::Matrix::removeRow()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l01556">gaussianEliminateIds()</a>, <a class="el" href="AffineStructures_8h_source.html#l00294">projectOut()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01166">removeConstraintsInvolvingSuffixDims()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l03731">removeIndependentConstraints()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l02031">removeRedundantLocalVars()</a>.</p>

</div>
</div>
<a id="a24e9ea709b9d11a7cfd9899aa9fefc39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24e9ea709b9d11a7cfd9899aa9fefc39">&#9670;&nbsp;</a></span>removeEqualityRange()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> FlatAffineConstraints::removeEqualityRange </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove the (in)equalities at positions [start, end). </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l02648">2648</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8h_source.html#l00555">equalities</a>, and <a class="el" href="Matrix_8cpp_source.html#l00165">mlir::Matrix::removeRows()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8h_source.html#l00294">projectOut()</a>, and <a class="el" href="PresburgerSet_8cpp_source.html#l00185">subtractRecursively()</a>.</p>

</div>
</div>
<a id="ac6953eccc1eb2884e95680dc7994c06b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6953eccc1eb2884e95680dc7994c06b">&#9670;&nbsp;</a></span>removeId() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> FlatAffineConstraints::removeId </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#ab47fbec6c4aff6faece95521b103fed2">IdKind</a>&#160;</td>
          <td class="paramname"><em>kind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes identifiers of the specified kind with the specified pos (or within the specified range) from the system. </p>
<p>The specified location is relative to the first identifier of the specified kind. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l00423">423</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUtils_8cpp_source.html#l03233">createSeparationCondition()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01925">eliminateRedundantLocalId()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l03157">fourierMotzkinEliminate()</a>, <a class="el" href="AffineStructures_8h_source.html#l00294">projectOut()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l02031">removeRedundantLocalVars()</a>.</p>

</div>
</div>
<a id="aa7e3fb602c03ba136b94b31a58bca727"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7e3fb602c03ba136b94b31a58bca727">&#9670;&nbsp;</a></span>removeId() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> FlatAffineConstraints::removeId </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the specified identifier from the system. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l03088">3088</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8cpp_source.html#l00982">mlir::FlatAffineValueConstraints::removeIdRange()</a>.</p>

</div>
</div>
<a id="a80a92ac0a8ca842b0c43d235ce86a4fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80a92ac0a8ca842b0c43d235ce86a4fc">&#9670;&nbsp;</a></span>removeIdRange() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> FlatAffineConstraints::removeIdRange </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#ab47fbec6c4aff6faece95521b103fed2">IdKind</a>&#160;</td>
          <td class="paramname"><em>kind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>idStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>idLimit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l00427">427</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l01228">findIntegerSample()</a>, <a class="el" href="AffineStructures_8h_source.html#l00501">gaussianEliminateId()</a>, <a class="el" href="AffineStructures_8h_source.html#l00294">projectOut()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00982">mlir::FlatAffineValueConstraints::removeIdRange()</a>, <a class="el" href="AffineStructures_8h_source.html#l00896">mlir::FlatAffineValueConstraints::setValues()</a>, and <a class="el" href="PresburgerSet_8cpp_source.html#l00185">subtractRecursively()</a>.</p>

</div>
</div>
<a id="a54db163f9d82617265f1a1166667d114"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54db163f9d82617265f1a1166667d114">&#9670;&nbsp;</a></span>removeIdRange() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> FlatAffineConstraints::removeIdRange </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>idStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>idLimit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes identifiers in the column range [idStart, idLimit), and copies any remaining valid data into place, updates member variables, and resizes arrays as needed. </p>

<p>Reimplemented in <a class="el" href="classmlir_1_1FlatAffineRelation.html#a1d7c7d7e81a2975456aca816950b0f0c">mlir::FlatAffineRelation</a>, and <a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a2b415d11d42c0a1e02bc2c35833d3a2d">mlir::FlatAffineValueConstraints</a>.</p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l00947">947</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8h_source.html#l00555">equalities</a>, <a class="el" href="AffineStructures_8h_source.html#l00191">getNumCols()</a>, <a class="el" href="AffineStructures_8h_source.html#l00357">getNumLocalIds()</a>, <a class="el" href="AffineStructures_8h_source.html#l00558">inequalities</a>, <a class="el" href="PolynomialApproximation_8cpp_source.html#l00185">max()</a>, <a class="el" href="PolynomialApproximation_8cpp_source.html#l00180">min()</a>, <a class="el" href="AffineStructures_8h_source.html#l00548">numDims</a>, <a class="el" href="AffineStructures_8h_source.html#l00545">numIds</a>, <a class="el" href="AffineStructures_8h_source.html#l00552">numSymbols</a>, and <a class="el" href="Matrix_8cpp_source.html#l00137">mlir::Matrix::removeColumns()</a>.</p>

</div>
</div>
<a id="ac9dbede371ec7b45452b41c7ecc7045e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9dbede371ec7b45452b41c7ecc7045e">&#9670;&nbsp;</a></span>removeIndependentConstraints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> FlatAffineConstraints::removeIndependentConstraints </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes constraints that are independent of (i.e., do not have a coefficient) identifiers in the range [pos, pos + num). </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l03731">3731</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8cpp_source.html#l03701">getIndependentConstraints()</a>, <a class="el" href="AffineStructures_8h_source.html#l00353">getNumIds()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02640">removeEquality()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l02644">removeInequality()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUtils_8cpp_source.html#l03233">createSeparationCondition()</a>, and <a class="el" href="AffineStructures_8h_source.html#l00357">getNumLocalIds()</a>.</p>

</div>
</div>
<a id="a82531e4f08beebf1338bf1ac5207475b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82531e4f08beebf1338bf1ac5207475b">&#9670;&nbsp;</a></span>removeInequality()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> FlatAffineConstraints::removeInequality </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l02644">2644</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8h_source.html#l00558">inequalities</a>, and <a class="el" href="Matrix_8cpp_source.html#l00164">mlir::Matrix::removeRow()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8h_source.html#l00294">projectOut()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01166">removeConstraintsInvolvingSuffixDims()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l03731">removeIndependentConstraints()</a>, and <a class="el" href="PresburgerSet_8cpp_source.html#l00185">subtractRecursively()</a>.</p>

</div>
</div>
<a id="a6695090f5659966f8aeeb44f9491d861"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6695090f5659966f8aeeb44f9491d861">&#9670;&nbsp;</a></span>removeInequalityRange()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> FlatAffineConstraints::removeInequalityRange </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l02654">2654</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8h_source.html#l00558">inequalities</a>, and <a class="el" href="Matrix_8cpp_source.html#l00165">mlir::Matrix::removeRows()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8h_source.html#l00294">projectOut()</a>, and <a class="el" href="PresburgerSet_8cpp_source.html#l00185">subtractRecursively()</a>.</p>

</div>
</div>
<a id="ae9d4b723904aafdfe34740b766c78789"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9d4b723904aafdfe34740b766c78789">&#9670;&nbsp;</a></span>removeRedundantConstraints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> FlatAffineConstraints::removeRedundantConstraints </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes redundant constraints using <a class="el" href="classmlir_1_1Simplex.html" title="This class implements a version of the Simplex and Generalized Basis Reduction algorithms, which can perform analysis of integer sets with affine inequalities and equalities. ">Simplex</a>. </p>
<p>Although the algorithm can theoretically take exponential time in the worst case (rare), it is known to perform much better in the average case. If V is the number of vertices in the polytope and C is the number of constraints, the algorithm takes O(VC) time. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l01878">1878</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8h_source.html#l00181">atEq()</a>, <a class="el" href="AffineStructures_8h_source.html#l00185">atIneq()</a>, <a class="el" href="Simplex_8cpp_source.html#l00596">mlir::Simplex::detectRedundant()</a>, <a class="el" href="AffineStructures_8h_source.html#l00555">equalities</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01537">gcdTightenInequalities()</a>, <a class="el" href="AffineStructures_8h_source.html#l00191">getNumCols()</a>, <a class="el" href="AffineStructures_8h_source.html#l00193">getNumEqualities()</a>, <a class="el" href="AffineStructures_8h_source.html#l00195">getNumInequalities()</a>, <a class="el" href="AffineStructures_8h_source.html#l00558">inequalities</a>, <a class="el" href="Simplex_8cpp_source.html#l00576">mlir::Simplex::isMarkedRedundant()</a>, and <a class="el" href="Matrix_8cpp_source.html#l00080">mlir::Matrix::resizeVertically()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8h_source.html#l00357">getNumLocalIds()</a>.</p>

</div>
</div>
<a id="a60b9abcf1ae4683b7ed214125d4d05c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60b9abcf1ae4683b7ed214125d4d05c8">&#9670;&nbsp;</a></span>removeRedundantInequalities()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> FlatAffineConstraints::removeRedundantInequalities </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A more expensive check than <code>removeTrivialRedundancy</code> to detect redundant inequalities. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l01838">1838</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8h_source.html#l00185">atIneq()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01822">fillInequality()</a>, <a class="el" href="AffineStructures_8h_source.html#l00191">getNumCols()</a>, <a class="el" href="AffineStructures_8h_source.html#l00195">getNumInequalities()</a>, <a class="el" href="AffineStructures_8h_source.html#l00558">inequalities</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01026">isEmpty()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01830">negateInequality()</a>, and <a class="el" href="Matrix_8cpp_source.html#l00080">mlir::Matrix::resizeVertically()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8h_source.html#l00357">getNumLocalIds()</a>.</p>

</div>
</div>
<a id="af9208d76671184c970f66b656b3a5879"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9208d76671184c970f66b656b3a5879">&#9670;&nbsp;</a></span>removeRedundantLocalVars()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> FlatAffineConstraints::removeRedundantLocalVars </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes local variables using equalities. </p>
<p>Each equality is checked if it can be reduced to the form: <code>e = affine-expr</code>, where <code>e</code> is a local variable and <code>affine-expr</code> is an affine expression not containing <code>e</code>. If an equality satisfies this form, the local variable is replaced in each constraint and then removed. The equality used to replace this local variable is also removed. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l02031">2031</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8h_source.html#l00181">atEq()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00915">eliminateFromConstraint()</a>, <a class="el" href="AffineStructures_8h_source.html#l00356">getNumDimAndSymbolIds()</a>, <a class="el" href="AffineStructures_8h_source.html#l00193">getNumEqualities()</a>, <a class="el" href="AffineStructures_8h_source.html#l00353">getNumIds()</a>, <a class="el" href="AffineStructures_8h_source.html#l00195">getNumInequalities()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00836">normalizeConstraintByGCD()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02640">removeEquality()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l00423">removeId()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l03808">mlir::FlatAffineRelation::compose()</a>, <a class="el" href="AffineStructures_8h_source.html#l00501">gaussianEliminateId()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l01026">isEmpty()</a>.</p>

</div>
</div>
<a id="ab3a710d4a8812b2e76eb3908a5767dac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3a710d4a8812b2e76eb3908a5767dac">&#9670;&nbsp;</a></span>removeTrivialRedundancy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> FlatAffineConstraints::removeTrivialRedundancy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes duplicate constraints, trivially true constraints, and constraints that can be detected as redundant as a result of differing only in their constant term part. </p>
<p>A constraint of the form &lt;non-negative constant&gt; &gt;= 0 is considered trivially true. This method is a linear time method on the constraints, does a single scan, and updates in place. It also normalizes constraints by their GCD and performs GCD tightening on inequalities.</p>
<p>A constraint of the form &lt;non-negative constant&gt; &gt;= 0 is considered trivially true. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l03002">3002</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8h_source.html#l00185">atIneq()</a>, <a class="el" href="Matrix_8cpp_source.html#l00174">mlir::Matrix::copyRow()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01537">gcdTightenInequalities()</a>, <a class="el" href="AffineStructures_8h_source.html#l00191">getNumCols()</a>, <a class="el" href="AffineStructures_8h_source.html#l00195">getNumInequalities()</a>, <a class="el" href="AffineStructures_8h_source.html#l00558">inequalities</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00855">normalizeConstraintsByGCD()</a>, and <a class="el" href="Matrix_8cpp_source.html#l00080">mlir::Matrix::resizeVertically()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUtils_8cpp_source.html#l03233">createSeparationCondition()</a>, <a class="el" href="AffineStructures_8h_source.html#l00357">getNumLocalIds()</a>, and <a class="el" href="Analysis_2Utils_8cpp_source.html#l01367">mlir::simplifyIntegerSet()</a>.</p>

</div>
</div>
<a id="a3edb59b14438aee23b65a97fec843573"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3edb59b14438aee23b65a97fec843573">&#9670;&nbsp;</a></span>reset() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> FlatAffineConstraints::reset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>numReservedInequalities</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>numReservedEqualities</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>numReservedCols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>numDims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>numSymbols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>numLocals</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clears any existing data and reserves memory for the specified constraints. </p>

<p>Reimplemented in <a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#ad9813ab39fe84ac3208f6475c0058e02">mlir::FlatAffineValueConstraints</a>.</p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l00235">235</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8h_source.html#l00069">FlatAffineConstraints()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8h_source.html#l00107">classof()</a>, <a class="el" href="AffineStructures_8h_source.html#l00644">mlir::FlatAffineValueConstraints::classof()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l03403">getCommonConstraints()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00074">getFlattenedAffineExprs()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l00120">mlir::getFlattenedAffineExprs()</a>.</p>

</div>
</div>
<a id="ab5a1350a0302ad695d2c11a065d59ee2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5a1350a0302ad695d2c11a065d59ee2">&#9670;&nbsp;</a></span>reset() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> FlatAffineConstraints::reset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>numDims</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>numSymbols</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>numLocals</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l00272">272</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8cpp_source.html#l00247">mlir::FlatAffineValueConstraints::reset()</a>.</p>

</div>
</div>
<a id="a1c88dcf47e95f1973d1f2bb5f40979e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c88dcf47e95f1973d1f2bb5f40979e5">&#9670;&nbsp;</a></span>setAndEliminate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> FlatAffineConstraints::setAndEliminate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the <code>values.size()</code> identifiers starting at <code>po</code>s to the specified values and removes them. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l02691">2691</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8h_source.html#l00181">atEq()</a>, <a class="el" href="AffineStructures_8h_source.html#l00185">atIneq()</a>, <a class="el" href="AffineStructures_8h_source.html#l00191">getNumCols()</a>, <a class="el" href="AffineStructures_8h_source.html#l00193">getNumEqualities()</a>, <a class="el" href="AffineStructures_8h_source.html#l00353">getNumIds()</a>, <a class="el" href="AffineStructures_8h_source.html#l00195">getNumInequalities()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l00982">mlir::FlatAffineValueConstraints::removeIdRange()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l02709">constantFoldId()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01228">findIntegerSample()</a>, and <a class="el" href="AffineStructures_8h_source.html#l00294">projectOut()</a>.</p>

</div>
</div>
<a id="ad4924b4c54d6823f8e52933ca960c1ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4924b4c54d6823f8e52933ca960c1ff">&#9670;&nbsp;</a></span>setDimSymbolSeparation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> FlatAffineConstraints::setDimSymbolSeparation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>newSymbolCount</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Changes the partition between dimensions and symbols. </p>
<p>Depending on the new symbol count, either a chunk of trailing dimensional identifiers becomes symbols, or some of the leading symbols become dimensions. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l02624">2624</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8h_source.html#l00548">numDims</a>, and <a class="el" href="AffineStructures_8h_source.html#l00552">numSymbols</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUtils_8cpp_source.html#l03315">createFullTiles()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l03233">createSeparationCondition()</a>, <a class="el" href="AffineStructures_8h_source.html#l00294">projectOut()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l00613">turnSymbolIntoDim()</a>.</p>

</div>
</div>
<a id="a926a9821dc4fa697619e08d65eeaeac5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a926a9821dc4fa697619e08d65eeaeac5">&#9670;&nbsp;</a></span>swapId()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> FlatAffineConstraints::swapId </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>posA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>posB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swap the posA^th identifier with the posB^th identifier. </p>

<p>Reimplemented in <a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#acda87dfc4340eb857e9bc9ab05141b16">mlir::FlatAffineValueConstraints</a>.</p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l02606">2606</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8h_source.html#l00181">atEq()</a>, <a class="el" href="AffineStructures_8h_source.html#l00185">atIneq()</a>, <a class="el" href="AffineStructures_8h_source.html#l00193">getNumEqualities()</a>, <a class="el" href="AffineStructures_8h_source.html#l00353">getNumIds()</a>, and <a class="el" href="AffineStructures_8h_source.html#l00195">getNumInequalities()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8h_source.html#l00644">mlir::FlatAffineValueConstraints::classof()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l02619">mlir::FlatAffineValueConstraints::swapId()</a>.</p>

</div>
</div>
<a id="afeb8348eba3bd5c81db503336ae2ebfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afeb8348eba3bd5c81db503336ae2ebfc">&#9670;&nbsp;</a></span>unionBoundingBox()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> FlatAffineConstraints::unionBoundingBox </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1FlatAffineConstraints.html">FlatAffineConstraints</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates the constraints to be the smallest bounding (enclosing) box that contains the points of <code>this</code> set and that of <code>other</code>, with the symbols being treated specially. </p>
<p>For each of the dimensions, the min of the lower bounds (symbolic) and the max of the upper bounds (symbolic) is computed to determine such a bounding box. <code>other</code> is expected to have the same dimensional identifiers as this constraint system (in the same order).</p>
<p>E.g.: 1) this = {0 &lt;= d0 &lt;= 127}, other = {16 &lt;= d0 &lt;= 192}, output = {0 &lt;= d0 &lt;= 192} 2) this = {s0 + 5 &lt;= d0 &lt;= s0 + 20}, other = {s0 + 1 &lt;= d0 &lt;= s0 + 9}, output = {s0 + 1 &lt;= d0 &lt;= s0 + 20} 3) this = {0 &lt;= d0 &lt;= 5, 1 &lt;= d1 &lt;= 9} other = {2 &lt;= d0 &lt;= 6, 5 &lt;= d1 &lt;= 15}, output = {0 &lt;= d0 &lt;= 6, 1 &lt;= d1 &lt;= 15} </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l03429">3429</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l03403">getCommonConstraints()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02743">getConstantBoundOnDimSize()</a>, <a class="el" href="AffineStructures_8h_source.html#l00191">getNumCols()</a>, <a class="el" href="AffineStructures_8h_source.html#l00354">getNumDimIds()</a>, <a class="el" href="AffineStructures_8h_source.html#l00357">getNumLocalIds()</a>, <a class="el" href="AffineStructures_8h_source.html#l00355">getNumSymbolIds()</a>, and <a class="el" href="AffineStructures_8h_source.html#l00548">numDims</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8h_source.html#l00294">projectOut()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l03540">mlir::FlatAffineValueConstraints::unionBoundingBox()</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="af9b8780712cd511c02db2cac6fc642c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9b8780712cd511c02db2cac6fc642c3">&#9670;&nbsp;</a></span>equalities</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Matrix.html">Matrix</a> mlir::FlatAffineConstraints::equalities</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Coefficients of affine equalities (in == 0 form). </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8h_source.html#l00555">555</a> of file <a class="el" href="AffineStructures_8h_source.html">AffineStructures.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l02533">addBound()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02519">addEquality()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00286">append()</a>, <a class="el" href="AffineStructures_8h_source.html#l00181">atEq()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l03374">clearConstraints()</a>, <a class="el" href="AffineStructures_8h_source.html#l00207">getEquality()</a>, <a class="el" href="AffineStructures_8h_source.html#l00193">getNumEqualities()</a>, <a class="el" href="AffineStructures_8h_source.html#l00199">getNumReservedEqualities()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00864">hasConsistentState()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02640">removeEquality()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02648">removeEqualityRange()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00947">removeIdRange()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l01878">removeRedundantConstraints()</a>.</p>

</div>
</div>
<a id="ab66ed19c85ef3b3b54a38b50edddc85d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab66ed19c85ef3b3b54a38b50edddc85d">&#9670;&nbsp;</a></span>inequalities</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Matrix.html">Matrix</a> mlir::FlatAffineConstraints::inequalities</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Coefficients of affine inequalities (in &gt;= 0 form). </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8h_source.html#l00558">558</a> of file <a class="el" href="AffineStructures_8h_source.html">AffineStructures.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l02533">addBound()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02526">addInequality()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00286">append()</a>, <a class="el" href="AffineStructures_8h_source.html#l00185">atIneq()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l03374">clearConstraints()</a>, <a class="el" href="AffineStructures_8h_source.html#l00211">getInequality()</a>, <a class="el" href="AffineStructures_8h_source.html#l00195">getNumInequalities()</a>, <a class="el" href="AffineStructures_8h_source.html#l00203">getNumReservedInequalities()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00864">hasConsistentState()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00947">removeIdRange()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02644">removeInequality()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02654">removeInequalityRange()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01878">removeRedundantConstraints()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01838">removeRedundantInequalities()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l03002">removeTrivialRedundancy()</a>.</p>

</div>
</div>
<a id="a436d362961b4fbd768187df180d6425d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a436d362961b4fbd768187df180d6425d">&#9670;&nbsp;</a></span>kExplosionFactor</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classunsigned.html">unsigned</a> mlir::FlatAffineConstraints::kExplosionFactor = 32</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A parameter that controls detection of an unrealistic number of constraints. </p>
<p>If the number of constraints is this many times the number of variables, we consider such a system out of line with the intended use case of <a class="el" href="classmlir_1_1FlatAffineConstraints.html" title="A flat list of affine equalities and inequalities in the form. ">FlatAffineConstraints</a>. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8h_source.html#l00570">570</a> of file <a class="el" href="AffineStructures_8h_source.html">AffineStructures.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l01026">isEmpty()</a>.</p>

</div>
</div>
<a id="a2202d24f4dfb178dd579cceb9a81d552"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2202d24f4dfb178dd579cceb9a81d552">&#9670;&nbsp;</a></span>numDims</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> mlir::FlatAffineConstraints::numDims</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of identifiers corresponding to real dimensions. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8h_source.html#l00548">548</a> of file <a class="el" href="AffineStructures_8h_source.html">AffineStructures.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8h_source.html#l00107">classof()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02424">mlir::FlatAffineValueConstraints::computeAlignedMap()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l03563">computeLocalVars()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01151">eqInvolvesSuffixDims()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l03646">getAsIntegerSet()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l03593">mlir::FlatAffineValueConstraints::getIneqAsAffineValueMap()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l03093">getNewNumDimsSymbols()</a>, <a class="el" href="AffineStructures_8h_source.html#l00354">getNumDimIds()</a>, <a class="el" href="AffineStructures_8h_source.html#l00092">getUniverse()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00864">hasConsistentState()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01158">ineqInvolvesSuffixDims()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00947">removeIdRange()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02624">setDimSymbolSeparation()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l03429">unionBoundingBox()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l03540">mlir::FlatAffineValueConstraints::unionBoundingBox()</a>.</p>

</div>
</div>
<a id="ad724bee0d8c9f91d7e5884b098c5e929"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad724bee0d8c9f91d7e5884b098c5e929">&#9670;&nbsp;</a></span>numIds</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> mlir::FlatAffineConstraints::numIds</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Total number of identifiers. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8h_source.html#l00545">545</a> of file <a class="el" href="AffineStructures_8h_source.html">AffineStructures.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l03076">mlir::FlatAffineValueConstraints::clearAndCopyFrom()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01228">findIntegerSample()</a>, <a class="el" href="AffineStructures_8h_source.html#l00069">FlatAffineConstraints()</a>, <a class="el" href="AffineStructures_8h_source.html#l00579">mlir::FlatAffineValueConstraints::FlatAffineValueConstraints()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l03318">mlir::FlatAffineValueConstraints::fourierMotzkinEliminate()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01556">gaussianEliminateIds()</a>, <a class="el" href="AffineStructures_8h_source.html#l00869">mlir::FlatAffineValueConstraints::getAllValues()</a>, <a class="el" href="AffineStructures_8h_source.html#l00191">getNumCols()</a>, <a class="el" href="AffineStructures_8h_source.html#l00353">getNumIds()</a>, <a class="el" href="AffineStructures_8h_source.html#l00357">getNumLocalIds()</a>, <a class="el" href="AffineStructures_8h_source.html#l00860">mlir::FlatAffineValueConstraints::getValues()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00864">hasConsistentState()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00947">removeIdRange()</a>, <a class="el" href="AffineStructures_8h_source.html#l00890">mlir::FlatAffineValueConstraints::setValue()</a>, and <a class="el" href="AffineStructures_8h_source.html#l00896">mlir::FlatAffineValueConstraints::setValues()</a>.</p>

</div>
</div>
<a id="a8ec0168aae7454795c0a4939f2230642"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ec0168aae7454795c0a4939f2230642">&#9670;&nbsp;</a></span>numSymbols</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> mlir::FlatAffineConstraints::numSymbols</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of identifiers corresponding to symbols (unknown but constant for analysis). </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8h_source.html#l00552">552</a> of file <a class="el" href="AffineStructures_8h_source.html">AffineStructures.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l03748">mlir::alignAffineMapWithValues()</a>, <a class="el" href="AffineStructures_8h_source.html#l00107">classof()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02424">mlir::FlatAffineValueConstraints::computeAlignedMap()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l03093">getNewNumDimsSymbols()</a>, <a class="el" href="AffineStructures_8h_source.html#l00356">getNumDimAndSymbolIds()</a>, <a class="el" href="AffineStructures_8h_source.html#l00357">getNumLocalIds()</a>, <a class="el" href="AffineStructures_8h_source.html#l00355">getNumSymbolIds()</a>, <a class="el" href="AffineStructures_8h_source.html#l00092">getUniverse()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00864">hasConsistentState()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00947">removeIdRange()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l02624">setDimSymbolSeparation()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/mlir/Analysis/<a class="el" href="AffineStructures_8h_source.html">AffineStructures.h</a></li>
<li>lib/Analysis/<a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Dec 6 2021 20:34:11 for MLIR by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
