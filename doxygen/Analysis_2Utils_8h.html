<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MLIR: include/mlir/Analysis/Utils.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MLIR
   &#160;<span id="projectnumber">14.0.0git</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li><li class="navelem"><a class="el" href="dir_5654f77406fb9ceec87e68ef828ceea2.html">mlir</a></li><li class="navelem"><a class="el" href="dir_444b57698294f6a80104968315903582.html">Analysis</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#namespaces">Namespaces</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Utils.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="AffineStructures_8h_source.html">mlir/Analysis/AffineStructures.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="IR_2AffineMap_8h_source.html">mlir/IR/AffineMap.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Block_8h_source.html">mlir/IR/Block.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Location_8h_source.html">mlir/IR/Location.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Support_2LLVM_8h_source.html">mlir/Support/LLVM.h</a>&quot;</code><br />
<code>#include &quot;llvm/ADT/SmallVector.h&quot;</code><br />
<code>#include &lt;memory&gt;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for Utils.h:</div>
<div class="dyncontent">
<div class="center"><img src="Analysis_2Utils_8h__incl.png" border="0" usemap="#include_2mlir_2Analysis_2Utils_8h" alt=""/></div>
<map name="include_2mlir_2Analysis_2Utils_8h" id="include_2mlir_2Analysis_2Utils_8h">
<area shape="rect" id="node2" href="AffineStructures_8h.html" title="mlir/Analysis/AffineStructures.h" alt="" coords="754,95,981,121"/>
<area shape="rect" id="node4" href="Support_2LLVM_8h.html" title="mlir/Support/LLVM.h" alt="" coords="941,1087,1092,1114"/>
<area shape="rect" id="node24" href="Location_8h.html" title="mlir/IR/Location.h" alt="" coords="1994,692,2130,719"/>
<area shape="rect" id="node43" href="Block_8h.html" title="mlir/IR/Block.h" alt="" coords="1029,393,1146,420"/>
<area shape="rect" id="node48" href="IR_2AffineMap_8h.html" title="mlir/IR/AffineMap.h" alt="" coords="1845,923,1991,950"/>
<area shape="rect" id="node3" href="Matrix_8h.html" title="mlir/Analysis/Presburger\l/Matrix.h" alt="" coords="253,916,434,957"/>
<area shape="rect" id="node11" href="IR_2AffineExpr_8h.html" title="mlir/IR/AffineExpr.h" alt="" coords="1290,1005,1437,1032"/>
<area shape="rect" id="node16" href="OpDefinition_8h.html" title="mlir/IR/OpDefinition.h" alt="" coords="2062,169,2225,196"/>
<area shape="rect" id="node31" href="LogicalResult_8h.html" title="mlir/Support/LogicalResult.h" alt="" coords="381,1005,585,1032"/>
<area shape="rect" id="node17" href="IR_2Dialect_8h.html" title="mlir/IR/Dialect.h" alt="" coords="2080,319,2207,345"/>
<area shape="rect" id="node42" href="Operation_8h.html" title="mlir/IR/Operation.h" alt="" coords="1216,244,1361,271"/>
<area shape="rect" id="node18" href="OperationSupport_8h.html" title="mlir/IR/OperationSupport.h" alt="" coords="1887,393,2082,420"/>
<area shape="rect" id="node28" href="TypeID_8h.html" title="mlir/Support/TypeID.h" alt="" coords="1639,1005,1802,1032"/>
<area shape="rect" id="node19" href="BlockSupport_8h.html" title="mlir/IR/BlockSupport.h" alt="" coords="1520,468,1687,495"/>
<area shape="rect" id="node20" href="Value_8h.html" title="mlir/IR/Value.h" alt="" coords="1917,543,2034,569"/>
<area shape="rect" id="node21" href="Types_8h.html" title="mlir/IR/Types.h" alt="" coords="2016,923,2135,950"/>
<area shape="rect" id="node39" href="IR_2BuiltinAttributes_8h.html" title="mlir/IR/BuiltinAttributes.h" alt="" coords="1711,468,1898,495"/>
<area shape="rect" id="node23" href="UseDefLists_8h.html" title="mlir/IR/UseDefLists.h" alt="" coords="1875,617,2033,644"/>
<area shape="rect" id="node25" href="Attributes_8h.html" title="mlir/IR/Attributes.h" alt="" coords="1989,767,2135,793"/>
<area shape="rect" id="node26" href="AttributeSupport_8h.html" title="mlir/IR/AttributeSupport.h" alt="" coords="1292,841,1480,868"/>
<area shape="rect" id="node27" href="MLIRContext_8h.html" title="mlir/IR/MLIRContext.h" alt="" coords="1607,923,1770,950"/>
<area shape="rect" id="node30" href="StorageUniquerSupport_8h.html" title="mlir/IR/StorageUniquerSupport.h" alt="" coords="1351,923,1583,950"/>
<area shape="rect" id="node46" href="IR_2Diagnostics_8h.html" title="mlir/IR/Diagnostics.h" alt="" coords="1210,617,1367,644"/>
<area shape="rect" id="node47" href="IR_2Region_8h.html" title="mlir/IR/Region.h" alt="" coords="1025,319,1150,345"/>
<area shape="rect" id="node44" href="Visitors_8h.html" title="mlir/IR/Visitors.h" alt="" coords="677,923,807,950"/>
</map>
</div>
</div><div class="textblock"><div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dyncontent">
<div class="center"><img src="Analysis_2Utils_8h__dep__incl.png" border="0" usemap="#include_2mlir_2Analysis_2Utils_8hdep" alt=""/></div>
<map name="include_2mlir_2Analysis_2Utils_8hdep" id="include_2mlir_2Analysis_2Utils_8hdep">
<area shape="rect" id="node2" href="AffineAnalysis_8cpp.html" title="lib/Analysis/AffineAnalysis.cpp" alt="" coords="5,109,227,136"/>
<area shape="rect" id="node3" href="Analysis_2Utils_8cpp.html" title="lib/Analysis/Utils.cpp" alt="" coords="251,109,410,136"/>
<area shape="rect" id="node4" href="AffineDataCopyGeneration_8cpp.html" title="lib/Dialect/Affine\l/Transforms/AffineDataCopy\lGeneration.cpp" alt="" coords="434,95,638,151"/>
<area shape="rect" id="node5" href="AffineLoopInvariantCodeMotion_8cpp.html" title="lib/Dialect/Affine\l/Transforms/AffineLoopInvariant\lCodeMotion.cpp" alt="" coords="663,95,892,151"/>
<area shape="rect" id="node6" href="AffineParallelize_8cpp.html" title="lib/Dialect/Affine\l/Transforms/AffineParallelize.cpp" alt="" coords="916,102,1151,143"/>
<area shape="rect" id="node7" href="AffineScalarReplacement_8cpp.html" title="lib/Dialect/Affine\l/Transforms/AffineScalarReplacement.cpp" alt="" coords="1175,102,1467,143"/>
<area shape="rect" id="node8" href="LoopTiling_8cpp.html" title="lib/Dialect/Affine\l/Transforms/LoopTiling.cpp" alt="" coords="1491,102,1687,143"/>
<area shape="rect" id="node9" href="SimplifyAffineStructures_8cpp.html" title="lib/Dialect/Affine\l/Transforms/SimplifyAffine\lStructures.cpp" alt="" coords="1712,95,1907,151"/>
<area shape="rect" id="node10" href="Dialect_2Affine_2Utils_2Utils_8cpp.html" title="lib/Dialect/Affine\l/Utils/Utils.cpp" alt="" coords="1931,102,2061,143"/>
<area shape="rect" id="node11" href="LoopFusion_8cpp.html" title="lib/Transforms/LoopFusion.cpp" alt="" coords="2086,109,2303,136"/>
<area shape="rect" id="node12" href="PipelineDataTransfer_8cpp.html" title="lib/Transforms/PipelineData\lTransfer.cpp" alt="" coords="2327,102,2529,143"/>
<area shape="rect" id="node13" href="LoopFusionUtils_8cpp.html" title="lib/Transforms/Utils\l/LoopFusionUtils.cpp" alt="" coords="2553,102,2708,143"/>
<area shape="rect" id="node14" href="LoopUtils_8cpp.html" title="lib/Transforms/Utils\l/LoopUtils.cpp" alt="" coords="2733,102,2881,143"/>
<area shape="rect" id="node15" href="Transforms_2Utils_2Utils_8cpp.html" title="lib/Transforms/Utils\l/Utils.cpp" alt="" coords="2905,102,3053,143"/>
</map>
</div>
</div>
<p><a href="Analysis_2Utils_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1SliceComputationResult.html">mlir::SliceComputationResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumerates different result statuses of slice computation by <code>computeSliceUnion</code>  <a href="structmlir_1_1SliceComputationResult.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1ComputationSliceState.html">mlir::ComputationSliceState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structmlir_1_1ComputationSliceState.html" title="ComputationSliceState aggregates loop IVs, loop bound AffineMaps and their associated operands for a ...">ComputationSliceState</a> aggregates loop IVs, loop bound AffineMaps and their associated operands for a set of loops within a loop nest (typically the set of loops surrounding a store operation).  <a href="structmlir_1_1ComputationSliceState.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1MemRefRegion.html">mlir::MemRefRegion</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A region of a memref's data space; this is typically constructed by analyzing load/store op's on this memref and the index space of loops surrounding such op's.  <a href="structmlir_1_1MemRefRegion.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacemlir"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html">mlir</a></td></tr>
<tr class="memdesc:namespacemlir"><td class="mdescLeft">&#160;</td><td class="mdescRight">Include the generated interface declarations. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a991e7b35354627941316244640aa4392"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a991e7b35354627941316244640aa4392">mlir::getLoopIVs</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> &amp;op, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; AffineForOp &gt; *loops)</td></tr>
<tr class="memdesc:a991e7b35354627941316244640aa4392"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates 'loops' with IVs of the loops surrounding 'op' ordered from the outermost 'affine.for' operation to the innermost one.  <a href="namespacemlir.html#a991e7b35354627941316244640aa4392">More...</a><br /></td></tr>
<tr class="separator:a991e7b35354627941316244640aa4392"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1ccc3f1298ad67bd387a804aa82fa65"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ad1ccc3f1298ad67bd387a804aa82fa65">mlir::getEnclosingAffineForAndIfOps</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> &amp;op, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&gt; *ops)</td></tr>
<tr class="memdesc:ad1ccc3f1298ad67bd387a804aa82fa65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates 'ops' with IVs of the loops surrounding <code>op</code>, along with <code>affine.if</code> operations interleaved between these loops, ordered from the outermost <code>affine.for</code> or <code>affine.if</code> operation to the innermost one.  <a href="namespacemlir.html#ad1ccc3f1298ad67bd387a804aa82fa65">More...</a><br /></td></tr>
<tr class="separator:ad1ccc3f1298ad67bd387a804aa82fa65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2db02976864d1e32f9f500d9d719d5a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ac2db02976864d1e32f9f500d9d719d5a">mlir::getNestingDepth</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:ac2db02976864d1e32f9f500d9d719d5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the nesting depth of this operation, i.e., the number of loops surrounding this operation.  <a href="namespacemlir.html#ac2db02976864d1e32f9f500d9d719d5a">More...</a><br /></td></tr>
<tr class="separator:ac2db02976864d1e32f9f500d9d719d5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b838aa59fec6e94e6afe4083478f52b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a0b838aa59fec6e94e6afe4083478f52b">mlir::isLoopParallelAndContainsReduction</a> (AffineForOp forOp)</td></tr>
<tr class="memdesc:a0b838aa59fec6e94e6afe4083478f52b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether a loop is a parallel loop and contains a reduction loop.  <a href="namespacemlir.html#a0b838aa59fec6e94e6afe4083478f52b">More...</a><br /></td></tr>
<tr class="separator:a0b838aa59fec6e94e6afe4083478f52b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4052bdb6ce4bde76e5de054805848162"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a4052bdb6ce4bde76e5de054805848162">mlir::getSequentialLoops</a> (AffineForOp forOp, llvm::SmallDenseSet&lt; <a class="el" href="classmlir_1_1Value.html">Value</a>, 8 &gt; *sequentialLoops)</td></tr>
<tr class="memdesc:a4052bdb6ce4bde76e5de054805848162"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns in 'sequentialLoops' all sequential loops in loop nest rooted at 'forOp'.  <a href="namespacemlir.html#a4052bdb6ce4bde76e5de054805848162">More...</a><br /></td></tr>
<tr class="separator:a4052bdb6ce4bde76e5de054805848162"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab92965fea632fd01db2c6e8ae156df70"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ab92965fea632fd01db2c6e8ae156df70">mlir::getComputationSliceState</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *depSourceOp, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *depSinkOp, <a class="el" href="classmlir_1_1FlatAffineValueConstraints.html">FlatAffineValueConstraints</a> *dependenceConstraints, <a class="el" href="classunsigned.html">unsigned</a> loopDepth, bool isBackwardSlice, <a class="el" href="structmlir_1_1ComputationSliceState.html">ComputationSliceState</a> *sliceState)</td></tr>
<tr class="memdesc:ab92965fea632fd01db2c6e8ae156df70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the computation slice loop bounds for one loop nest as affine maps of the other loop nest's IVs and symbols, using 'dependenceConstraints' computed between 'depSourceAccess' and 'depSinkAccess'.  <a href="namespacemlir.html#ab92965fea632fd01db2c6e8ae156df70">More...</a><br /></td></tr>
<tr class="separator:ab92965fea632fd01db2c6e8ae156df70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3fa33c99e241ea5c601599c366c415e"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#af3fa33c99e241ea5c601599c366c415e">mlir::getSliceIterationCount</a> (const llvm::SmallDenseMap&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *, uint64_t, 8 &gt; &amp;sliceTripCountMap)</td></tr>
<tr class="memdesc:af3fa33c99e241ea5c601599c366c415e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of iterations for the <code>slicetripCountMap</code> provided.  <a href="namespacemlir.html#af3fa33c99e241ea5c601599c366c415e">More...</a><br /></td></tr>
<tr class="separator:af3fa33c99e241ea5c601599c366c415e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f66fe15b68ccfe9902bee711b0d1636"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a2f66fe15b68ccfe9902bee711b0d1636">mlir::buildSliceTripCountMap</a> (const <a class="el" href="structmlir_1_1ComputationSliceState.html">ComputationSliceState</a> &amp;slice, llvm::SmallDenseMap&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *, uint64_t, 8 &gt; *tripCountMap)</td></tr>
<tr class="memdesc:a2f66fe15b68ccfe9902bee711b0d1636"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds a map 'tripCountMap' from AffineForOp to constant trip count for loop nest surrounding represented by slice loop bounds in 'slice'.  <a href="namespacemlir.html#a2f66fe15b68ccfe9902bee711b0d1636">More...</a><br /></td></tr>
<tr class="separator:a2f66fe15b68ccfe9902bee711b0d1636"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa53bb2629311efe042f2418b2c4233e0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1SliceComputationResult.html">SliceComputationResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aa53bb2629311efe042f2418b2c4233e0">mlir::computeSliceUnion</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&gt; opsA, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&gt; opsB, <a class="el" href="classunsigned.html">unsigned</a> loopDepth, <a class="el" href="classunsigned.html">unsigned</a> numCommonLoops, bool isBackwardSlice, <a class="el" href="structmlir_1_1ComputationSliceState.html">ComputationSliceState</a> *sliceUnion)</td></tr>
<tr class="memdesc:aa53bb2629311efe042f2418b2c4233e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes in 'sliceUnion' the union of all slice bounds computed at 'loopDepth' between all dependent pairs of ops in 'opsA' and 'opsB', and then verifies if it is valid.  <a href="namespacemlir.html#aa53bb2629311efe042f2418b2c4233e0">More...</a><br /></td></tr>
<tr class="separator:aa53bb2629311efe042f2418b2c4233e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8c76f66345aba4e6cabb250bf7699c1"><td class="memItemLeft" align="right" valign="top">AffineForOp&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aa8c76f66345aba4e6cabb250bf7699c1">mlir::insertBackwardComputationSlice</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *srcOpInst, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *dstOpInst, <a class="el" href="classunsigned.html">unsigned</a> dstLoopDepth, <a class="el" href="structmlir_1_1ComputationSliceState.html">ComputationSliceState</a> *sliceState)</td></tr>
<tr class="memdesc:aa8c76f66345aba4e6cabb250bf7699c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a clone of the computation contained in the loop nest surrounding 'srcOpInst', slices the iteration space of src loop based on slice bounds in 'sliceState', and inserts the computation slice at the beginning of the operation block of the loop at 'dstLoopDepth' in the loop nest surrounding 'dstOpInst'.  <a href="namespacemlir.html#aa8c76f66345aba4e6cabb250bf7699c1">More...</a><br /></td></tr>
<tr class="separator:aa8c76f66345aba4e6cabb250bf7699c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bd0c019a961c60a1fd09225b7dcd3be"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a5bd0c019a961c60a1fd09225b7dcd3be">mlir::getMemRefSizeInBytes</a> (MemRefType memRefType)</td></tr>
<tr class="memdesc:a5bd0c019a961c60a1fd09225b7dcd3be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of memref data in bytes if it's statically shaped, None otherwise.  <a href="namespacemlir.html#a5bd0c019a961c60a1fd09225b7dcd3be">More...</a><br /></td></tr>
<tr class="separator:a5bd0c019a961c60a1fd09225b7dcd3be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdb92b40e131a0a6bd17fc39f1f3e371"><td class="memTemplParams" colspan="2">template&lt;typename LoadOrStoreOpPointer &gt; </td></tr>
<tr class="memitem:afdb92b40e131a0a6bd17fc39f1f3e371"><td class="memTemplItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#afdb92b40e131a0a6bd17fc39f1f3e371">mlir::boundCheckLoadOrStoreOp</a> (LoadOrStoreOpPointer loadOrStoreOp, bool emitError=true)</td></tr>
<tr class="memdesc:afdb92b40e131a0a6bd17fc39f1f3e371"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks a load or store op for an out of bound access; returns failure if the access is out of bounds along any of the dimensions, success otherwise.  <a href="namespacemlir.html#afdb92b40e131a0a6bd17fc39f1f3e371">More...</a><br /></td></tr>
<tr class="separator:afdb92b40e131a0a6bd17fc39f1f3e371"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9ce1eb0663c1448ebc1bbeccc2b6bcf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#af9ce1eb0663c1448ebc1bbeccc2b6bcf">mlir::getNumCommonSurroundingLoops</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> &amp;A, <a class="el" href="classmlir_1_1Operation.html">Operation</a> &amp;B)</td></tr>
<tr class="memdesc:af9ce1eb0663c1448ebc1bbeccc2b6bcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of surrounding loops common to both A and B.  <a href="namespacemlir.html#af9ce1eb0663c1448ebc1bbeccc2b6bcf">More...</a><br /></td></tr>
<tr class="separator:af9ce1eb0663c1448ebc1bbeccc2b6bcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1670cd81ab396ba425cd0063d516b9a9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a1670cd81ab396ba425cd0063d516b9a9">mlir::getMemoryFootprintBytes</a> (AffineForOp forOp, int memorySpace=-1)</td></tr>
<tr class="memdesc:a1670cd81ab396ba425cd0063d516b9a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the memory footprint of all data touched in the specified memory space in bytes; if the memory space is unspecified, considers all memory spaces.  <a href="namespacemlir.html#a1670cd81ab396ba425cd0063d516b9a9">More...</a><br /></td></tr>
<tr class="separator:a1670cd81ab396ba425cd0063d516b9a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cab5a79af53f1bc236af0c5ba5e7b54"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1IntegerSet.html">IntegerSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a1cab5a79af53f1bc236af0c5ba5e7b54">mlir::simplifyIntegerSet</a> (<a class="el" href="classmlir_1_1IntegerSet.html">IntegerSet</a> set)</td></tr>
<tr class="memdesc:a1cab5a79af53f1bc236af0c5ba5e7b54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplify the integer set by simplifying the underlying affine expressions by flattening and some simple inference.  <a href="namespacemlir.html#a1cab5a79af53f1bc236af0c5ba5e7b54">More...</a><br /></td></tr>
<tr class="separator:a1cab5a79af53f1bc236af0c5ba5e7b54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abde4236d0e9455a3983834b085f73224"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#abde4236d0e9455a3983834b085f73224">mlir::getInnermostCommonLoopDepth</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&gt; ops, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; AffineForOp &gt; *surroundingLoops=nullptr)</td></tr>
<tr class="memdesc:abde4236d0e9455a3983834b085f73224"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the innermost common loop depth for the set of operations in 'ops'.  <a href="namespacemlir.html#abde4236d0e9455a3983834b085f73224">More...</a><br /></td></tr>
<tr class="separator:abde4236d0e9455a3983834b085f73224"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Dec 6 2021 20:34:08 for MLIR by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
