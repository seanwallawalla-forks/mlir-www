<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MLIR: lib/Dialect/Linalg/Transforms/Fusion.cpp File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MLIR
   &#160;<span id="projectnumber">14.0.0git</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_97aefd0d527b934f1d99a682da8fe6a9.html">lib</a></li><li class="navelem"><a class="el" href="dir_1a25ec519b6c1121408b67cc33ce3f15.html">Dialect</a></li><li class="navelem"><a class="el" href="dir_8edb792440615361a0811a7329611599.html">Linalg</a></li><li class="navelem"><a class="el" href="dir_7e2f808e77498894ca0efbd745da2201.html">Transforms</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Fusion.cpp File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="lib_2Dialect_2Linalg_2Transforms_2PassDetail_8h_source.html">PassDetail.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="AffineOps_8h_source.html">mlir/Dialect/Affine/IR/AffineOps.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Arithmetic_8h_source.html">mlir/Dialect/Arithmetic/IR/Arithmetic.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="DependenceAnalysis_8h_source.html">mlir/Dialect/Linalg/Analysis/DependenceAnalysis.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="LinalgOps_8h_source.html">mlir/Dialect/Linalg/IR/LinalgOps.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="LinalgTypes_8h_source.html">mlir/Dialect/Linalg/IR/LinalgTypes.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Dialect_2Linalg_2Passes_8h_source.html">mlir/Dialect/Linalg/Passes.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8h_source.html">mlir/Dialect/Linalg/Transforms/Transforms.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Dialect_2Linalg_2Utils_2Utils_8h_source.html">mlir/Dialect/Linalg/Utils/Utils.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="MemRef_8h_source.html">mlir/Dialect/MemRef/IR/MemRef.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Dialect_2Tensor_2IR_2Tensor_8h_source.html">mlir/Dialect/Tensor/IR/Tensor.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="IR_2AffineExpr_8h_source.html">mlir/IR/AffineExpr.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="IR_2AffineMap_8h_source.html">mlir/IR/AffineMap.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Dominance_8h_source.html">mlir/IR/Dominance.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Support_2LLVM_8h_source.html">mlir/Support/LLVM.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="GreedyPatternRewriteDriver_8h_source.html">mlir/Transforms/GreedyPatternRewriteDriver.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="RegionUtils_8h_source.html">mlir/Transforms/RegionUtils.h</a>&quot;</code><br />
<code>#include &quot;llvm/ADT/MapVector.h&quot;</code><br />
<code>#include &quot;llvm/ADT/ScopeExit.h&quot;</code><br />
<code>#include &quot;llvm/Support/CommandLine.h&quot;</code><br />
<code>#include &quot;llvm/Support/Debug.h&quot;</code><br />
<code>#include &lt;set&gt;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for Fusion.cpp:</div>
<div class="dyncontent">
<div class="center"><img src="Fusion_8cpp__incl.png" border="0" usemap="#lib_2Dialect_2Linalg_2Transforms_2Fusion_8cpp" alt=""/></div>
<map name="lib_2Dialect_2Linalg_2Transforms_2Fusion_8cpp" id="lib_2Dialect_2Linalg_2Transforms_2Fusion_8cpp">
<area shape="rect" id="node2" href="lib_2Dialect_2Linalg_2Transforms_2PassDetail_8h.html" title="PassDetail.h" alt="" coords="2905,102,3007,129"/>
<area shape="rect" id="node3" href="AffineOps_8h.html" title="mlir/Dialect/Affine\l/IR/AffineOps.h" alt="" coords="2071,631,2211,672"/>
<area shape="rect" id="node5" href="IR_2AffineMap_8h.html" title="mlir/IR/AffineMap.h" alt="" coords="333,988,480,1015"/>
<area shape="rect" id="node6" href="IR_2AffineExpr_8h.html" title="mlir/IR/AffineExpr.h" alt="" coords="272,1063,419,1089"/>
<area shape="rect" id="node7" href="Support_2LLVM_8h.html" title="mlir/Support/LLVM.h" alt="" coords="409,1137,559,1164"/>
<area shape="rect" id="node12" href="Arithmetic_8h.html" title="mlir/Dialect/Arithmetic\l/IR/Arithmetic.h" alt="" coords="2693,809,2864,851"/>
<area shape="rect" id="node27" href="DependenceAnalysis_8h.html" title="mlir/Dialect/Linalg\l/Analysis/DependenceAnalysis.h" alt="" coords="1594,363,1827,404"/>
<area shape="rect" id="node28" href="LinalgOps_8h.html" title="mlir/Dialect/Linalg\l/IR/LinalgOps.h" alt="" coords="1321,452,1463,493"/>
<area shape="rect" id="node29" href="LinalgTypes_8h.html" title="mlir/Dialect/Linalg\l/IR/LinalgTypes.h" alt="" coords="2376,541,2517,583"/>
<area shape="rect" id="node30" href="MemRef_8h.html" title="mlir/Dialect/MemRef\l/IR/MemRef.h" alt="" coords="2405,720,2560,761"/>
<area shape="rect" id="node33" href="Dialect_2Tensor_2IR_2Tensor_8h.html" title="mlir/Dialect/Tensor\l/IR/Tensor.h" alt="" coords="2584,720,2728,761"/>
<area shape="rect" id="node40" href="Dialect_2Linalg_2Passes_8h.html" title="mlir/Dialect/Linalg\l/Passes.h" alt="" coords="2637,95,2779,136"/>
<area shape="rect" id="node41" href="Dialect_2Linalg_2Transforms_2Transforms_8h.html" title="mlir/Dialect/Linalg\l/Transforms/Transforms.h" alt="" coords="2427,184,2613,225"/>
<area shape="rect" id="node42" href="Dialect_2Linalg_2Utils_2Utils_8h.html" title="mlir/Dialect/Linalg\l/Utils/Utils.h" alt="" coords="2059,273,2200,315"/>
<area shape="rect" id="node44" href="Dominance_8h.html" title="mlir/IR/Dominance.h" alt="" coords="3133,102,3288,129"/>
<area shape="rect" id="node45" href="GreedyPatternRewriteDriver_8h.html" title="mlir/Transforms/GreedyPattern\lRewriteDriver.h" alt="" coords="3312,95,3533,136"/>
<area shape="rect" id="node46" href="RegionUtils_8h.html" title="mlir/Transforms/RegionUtils.h" alt="" coords="3558,102,3773,129"/>
<area shape="rect" id="node10" href="IR_2Dialect_8h.html" title="mlir/IR/Dialect.h" alt="" coords="3434,1063,3561,1089"/>
<area shape="rect" id="node25" href="include_2mlir_2Pass_2Pass_8h.html" title="mlir/Pass/Pass.h" alt="" coords="2905,191,3031,218"/>
<area shape="rect" id="node4" href="AffineMemoryOpInterfaces_8h.html" title="mlir/Dialect/Affine\l/IR/AffineMemoryOpInterfaces.h" alt="" coords="784,899,1013,940"/>
<area shape="rect" id="node11" href="Ops_8h.html" title="mlir/Dialect/StandardOps\l/IR/Ops.h" alt="" coords="1667,720,1853,761"/>
<area shape="rect" id="node22" href="LoopLikeInterface_8h.html" title="mlir/Interfaces/LoopLike\lInterface.h" alt="" coords="2237,809,2416,851"/>
<area shape="rect" id="node8" href="IR_2BuiltinTypes_8h.html" title="mlir/IR/BuiltinTypes.h" alt="" coords="1056,988,1216,1015"/>
<area shape="rect" id="node9" href="OpDefinition_8h.html" title="mlir/IR/OpDefinition.h" alt="" coords="1956,988,2119,1015"/>
<area shape="rect" id="node13" href="OpImplementation_8h.html" title="mlir/IR/OpImplementation.h" alt="" coords="1867,906,2069,933"/>
<area shape="rect" id="node14" href="CastInterfaces_8h.html" title="mlir/Interfaces/CastInterfaces.h" alt="" coords="2405,906,2632,933"/>
<area shape="rect" id="node15" href="SideEffectInterfaces_8h.html" title="mlir/Interfaces/SideEffect\lInterfaces.h" alt="" coords="2195,899,2381,940"/>
<area shape="rect" id="node16" href="VectorInterfaces_8h.html" title="mlir/Interfaces/VectorInterfaces.h" alt="" coords="1603,906,1842,933"/>
<area shape="rect" id="node20" href="Builders_8h.html" title="mlir/IR/Builders.h" alt="" coords="1393,906,1527,933"/>
<area shape="rect" id="node21" href="InferTypeOpInterface_8h.html" title="mlir/Interfaces/InferType\lOpInterface.h" alt="" coords="1360,809,1541,851"/>
<area shape="rect" id="node31" href="ReshapeOpsUtils_8h.html" title="mlir/Dialect/Utils\l/ReshapeOpsUtils.h" alt="" coords="1187,809,1335,851"/>
<area shape="rect" id="node32" href="CopyOpInterface_8h.html" title="mlir/Interfaces/CopyOpInterface.h" alt="" coords="1869,817,2112,843"/>
<area shape="rect" id="node34" href="Types_8h.html" title="mlir/IR/Types.h" alt="" coords="1929,638,2047,665"/>
<area shape="rect" id="node35" href="StructuredOpsUtils_8h.html" title="mlir/Dialect/Utils\l/StructuredOpsUtils.h" alt="" coords="144,899,304,940"/>
<area shape="rect" id="node36" href="BlockAndValueMapping_8h.html" title="mlir/IR/BlockAndValueMapping.h" alt="" coords="1053,549,1286,575"/>
<area shape="rect" id="node37" href="BuiltinDialect_8h.html" title="mlir/IR/BuiltinDialect.h" alt="" coords="481,638,650,665"/>
<area shape="rect" id="node38" href="TypeUtilities_8h.html" title="mlir/IR/TypeUtilities.h" alt="" coords="1311,549,1473,575"/>
<area shape="rect" id="node39" href="TilingInterface_8h.html" title="mlir/Interfaces/TilingInterface.h" alt="" coords="683,817,909,843"/>
</map>
</div>
</div>
<p><a href="Fusion_8cpp_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structShapeDimension.html">ShapeDimension</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements a simple high-level fusion pass on linalg structured operations.  <a href="structShapeDimension.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ad78e062f62e0d6e453941fb4ca843e4d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Fusion_8cpp.html#ad78e062f62e0d6e453941fb4ca843e4d">DEBUG_TYPE</a>&#160;&#160;&#160;&quot;linalg-fusion&quot;</td></tr>
<tr class="separator:ad78e062f62e0d6e453941fb4ca843e4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a8bda7c81ef2c40cf52452d003aa70e6a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structShapeDimension.html">ShapeDimension</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Fusion_8cpp.html#a8bda7c81ef2c40cf52452d003aa70e6a">getShapeDefiningLoopRange</a> (LinalgOp op, <a class="el" href="classunsigned.html">unsigned</a> loopDepth, bool fromSubViewOpOnly=false)</td></tr>
<tr class="separator:a8bda7c81ef2c40cf52452d003aa70e6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97be70d6c7f22d016d72abea8ffec8a6"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Fusion_8cpp.html#a97be70d6c7f22d016d72abea8ffec8a6">getTiledOperands</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, LinalgOp producer)</td></tr>
<tr class="separator:a97be70d6c7f22d016d72abea8ffec8a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ef2b2f86e222163675b7d2d3cc9a977"><td class="memItemLeft" align="right" valign="top">static LinalgOp&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Fusion_8cpp.html#a0ef2b2f86e222163675b7d2d3cc9a977">fuse</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, LinalgOp producer, const <a class="el" href="namespacemlir.html#ad7f731697783a754f6f0e3821d1264b2">DenseMap</a>&lt; <a class="el" href="classunsigned.html">unsigned</a>, <a class="el" href="structmlir_1_1Range.html">Range</a> &gt; &amp;fusedLoopsAndRanges)</td></tr>
<tr class="memdesc:a0ef2b2f86e222163675b7d2d3cc9a977"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fuses the producer by cloning the <code>producer</code>.  <a href="#a0ef2b2f86e222163675b7d2d3cc9a977">More...</a><br /></td></tr>
<tr class="separator:a0ef2b2f86e222163675b7d2d3cc9a977"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9bf9c5713729b719d28d13b4ed76232"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structmlir_1_1Range.html">Range</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Fusion_8cpp.html#ad9bf9c5713729b719d28d13b4ed76232">getRangeFromOperandShape</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Value.html">Value</a> shapedOperand, <a class="el" href="classunsigned.html">unsigned</a> dim)</td></tr>
<tr class="memdesc:ad9bf9c5713729b719d28d13b4ed76232"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the loop range for a dimension <code>dim</code> based on the <code>shapedOperand</code>.  <a href="#ad9bf9c5713729b719d28d13b4ed76232">More...</a><br /></td></tr>
<tr class="separator:ad9bf9c5713729b719d28d13b4ed76232"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f048e5bc1dd7fd8d00f76c7c43666ef"><td class="memItemLeft" align="right" valign="top">static LinalgOp&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Fusion_8cpp.html#a7f048e5bc1dd7fd8d00f76c7c43666ef">fuse</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, LinalgOp producerOp, <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> producerMap, <a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> &amp;consumerOpOperand)</td></tr>
<tr class="memdesc:a7f048e5bc1dd7fd8d00f76c7c43666ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fuses the producer into the loop immediately enclosing the consumer.  <a href="#a7f048e5bc1dd7fd8d00f76c7c43666ef">More...</a><br /></td></tr>
<tr class="separator:a7f048e5bc1dd7fd8d00f76c7c43666ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73e2f0896470da6a34a6a40bfe55e957"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Fusion_8cpp.html#a73e2f0896470da6a34a6a40bfe55e957">isStructurallyFusableProducer</a> (LinalgOp producer, <a class="el" href="classmlir_1_1Value.html">Value</a> consumedView, LinalgOp consumer)</td></tr>
<tr class="separator:a73e2f0896470da6a34a6a40bfe55e957"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a971363b74d384512d7f70f2b7c45b3b1"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; <a class="el" href="structmlir_1_1linalg_1_1LinalgDependenceGraph_1_1LinalgDependenceGraphElem.html">LinalgDependenceGraph::LinalgDependenceGraphElem</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Fusion_8cpp.html#a971363b74d384512d7f70f2b7c45b3b1">findFusableProducer</a> (<a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> &amp;consumerOpOperand, const <a class="el" href="classmlir_1_1linalg_1_1LinalgDependenceGraph.html">LinalgDependenceGraph</a> &amp;dependenceGraph)</td></tr>
<tr class="memdesc:a971363b74d384512d7f70f2b7c45b3b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">For <code>consumer</code> with buffer semantics, find the Linalg operation on buffers that is the last writer of <code>consumerOpOperand</code>.  <a href="#a971363b74d384512d7f70f2b7c45b3b1">More...</a><br /></td></tr>
<tr class="separator:a971363b74d384512d7f70f2b7c45b3b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a85e8820f83776c7b9d851686c3d820"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Fusion_8cpp.html#a2a85e8820f83776c7b9d851686c3d820">getProducerOfTensor</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> tensor, <a class="el" href="classmlir_1_1OpResult.html">OpResult</a> &amp;opResult)</td></tr>
<tr class="memdesc:a2a85e8820f83776c7b9d851686c3d820"><td class="mdescLeft">&#160;</td><td class="mdescRight">Walk back use-def chain through scf::For yields.  <a href="#a2a85e8820f83776c7b9d851686c3d820">More...</a><br /></td></tr>
<tr class="separator:a2a85e8820f83776c7b9d851686c3d820"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dca7e29a8de7e3d6608c35f2c50183f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Fusion_8cpp.html#a9dca7e29a8de7e3d6608c35f2c50183f">pruneReductionDimsFromMap</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt; iteratorTypes, <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> map)</td></tr>
<tr class="memdesc:a9dca7e29a8de7e3d6608c35f2c50183f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prune all dimensions that are of reduction iterator type from <code>map</code>.  <a href="#a9dca7e29a8de7e3d6608c35f2c50183f">More...</a><br /></td></tr>
<tr class="separator:a9dca7e29a8de7e3d6608c35f2c50183f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a669a8be6bbb90d78a3ca28bbf55fbf96"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Fusion_8cpp.html#a669a8be6bbb90d78a3ca28bbf55fbf96">getConsumerLoopToProducerLoopMap</a> (<a class="el" href="structmlir_1_1linalg_1_1LinalgDependenceGraph_1_1LinalgDependenceGraphElem.html">LinalgDependenceGraph::LinalgDependenceGraphElem</a> dependence)</td></tr>
<tr class="memdesc:a669a8be6bbb90d78a3ca28bbf55fbf96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the mapping from iterations in the consumer that write to the same location as the iterations in the producer.  <a href="#a669a8be6bbb90d78a3ca28bbf55fbf96">More...</a><br /></td></tr>
<tr class="separator:a669a8be6bbb90d78a3ca28bbf55fbf96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33dcf4467f99f363f937474c3c3a9457"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Fusion_8cpp.html#a33dcf4467f99f363f937474c3c3a9457">doesTransposeAccess</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> map, const std::set&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt; &amp;fusableLoops)</td></tr>
<tr class="memdesc:a33dcf4467f99f363f937474c3c3a9457"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a projected permutation <code>map</code>, returns true if the map changes the order in which the fused loop dimension appear.  <a href="#a33dcf4467f99f363f937474c3c3a9457">More...</a><br /></td></tr>
<tr class="separator:a33dcf4467f99f363f937474c3c3a9457"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91395f43bdb1d8532fc542fe70664577"><td class="memItemLeft" align="right" valign="top">static std::set&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Fusion_8cpp.html#a91395f43bdb1d8532fc542fe70664577">collectFusableLoops</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; LinalgOp &gt; ops, const <a class="el" href="namespacemlir_1_1linalg.html#aed2c8e52c82709202bade005c0609f77">FusableOpDependencesTy</a> &amp;fusableDependences)</td></tr>
<tr class="memdesc:a91395f43bdb1d8532fc542fe70664577"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the positions of the loop in <code>op</code> that can be tiled based on the operations that are to be fused with it.  <a href="#a91395f43bdb1d8532fc542fe70664577">More...</a><br /></td></tr>
<tr class="separator:a91395f43bdb1d8532fc542fe70664577"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad88f424b81362cb5742883116fda9237"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; <a class="el" href="structmlir_1_1linalg_1_1TiledLinalgOp.html">TiledLinalgOp</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Fusion_8cpp.html#ad88f424b81362cb5742883116fda9237">tileRootOperation</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, LinalgOp op, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; tileSizeVector, const <a class="el" href="structmlir_1_1linalg_1_1LinalgTilingOptions.html">LinalgTilingOptions</a> &amp;<a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>, const std::set&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt; &amp;fusedLoops)</td></tr>
<tr class="memdesc:ad88f424b81362cb5742883116fda9237"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tile the fused loops in the root operation, by setting the tile sizes for all other loops to zero (those will be tiled later).  <a href="#ad88f424b81362cb5742883116fda9237">More...</a><br /></td></tr>
<tr class="separator:ad88f424b81362cb5742883116fda9237"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0088b99e81de0689e96274cadcb2184"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; LinalgOp, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Fusion_8cpp.html#ab0088b99e81de0689e96274cadcb2184">fuseOperations</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, LinalgOp rootOp, <a class="el" href="structmlir_1_1linalg_1_1TiledLinalgOp.html">TiledLinalgOp</a> tiledLinalgOp, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; LinalgOp &gt; fusionCandidates, const <a class="el" href="namespacemlir_1_1linalg.html#aed2c8e52c82709202bade005c0609f77">FusableOpDependencesTy</a> &amp;fusableDependences, const std::set&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt; &amp;fusedLoops)</td></tr>
<tr class="memdesc:ab0088b99e81de0689e96274cadcb2184"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fuse the operations in <code>fusionCandidates</code> with <code>tiledOp</code>.  <a href="#ab0088b99e81de0689e96274cadcb2184">More...</a><br /></td></tr>
<tr class="separator:ab0088b99e81de0689e96274cadcb2184"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1ccfeffa295aff35d8ff682e8639024"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; <a class="el" href="structmlir_1_1linalg_1_1TiledAndFusedLinalgOps.html">TiledAndFusedLinalgOps</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Fusion_8cpp.html#af1ccfeffa295aff35d8ff682e8639024">tileAndFuseLinalgOpsImpl</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; LinalgOp &gt; ops, const <a class="el" href="classmlir_1_1linalg_1_1LinalgDependenceGraph.html">LinalgDependenceGraph</a> &amp;dependenceGraph, const <a class="el" href="structmlir_1_1linalg_1_1LinalgTilingOptions.html">LinalgTilingOptions</a> &amp;tilingOptions)</td></tr>
<tr class="separator:af1ccfeffa295aff35d8ff682e8639024"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ad78e062f62e0d6e453941fb4ca843e4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad78e062f62e0d6e453941fb4ca843e4d">&#9670;&nbsp;</a></span>DEBUG_TYPE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DEBUG_TYPE&#160;&#160;&#160;&quot;linalg-fusion&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Fusion_8cpp_source.html#l00037">37</a> of file <a class="el" href="Fusion_8cpp_source.html">Fusion.cpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a91395f43bdb1d8532fc542fe70664577"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91395f43bdb1d8532fc542fe70664577">&#9670;&nbsp;</a></span>collectFusableLoops()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::set&lt;<a class="el" href="classunsigned.html">unsigned</a>&gt; collectFusableLoops </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; LinalgOp &gt;&#160;</td>
          <td class="paramname"><em>ops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacemlir_1_1linalg.html#aed2c8e52c82709202bade005c0609f77">FusableOpDependencesTy</a> &amp;&#160;</td>
          <td class="paramname"><em>fusableDependences</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the positions of the loop in <code>op</code> that can be tiled based on the operations that are to be fused with it. </p>
<p>For example, in a</p>
<p>linalg.matmul ins(a, b : ...) outs(c : ...)</p>
<p>if the producer of a needs to be fused with this op, only the <code>i</code> loop of the matmul can be tiled while fusing. If producer of a, and b are to be fused, then no loops can be tiled while fusing. The conditions used are:</p><ol type="1">
<li>Only parallel loops can be used for tile + fuse. Find the number of common outer parallel loops between the op and its producers being fused.</li>
<li>Of the parallel loops only some can be fused. Only those loops can be fused such where the fusable loops iteration space only touches one tile of the fused operation. This is because the producer (which is writing the fused subview) has update semantics.</li>
</ol>
<p>Since an inverse computation is needed, we need to consider the projection of the producerIndexMap w.r.t the parallel loops. The actual fusable loops are the dimensions of the consumerLoopToProducerLoop map that correspond to parallel loops and appear in the result of the map</p>
<p>Example 1: linalg.fill(cst, c) linalg.matmul ins(a, b) outs(c) Number of parallel loops : 2 producerIndexMap = affine_map&lt;(i, j) -&gt;(i , j)&gt; consumerIndexMap = affine_map&lt;(i, j, k) -&gt; (i, j)&gt; consumerLoopToProducerLoop = affine_map&lt;(i, j, k) -&gt; (i, j)&gt; Fused dimensions : i, j</p>
<p>Example 2: linalg.matmul ins(a, b) outs(c) linalg.generic {indexing_maps = [affine_map&lt;(i, j) -&gt; (j, i)&gt;, ... iterator_types = ["parallel", "parallel"]} ins(c) ...</p>
<p>Number of parallel loops = 2: producerIndexMap (projected to parallel loops) = affine_map&lt;(i, j) -&gt; (i, j)&gt; consumerLoopToProducerLoop2 = affine_map&lt;(i, j) -&gt; (j, i)&gt; Fused dimensions : i, j</p>
<p>Example 3: linalg.copy(s, b) linalg.matmul ins(a, b) outs(c)</p>
<p>Number of parallel loops = 2 produceIndexMap : affine_map&lt;(i, j) -&gt; (i, j)&gt; consumerLoopToProduceLoops = affine_map&lt;(i, j, k) -&gt; (k, j)&gt; submap with only parallel loops = affine_map&lt;(i, j) -&gt; (j)&gt; Fused dimensions : j </p>

<p class="definition">Definition at line <a class="el" href="Fusion_8cpp_source.html#l00652">652</a> of file <a class="el" href="Fusion_8cpp_source.html">Fusion.cpp</a>.</p>

<p class="reference">References <a class="el" href="Attributes_8h_source.html#l00126">mlir::Attribute::cast()</a>, <a class="el" href="Fusion_8cpp_source.html#l00582">doesTransposeAccess()</a>, <a class="el" href="Fusion_8cpp_source.html#l00540">getConsumerLoopToProducerLoopMap()</a>, <a class="el" href="StructuredOpsUtils_8h_source.html#l00080">mlir::getParallelIteratorTypeName()</a>, and <a class="el" href="PolynomialApproximation_8cpp_source.html#l00180">min()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Fusion_8cpp_source.html#l00875">tileAndFuseLinalgOpsImpl()</a>.</p>

</div>
</div>
<a id="a33dcf4467f99f363f937474c3c3a9457"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33dcf4467f99f363f937474c3c3a9457">&#9670;&nbsp;</a></span>doesTransposeAccess()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool doesTransposeAccess </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>fusableLoops</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a projected permutation <code>map</code>, returns true if the map changes the order in which the fused loop dimension appear. </p>

<p class="definition">Definition at line <a class="el" href="Fusion_8cpp_source.html#l00582">582</a> of file <a class="el" href="Fusion_8cpp_source.html">Fusion.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineMap_8cpp_source.html#l00311">mlir::AffineMap::getResults()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Fusion_8cpp_source.html#l00652">collectFusableLoops()</a>.</p>

</div>
</div>
<a id="a971363b74d384512d7f70f2b7c45b3b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a971363b74d384512d7f70f2b7c45b3b1">&#9670;&nbsp;</a></span>findFusableProducer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt;<a class="el" href="structmlir_1_1linalg_1_1LinalgDependenceGraph_1_1LinalgDependenceGraphElem.html">LinalgDependenceGraph::LinalgDependenceGraphElem</a>&gt; findFusableProducer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> &amp;&#160;</td>
          <td class="paramname"><em>consumerOpOperand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1linalg_1_1LinalgDependenceGraph.html">LinalgDependenceGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>dependenceGraph</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For <code>consumer</code> with buffer semantics, find the Linalg operation on buffers that is the last writer of <code>consumerOpOperand</code>. </p>
<p>For now the fusable dependence is returned as an instance of the <code>dependenceGraph</code>. </p>

<p class="definition">Definition at line <a class="el" href="Fusion_8cpp_source.html#l00335">335</a> of file <a class="el" href="Fusion_8cpp_source.html">Fusion.cpp</a>.</p>

<p class="reference">References <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>, <a class="el" href="UseDefLists_8h_source.html#l00133">mlir::IROperand&lt; DerivedT, IRValueT &gt;::get()</a>, <a class="el" href="DependenceAnalysis_8cpp_source.html#l00156">mlir::linalg::LinalgDependenceGraph::getDependencesInto()</a>, <a class="el" href="DependenceAnalysis_8cpp_source.html#l00080">mlir::linalg::LinalgDependenceGraph::getDependenceTypeStr()</a>, <a class="el" href="Value_8cpp_source.html#l00212">mlir::OpOperand::getOperandNumber()</a>, <a class="el" href="UseDefLists_8h_source.html#l00037">mlir::detail::IROperandBase::getOwner()</a>, and <a class="el" href="Fusion_8cpp_source.html#l00311">mlir::linalg::isFusableInto()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Fusion_8cpp_source.html#l00722">mlir::linalg::findAllFusableDependences()</a>, and <a class="el" href="Fusion_8cpp_source.html#l00393">mlir::linalg::fuseProducerOfBuffer()</a>.</p>

</div>
</div>
<a id="a0ef2b2f86e222163675b7d2d3cc9a977"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ef2b2f86e222163675b7d2d3cc9a977">&#9670;&nbsp;</a></span>fuse() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static LinalgOp fuse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LinalgOp&#160;</td>
          <td class="paramname"><em>producer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacemlir.html#ad7f731697783a754f6f0e3821d1264b2">DenseMap</a>&lt; <a class="el" href="classunsigned.html">unsigned</a>, <a class="el" href="structmlir_1_1Range.html">Range</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>fusedLoopsAndRanges</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fuses the producer by cloning the <code>producer</code>. </p>
<p>The <code>fusedLoopsAndRanges</code> provides the loop range information for the fused loops. The rest are obtained from the producer itself, since they are not tiled + fused. </p>

<p class="definition">Definition at line <a class="el" href="Fusion_8cpp_source.html#l00172">172</a> of file <a class="el" href="Fusion_8cpp_source.html">Fusion.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00903">mlir::linalg::addTileLoopIvsToIndexOpResults()</a>, <a class="el" href="Operation_8cpp_source.html#l00564">mlir::Operation::clone()</a>, <a class="el" href="Builders_8h_source.html#l00424">mlir::OpBuilder::create()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00160">mlir::linalg::createOrFoldDimOp()</a>, <a class="el" href="Fusion_8cpp_source.html#l00071">getShapeDefiningLoopRange()</a>, <a class="el" href="Fusion_8cpp_source.html#l00125">getTiledOperands()</a>, <a class="el" href="IR_2BuiltinTypes_8h_source.html#l00073">mlir::ShapedType::kDynamicSize</a>, <a class="el" href="IR_2BuiltinTypes_8h_source.html#l00074">mlir::ShapedType::kDynamicStrideOrOffset</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00858">mlir::linalg::makeTiledShapes()</a>, and <a class="el" href="ViewLikeInterface_8h_source.html#l00027">mlir::Range::offset</a>.</p>

<p class="reference">Referenced by <a class="el" href="Fusion_8cpp_source.html#l00251">fuse()</a>, <a class="el" href="Fusion_8cpp_source.html#l00798">fuseOperations()</a>, <a class="el" href="Fusion_8cpp_source.html#l00393">mlir::linalg::fuseProducerOfBuffer()</a>, and <a class="el" href="Fusion_8cpp_source.html#l00475">mlir::linalg::fuseProducerOfTensor()</a>.</p>

</div>
</div>
<a id="a7f048e5bc1dd7fd8d00f76c7c43666ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f048e5bc1dd7fd8d00f76c7c43666ef">&#9670;&nbsp;</a></span>fuse() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static LinalgOp fuse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LinalgOp&#160;</td>
          <td class="paramname"><em>producerOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>producerMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> &amp;&#160;</td>
          <td class="paramname"><em>consumerOpOperand</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fuses the producer into the loop immediately enclosing the consumer. </p>
<p>This is achieved by "recomputing" the producer at the time it is needed just before the consumer. </p>

<p class="definition">Definition at line <a class="el" href="Fusion_8cpp_source.html#l00251">251</a> of file <a class="el" href="Fusion_8cpp_source.html">Fusion.cpp</a>.</p>

<p class="reference">References <a class="el" href="Value_8h_source.html#l00109">mlir::Value::cast()</a>, <a class="el" href="Matchers_8h_source.html#l00206">mlir::detail::enumerate()</a>, <a class="el" href="Fusion_8cpp_source.html#l00172">fuse()</a>, <a class="el" href="UseDefLists_8h_source.html#l00133">mlir::IROperand&lt; DerivedT, IRValueT &gt;::get()</a>, <a class="el" href="Operation_8h_source.html#l00106">mlir::Operation::getLoc()</a>, <a class="el" href="UseDefLists_8h_source.html#l00037">mlir::detail::IROperandBase::getOwner()</a>, <a class="el" href="Fusion_8cpp_source.html#l00238">getRangeFromOperandShape()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00311">mlir::AffineMap::getResults()</a>.</p>

</div>
</div>
<a id="ab0088b99e81de0689e96274cadcb2184"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0088b99e81de0689e96274cadcb2184">&#9670;&nbsp;</a></span>fuseOperations()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;LinalgOp, 1&gt; fuseOperations </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LinalgOp&#160;</td>
          <td class="paramname"><em>rootOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1linalg_1_1TiledLinalgOp.html">TiledLinalgOp</a>&#160;</td>
          <td class="paramname"><em>tiledLinalgOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; LinalgOp &gt;&#160;</td>
          <td class="paramname"><em>fusionCandidates</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacemlir_1_1linalg.html#aed2c8e52c82709202bade005c0609f77">FusableOpDependencesTy</a> &amp;&#160;</td>
          <td class="paramname"><em>fusableDependences</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>fusedLoops</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fuse the operations in <code>fusionCandidates</code> with <code>tiledOp</code>. </p>
<p>Latter is expected to be a tiled operation such that it is valid to fuse all operations in <code>fusionCandidates</code>, i.e. move the operation within the inter-tile loops of <code>tiledOp</code>. </p>

<p class="definition">Definition at line <a class="el" href="Fusion_8cpp_source.html#l00798">798</a> of file <a class="el" href="Fusion_8cpp_source.html">Fusion.cpp</a>.</p>

<p class="reference">References <a class="el" href="Fusion_8cpp_source.html#l00062">ShapeDimension::dimension</a>, <a class="el" href="Matchers_8h_source.html#l00206">mlir::detail::enumerate()</a>, <a class="el" href="Fusion_8cpp_source.html#l00172">fuse()</a>, <a class="el" href="Fusion_8cpp_source.html#l00238">getRangeFromOperandShape()</a>, <a class="el" href="Fusion_8cpp_source.html#l00071">getShapeDefiningLoopRange()</a>, <a class="el" href="Value_8h_source.html#l00119">mlir::Value::getType()</a>, <a class="el" href="Types_8h_source.html#l00234">mlir::Type::isa()</a>, <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l00164">mlir::linalg::TiledLinalgOp::loops</a>, <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l00163">mlir::linalg::TiledLinalgOp::op</a>, <a class="el" href="Operator_8cpp_source.html#l00293">resultIndex()</a>, <a class="el" href="Builders_8h_source.html#l00331">mlir::OpBuilder::setInsertionPoint()</a>, and <a class="el" href="Fusion_8cpp_source.html#l00061">ShapeDimension::shape</a>.</p>

<p class="reference">Referenced by <a class="el" href="Fusion_8cpp_source.html#l00875">tileAndFuseLinalgOpsImpl()</a>.</p>

</div>
</div>
<a id="a669a8be6bbb90d78a3ca28bbf55fbf96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a669a8be6bbb90d78a3ca28bbf55fbf96">&#9670;&nbsp;</a></span>getConsumerLoopToProducerLoopMap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt;<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&gt; getConsumerLoopToProducerLoopMap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmlir_1_1linalg_1_1LinalgDependenceGraph_1_1LinalgDependenceGraphElem.html">LinalgDependenceGraph::LinalgDependenceGraphElem</a>&#160;</td>
          <td class="paramname"><em>dependence</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the mapping from iterations in the consumer that write to the same location as the iterations in the producer. </p>
<p>To do so use</p><ul>
<li>indexing map of the fused view in the consumer : consumerIndexMap</li>
<li>indexing map of the fused view in the producer : producerIndexMap consumerLoopToProducerLoop = inverse(producerIndexMap).compose(consumerIndexMap) </li>
</ul>

<p class="definition">Definition at line <a class="el" href="Fusion_8cpp_source.html#l00540">540</a> of file <a class="el" href="Fusion_8cpp_source.html">Fusion.cpp</a>.</p>

<p class="reference">References <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>, <a class="el" href="DependenceAnalysis_8h_source.html#l00103">mlir::linalg::LinalgDependenceGraph::LinalgDependenceGraphElem::getDependentOp()</a>, <a class="el" href="DependenceAnalysis_8h_source.html#l00140">mlir::linalg::LinalgDependenceGraph::LinalgDependenceGraphElem::getDependentOpViewIndexingMap()</a>, <a class="el" href="DependenceAnalysis_8h_source.html#l00146">mlir::linalg::LinalgDependenceGraph::LinalgDependenceGraphElem::getIndexingOpViewIndexingMap()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00302">mlir::AffineMap::getNumResults()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00673">mlir::inversePermutation()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00513">mlir::AffineMap::isPermutation()</a>, <a class="el" href="AsmPrinter_8cpp_source.html#l02771">mlir::AffineMap::print()</a>, and <a class="el" href="Fusion_8cpp_source.html#l00524">pruneReductionDimsFromMap()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Fusion_8cpp_source.html#l00652">collectFusableLoops()</a>.</p>

</div>
</div>
<a id="a2a85e8820f83776c7b9d851686c3d820"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a85e8820f83776c7b9d851686c3d820">&#9670;&nbsp;</a></span>getProducerOfTensor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classvoid.html">void</a> getProducerOfTensor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>tensor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpResult.html">OpResult</a> &amp;&#160;</td>
          <td class="paramname"><em>opResult</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Walk back use-def chain through scf::For yields. </p>
<p>Sets <code>producer</code> and <code>outputIndex</code> if it finds a producer LinalgOp </p>

<p class="definition">Definition at line <a class="el" href="Fusion_8cpp_source.html#l00438">438</a> of file <a class="el" href="Fusion_8cpp_source.html">Fusion.cpp</a>.</p>

<p class="reference">References <a class="el" href="Value_8h_source.html#l00109">mlir::Value::cast()</a>, <a class="el" href="Value_8h_source.html#l00101">mlir::Value::dyn_cast()</a>, <a class="el" href="Value_8cpp_source.html#l00020">mlir::Value::getDefiningOp()</a>, <a class="el" href="Value_8h_source.html#l00119">mlir::Value::getType()</a>, and <a class="el" href="Types_8h_source.html#l00234">mlir::Type::isa()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Fusion_8cpp_source.html#l00463">mlir::linalg::fuseProducerOfTensor()</a>.</p>

</div>
</div>
<a id="ad9bf9c5713729b719d28d13b4ed76232"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9bf9c5713729b719d28d13b4ed76232">&#9670;&nbsp;</a></span>getRangeFromOperandShape()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structmlir_1_1Range.html">Range</a> getRangeFromOperandShape </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>shapedOperand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>dim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the loop range for a dimension <code>dim</code> based on the <code>shapedOperand</code>. </p>
<p>It is expected to be defined by a subview op or an extract_slice op. </p>

<p class="definition">Definition at line <a class="el" href="Fusion_8cpp_source.html#l00238">238</a> of file <a class="el" href="Fusion_8cpp_source.html">Fusion.cpp</a>.</p>

<p class="reference">References <a class="el" href="Value_8cpp_source.html#l00020">mlir::Value::getDefiningOp()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Fusion_8cpp_source.html#l00251">fuse()</a>, and <a class="el" href="Fusion_8cpp_source.html#l00798">fuseOperations()</a>.</p>

</div>
</div>
<a id="a8bda7c81ef2c40cf52452d003aa70e6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bda7c81ef2c40cf52452d003aa70e6a">&#9670;&nbsp;</a></span>getShapeDefiningLoopRange()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structShapeDimension.html">ShapeDimension</a> getShapeDefiningLoopRange </td>
          <td>(</td>
          <td class="paramtype">LinalgOp&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>loopDepth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fromSubViewOpOnly</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Fusion_8cpp_source.html#l00071">71</a> of file <a class="el" href="Fusion_8cpp_source.html">Fusion.cpp</a>.</p>

<p class="reference">References <a class="el" href="Matchers_8h_source.html#l00206">mlir::detail::enumerate()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00302">mlir::AffineMap::getNumResults()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00311">mlir::AffineMap::getResults()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Fusion_8cpp_source.html#l00172">fuse()</a>, and <a class="el" href="Fusion_8cpp_source.html#l00798">fuseOperations()</a>.</p>

</div>
</div>
<a id="a97be70d6c7f22d016d72abea8ffec8a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97be70d6c7f22d016d72abea8ffec8a6">&#9670;&nbsp;</a></span>getTiledOperands()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;<a class="el" href="classmlir_1_1Value.html">Value</a>&gt; getTiledOperands </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LinalgOp&#160;</td>
          <td class="paramname"><em>producer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Fusion_8cpp_source.html#l00125">125</a> of file <a class="el" href="Fusion_8cpp_source.html">Fusion.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8h_source.html#l00381">mlir::OpBuilder::getBlock()</a>, <a class="el" href="Value_8cpp_source.html#l00212">mlir::OpOperand::getOperandNumber()</a>, and <a class="el" href="Block_8cpp_source.html#l00030">mlir::Block::getParentOp()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Fusion_8cpp_source.html#l00172">fuse()</a>.</p>

</div>
</div>
<a id="a73e2f0896470da6a34a6a40bfe55e957"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73e2f0896470da6a34a6a40bfe55e957">&#9670;&nbsp;</a></span>isStructurallyFusableProducer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool isStructurallyFusableProducer </td>
          <td>(</td>
          <td class="paramtype">LinalgOp&#160;</td>
          <td class="paramname"><em>producer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>consumedView</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LinalgOp&#160;</td>
          <td class="paramname"><em>consumer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Fusion_8cpp_source.html#l00266">266</a> of file <a class="el" href="Fusion_8cpp_source.html">Fusion.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="Fusion_8cpp_source.html#l00287">mlir::linalg::isProducerLastWriteOfView()</a>.</p>

</div>
</div>
<a id="a9dca7e29a8de7e3d6608c35f2c50183f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9dca7e29a8de7e3d6608c35f2c50183f">&#9670;&nbsp;</a></span>pruneReductionDimsFromMap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> pruneReductionDimsFromMap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt;&#160;</td>
          <td class="paramname"><em>iteratorTypes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>map</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prune all dimensions that are of reduction iterator type from <code>map</code>. </p>

<p class="definition">Definition at line <a class="el" href="Fusion_8cpp_source.html#l00524">524</a> of file <a class="el" href="Fusion_8cpp_source.html">Fusion.cpp</a>.</p>

<p class="reference">References <a class="el" href="Matchers_8h_source.html#l00206">mlir::detail::enumerate()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00736">mlir::getProjectedMap()</a>, and <a class="el" href="StructuredOpsUtils_8h_source.html#l00081">mlir::isParallelIterator()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Fusion_8cpp_source.html#l00540">getConsumerLoopToProducerLoopMap()</a>.</p>

</div>
</div>
<a id="af1ccfeffa295aff35d8ff682e8639024"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1ccfeffa295aff35d8ff682e8639024">&#9670;&nbsp;</a></span>tileAndFuseLinalgOpsImpl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt;<a class="el" href="structmlir_1_1linalg_1_1TiledAndFusedLinalgOps.html">TiledAndFusedLinalgOps</a>&gt; tileAndFuseLinalgOpsImpl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; LinalgOp &gt;&#160;</td>
          <td class="paramname"><em>ops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1linalg_1_1LinalgDependenceGraph.html">LinalgDependenceGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>dependenceGraph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1linalg_1_1LinalgTilingOptions.html">LinalgTilingOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>tilingOptions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Fusion_8cpp_source.html#l00875">875</a> of file <a class="el" href="Fusion_8cpp_source.html">Fusion.cpp</a>.</p>

<p class="reference">References <a class="el" href="Fusion_8cpp_source.html#l00652">collectFusableLoops()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">mlir::failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>, <a class="el" href="Fusion_8cpp_source.html#l00722">mlir::linalg::findAllFusableDependences()</a>, <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l00224">mlir::linalg::TiledAndFusedLinalgOps::fusedLoopDims</a>, <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l00228">mlir::linalg::TiledAndFusedLinalgOps::fusedLoops</a>, <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l00226">mlir::linalg::TiledAndFusedLinalgOps::fusedProducers</a>, <a class="el" href="Fusion_8cpp_source.html#l00798">fuseOperations()</a>, <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l00553">mlir::linalg::LinalgTilingOptions::interchangeVector</a>, <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l00222">mlir::linalg::TiledAndFusedLinalgOps::op</a>, <a class="el" href="Builders_8h_source.html#l00331">mlir::OpBuilder::setInsertionPoint()</a>, <a class="el" href="Fusion_8cpp_source.html#l00780">tileRootOperation()</a>, and <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l00529">mlir::linalg::LinalgTilingOptions::tileSizeComputationFunction</a>.</p>

<p class="reference">Referenced by <a class="el" href="Fusion_8cpp_source.html#l00943">mlir::linalg::tileAndFuseLinalgOps()</a>.</p>

</div>
</div>
<a id="ad88f424b81362cb5742883116fda9237"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad88f424b81362cb5742883116fda9237">&#9670;&nbsp;</a></span>tileRootOperation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt;<a class="el" href="structmlir_1_1linalg_1_1TiledLinalgOp.html">TiledLinalgOp</a>&gt; tileRootOperation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LinalgOp&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td>
          <td class="paramname"><em>tileSizeVector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1linalg_1_1LinalgTilingOptions.html">LinalgTilingOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>fusedLoops</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tile the fused loops in the root operation, by setting the tile sizes for all other loops to zero (those will be tiled later). </p>

<p class="definition">Definition at line <a class="el" href="Fusion_8cpp_source.html#l00780">780</a> of file <a class="el" href="Fusion_8cpp_source.html">Fusion.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8h_source.html#l00424">mlir::OpBuilder::create()</a>, <a class="el" href="PassManagerOptions_8cpp_source.html#l00083">options</a>, <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l00539">mlir::linalg::LinalgTilingOptions::setTileSizes()</a>, and <a class="el" href="Tiling_8cpp_source.html#l00322">mlir::linalg::tileLinalgOp()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Fusion_8cpp_source.html#l00875">tileAndFuseLinalgOpsImpl()</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Dec 6 2021 20:34:09 for MLIR by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
