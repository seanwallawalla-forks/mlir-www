<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MLIR: mlir::linalg Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MLIR
   &#160;<span id="projectnumber">14.0.0git</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacemlir.html">mlir</a></li><li class="navelem"><a class="el" href="namespacemlir_1_1linalg.html">linalg</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">mlir::linalg Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacemlir_1_1linalg_1_1comprehensive__bufferize"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg_1_1comprehensive__bufferize.html">comprehensive_bufferize</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1linalg_1_1detail"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg_1_1detail.html">detail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1linalg_1_1Aliases.html">Aliases</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A very primitive alias analysis which just records for each view, either:  <a href="classmlir_1_1linalg_1_1Aliases.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1CodegenStrategy.html">CodegenStrategy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Codegen strategy controls how a Linalg op is progressively lowered.  <a href="structmlir_1_1linalg_1_1CodegenStrategy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1linalg_1_1ConvOpVectorization.html">ConvOpVectorization</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts Convolution op into vector contraction.  <a href="classmlir_1_1linalg_1_1ConvOpVectorization.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1linalg_1_1CopyOpToLibraryCallRewrite.html">CopyOpToLibraryCallRewrite</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrite pattern specialization for CopyOp, kicks in when both input and output permutations are left unspecified or are the identity.  <a href="classmlir_1_1linalg_1_1CopyOpToLibraryCallRewrite.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1linalg_1_1CopyTransposeRewrite.html">CopyTransposeRewrite</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrite CopyOp with permutations into a sequence of TransposeOp and permutation-free CopyOp.  <a href="classmlir_1_1linalg_1_1CopyTransposeRewrite.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1Decompose.html">Decompose</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represent one application of createLinalgStrategyDecomposePass.  <a href="structmlir_1_1linalg_1_1Decompose.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1ExtractSliceOfPadTensorSwapPattern.html">ExtractSliceOfPadTensorSwapPattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrite extract_slice(pad_tensor(x)) into pad_tensor(extract_slice(x)).  <a href="structmlir_1_1linalg_1_1ExtractSliceOfPadTensorSwapPattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1FusionInfo.html">FusionInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A struct containing the Linalg producer before and after fusion.  <a href="structmlir_1_1linalg_1_1FusionInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1Generalize.html">Generalize</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represent one application of createLinalgStrategyGeneralizePass.  <a href="structmlir_1_1linalg_1_1Generalize.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1GeneralizePadTensorOpPattern.html">GeneralizePadTensorOpPattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrite a PadTensorOp into a sequence of InitTensorOp, FillOp and InsertSliceOp.  <a href="structmlir_1_1linalg_1_1GeneralizePadTensorOpPattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1GenerateLoopNest.html">GenerateLoopNest</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility class used to generate nested loops with ranges described by <code>loopRanges</code> and loop type described by the <code>iteratorTypes</code>.  <a href="structmlir_1_1linalg_1_1GenerateLoopNest.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1GenericOpInterchangePattern.html">GenericOpInterchangePattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Linalg generic interchage pattern.  <a href="structmlir_1_1linalg_1_1GenericOpInterchangePattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1Interchange.html">Interchange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represent one application of createLinalgStrategyInterchangePass.  <a href="structmlir_1_1linalg_1_1Interchange.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1LinalgBasePromotionPattern.html">LinalgBasePromotionPattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Linalg promotion patterns.  <a href="structmlir_1_1linalg_1_1LinalgBasePromotionPattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1LinalgBaseTileAndFusePattern.html">LinalgBaseTileAndFusePattern</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1LinalgBaseTilingPattern.html">LinalgBaseTilingPattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base pattern that applied the tiling transformation specified by <code>options</code>.  <a href="structmlir_1_1linalg_1_1LinalgBaseTilingPattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1LinalgBaseVectorizationPattern.html">LinalgBaseVectorizationPattern</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1LinalgCopyVTRForwardingPattern.html">LinalgCopyVTRForwardingPattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Match and rewrite for the pattern: ``` alloc = ...  <a href="structmlir_1_1linalg_1_1LinalgCopyVTRForwardingPattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1LinalgCopyVTWForwardingPattern.html">LinalgCopyVTWForwardingPattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Match and rewrite for the pattern: ``` alloc = ...  <a href="structmlir_1_1linalg_1_1LinalgCopyVTWForwardingPattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1linalg_1_1LinalgDependenceGraph.html">LinalgDependenceGraph</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data structure for holding a dependence graph that operates on LinalgOp and views as SSA values.  <a href="classmlir_1_1linalg_1_1LinalgDependenceGraph.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1LinalgElementwiseFusionOptions.html">LinalgElementwiseFusionOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Options that control fusion of elementwise operations.  <a href="structmlir_1_1linalg_1_1LinalgElementwiseFusionOptions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1LinalgEnablingOptions.html">LinalgEnablingOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Options to control the application of enabling transformations.  <a href="structmlir_1_1linalg_1_1LinalgEnablingOptions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1LinalgFusionOptions.html">LinalgFusionOptions</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1LinalgGeneralizationPattern.html">LinalgGeneralizationPattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Linalg generalization pattern.  <a href="structmlir_1_1linalg_1_1LinalgGeneralizationPattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1LinalgGenericTilingPattern.html">LinalgGenericTilingPattern</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1LinalgLoopDistributionOptions.html">LinalgLoopDistributionOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Options that allow distribution of loops generated in Linalg transforms to processors while generating the loops.  <a href="structmlir_1_1linalg_1_1LinalgLoopDistributionOptions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1LinalgLoweringPattern.html">LinalgLoweringPattern</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1linalg_1_1LinalgOpToLibraryCallRewrite.html">LinalgOpToLibraryCallRewrite</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1LinalgPaddingOptions.html">LinalgPaddingOptions</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1LinalgPaddingPattern.html">LinalgPaddingPattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Linalg padding pattern.  <a href="structmlir_1_1linalg_1_1LinalgPaddingPattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1LinalgPromotionOptions.html">LinalgPromotionOptions</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1LinalgPromotionPattern.html">LinalgPromotionPattern</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1LinalgTileAndFusePattern.html">LinalgTileAndFusePattern</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1LinalgTileAndFuseTensorOpsPattern.html">LinalgTileAndFuseTensorOpsPattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Linalg tile and fuse tensor ops pattern.  <a href="structmlir_1_1linalg_1_1LinalgTileAndFuseTensorOpsPattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1LinalgTilingAndFusionOptions.html">LinalgTilingAndFusionOptions</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1LinalgTilingOptions.html">LinalgTilingOptions</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1LinalgTilingPattern.html">LinalgTilingPattern</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1LinalgTransformationFilter.html">LinalgTransformationFilter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class to control application of linalg transformation patterns.  <a href="structmlir_1_1linalg_1_1LinalgTransformationFilter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1LinalgTransforms.html">LinalgTransforms</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1LinalgVectorizationOptions.html">LinalgVectorizationOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Linalg vectorization patterns.  <a href="structmlir_1_1linalg_1_1LinalgVectorizationOptions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1LinalgVectorizationPattern.html">LinalgVectorizationPattern</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1LinalgVectorLoweringOptions.html">LinalgVectorLoweringOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structVector.html">Vector</a> lowering options control how ops are lowered down to 1-D and scf.for form.  <a href="structmlir_1_1linalg_1_1LinalgVectorLoweringOptions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1OpOperandVector.html">OpOperandVector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1OpOperand.html" title="This class represents an operand of an operation. ">OpOperand</a> vector that implicitly converts to a <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> vector.  <a href="structmlir_1_1linalg_1_1OpOperandVector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1Pad.html">Pad</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represent one application of LinalgStrategyPadPass.  <a href="structmlir_1_1linalg_1_1Pad.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1PadTensorOpTransformationPattern.html">PadTensorOpTransformationPattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">PadTensorOp is not canonicalized away yet, so we provide a transformation to <code>linalg.generic</code>.  <a href="structmlir_1_1linalg_1_1PadTensorOpTransformationPattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1ProcInfo.html">ProcInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback function type used to get processor ID, and number of processors used for distribution for all parallel loops generated.  <a href="structmlir_1_1linalg_1_1ProcInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1Promote.html">Promote</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represent one application of createLinalgStrategyPromotePass.  <a href="structmlir_1_1linalg_1_1Promote.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1PromotionInfo.html">PromotionInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new buffer using the <code>allocationFn</code> provided.  <a href="structmlir_1_1linalg_1_1PromotionInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1linalg_1_1RangeType.html">RangeType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classmlir_1_1linalg_1_1RangeType.html" title="A RangeType represents a minimal range abstraction (min, max, step). ">RangeType</a> represents a minimal range abstraction (min, max, step).  <a href="classmlir_1_1linalg_1_1RangeType.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1RegionMatcher.html">RegionMatcher</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A struct containing common matchers over linalg op's region.  <a href="structmlir_1_1linalg_1_1RegionMatcher.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1Tile.html">Tile</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represent one application of LinalgStrategyTilePass.  <a href="structmlir_1_1linalg_1_1Tile.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1TileAndFuse.html">TileAndFuse</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represent one application of LinalgStrategyTileAndFusePass.  <a href="structmlir_1_1linalg_1_1TileAndFuse.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1TiledAndFusedLinalgOps.html">TiledAndFusedLinalgOps</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fuse a sequence of linalg operations (<code>ops</code>) using tile-and-fuse.  <a href="structmlir_1_1linalg_1_1TiledAndFusedLinalgOps.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1TiledLinalgOp.html">TiledLinalgOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs standalone tiling of a single LinalgOp by <code>tileSizes</code>.  <a href="structmlir_1_1linalg_1_1TiledLinalgOp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1linalg_1_1TileLoopNest.html">TileLoopNest</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A struct to manage the tile loop nest specific information.  <a href="classmlir_1_1linalg_1_1TileLoopNest.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1Transformation.html">Transformation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract <a class="el" href="structmlir_1_1linalg_1_1Transformation.html" title="Abstract Transformation class applied in a sequence that also handles state through markers...">Transformation</a> class applied in a sequence that also handles state through markers.  <a href="structmlir_1_1linalg_1_1Transformation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1Vectorize.html">Vectorize</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represent one application of createLinalgStrategyVectorizePass.  <a href="structmlir_1_1linalg_1_1Vectorize.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1VectorLowering.html">VectorLowering</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represent one application of createLinalgStrategyLowerVectorsPass.  <a href="structmlir_1_1linalg_1_1VectorLowering.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a949f3c7a426d9e0cfec01467631f8037"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a949f3c7a426d9e0cfec01467631f8037">LoopRangeBuilder</a> = std::function&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="structmlir_1_1Range.html">Range</a>, 4 &gt;(<a class="el" href="classmlir_1_1ImplicitLocOpBuilder.html">ImplicitLocOpBuilder</a>)&gt;</td></tr>
<tr class="separator:a949f3c7a426d9e0cfec01467631f8037"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a9ca79033211e3e53e0eb25a8e9551b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a4a9ca79033211e3e53e0eb25a8e9551b">LinalgLoops</a> = <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *, 4 &gt;</td></tr>
<tr class="separator:a4a9ca79033211e3e53e0eb25a8e9551b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f0c7d5683991009cfddd7748b7f8d4d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a7f0c7d5683991009cfddd7748b7f8d4d">ControlElementwiseOpsFusionFn</a> = std::function&lt; bool(const <a class="el" href="classmlir_1_1OpResult.html">OpResult</a> &amp;producer, <a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> &amp;consumer)&gt;</td></tr>
<tr class="memdesc:a7f0c7d5683991009cfddd7748b7f8d4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function type which is used to control when to stop fusion.  <a href="#a7f0c7d5683991009cfddd7748b7f8d4d">More...</a><br /></td></tr>
<tr class="separator:a7f0c7d5683991009cfddd7748b7f8d4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15f98a29e8d8529d00b3b406f009767e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a15f98a29e8d8529d00b3b406f009767e">AllocBufferCallbackFn</a> = std::function&lt; <a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;(<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, memref::SubViewOp subView, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; boundingSubViewSize, <a class="el" href="classmlir_1_1DataLayout.html">DataLayout</a> &amp;layout)&gt;</td></tr>
<tr class="memdesc:a15f98a29e8d8529d00b3b406f009767e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback function type used to perform the allocation for the promoted <code>subView</code>.  <a href="#a15f98a29e8d8529d00b3b406f009767e">More...</a><br /></td></tr>
<tr class="separator:a15f98a29e8d8529d00b3b406f009767e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d7afb284c4be072a74a24eeb71cc985"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a3d7afb284c4be072a74a24eeb71cc985">DeallocBufferCallbackFn</a> = std::function&lt; <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>(<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Value.html">Value</a> buffer)&gt;</td></tr>
<tr class="memdesc:a3d7afb284c4be072a74a24eeb71cc985"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback function type used to deallocate the buffers used to hold the promoted subview.  <a href="#a3d7afb284c4be072a74a24eeb71cc985">More...</a><br /></td></tr>
<tr class="separator:a3d7afb284c4be072a74a24eeb71cc985"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa49994e2aab61b35167972384684cf24"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#aa49994e2aab61b35167972384684cf24">CopyCallbackFn</a> = std::function&lt; <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>(<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Value.html">Value</a> src, <a class="el" href="classmlir_1_1Value.html">Value</a> dst)&gt;</td></tr>
<tr class="memdesc:aa49994e2aab61b35167972384684cf24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback function type used to insert copy from original subview to subview of the promoted region for the read operands/subview of promoted region to original subview for the results.  <a href="#aa49994e2aab61b35167972384684cf24">More...</a><br /></td></tr>
<tr class="separator:aa49994e2aab61b35167972384684cf24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a730df0415b8172eb93f8f7b346e04440"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a730df0415b8172eb93f8f7b346e04440">TileSizeComputationFunction</a> = std::function&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a>, 4 &gt;(<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *)&gt;</td></tr>
<tr class="separator:a730df0415b8172eb93f8f7b346e04440"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a035c53b6c522327cbc4e96070564738a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a035c53b6c522327cbc4e96070564738a">PaddingValueComputationFunction</a> = std::function&lt; <a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;(<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;, <a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> &amp;)&gt;</td></tr>
<tr class="memdesc:a035c53b6c522327cbc4e96070564738a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback returning the padding value to use for a given <a class="el" href="classmlir_1_1OpOperand.html" title="This class represents an operand of an operation. ">OpOperand</a> or failure for no padding.  <a href="#a035c53b6c522327cbc4e96070564738a">More...</a><br /></td></tr>
<tr class="separator:a035c53b6c522327cbc4e96070564738a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96e2c72347bd9cc278b81c22fe13d35b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a96e2c72347bd9cc278b81c22fe13d35b">PaddingNoFoldComputationFunction</a> = std::function&lt; bool(<a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> &amp;)&gt;</td></tr>
<tr class="memdesc:a96e2c72347bd9cc278b81c22fe13d35b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback returning true if the pad tensor operation defining the given <a class="el" href="classmlir_1_1OpOperand.html" title="This class represents an operand of an operation. ">OpOperand</a> shall be marked as nofold to enable packing.  <a href="#a96e2c72347bd9cc278b81c22fe13d35b">More...</a><br /></td></tr>
<tr class="separator:a96e2c72347bd9cc278b81c22fe13d35b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaf3af3f2e3d6690f81118bf194fb0a4"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#afaf3af3f2e3d6690f81118bf194fb0a4">PaddingHoistComputationFunction</a> = std::function&lt; int64_t(<a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> &amp;)&gt;</td></tr>
<tr class="memdesc:afaf3af3f2e3d6690f81118bf194fb0a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback returning the number of loops to hoist the pad tensor operation defining the given <a class="el" href="classmlir_1_1OpOperand.html" title="This class represents an operand of an operation. ">OpOperand</a>.  <a href="#afaf3af3f2e3d6690f81118bf194fb0a4">More...</a><br /></td></tr>
<tr class="separator:afaf3af3f2e3d6690f81118bf194fb0a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54b1e68a26156715923bbc38afddff82"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:a54b1e68a26156715923bbc38afddff82"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a54b1e68a26156715923bbc38afddff82">has_get_operation_name</a> = decltype(T::getOperationName())</td></tr>
<tr class="memdesc:a54b1e68a26156715923bbc38afddff82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait to check if T provides a <code>getOperationName</code> method.  <a href="#a54b1e68a26156715923bbc38afddff82">More...</a><br /></td></tr>
<tr class="separator:a54b1e68a26156715923bbc38afddff82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ba4b4e6dc3c816c9b069a2c40c97420"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4ba4b4e6dc3c816c9b069a2c40c97420"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a4ba4b4e6dc3c816c9b069a2c40c97420">detect_has_get_operation_name</a> = llvm::is_detected&lt; <a class="el" href="namespacemlir_1_1linalg.html#a54b1e68a26156715923bbc38afddff82">has_get_operation_name</a>, T &gt;</td></tr>
<tr class="separator:a4ba4b4e6dc3c816c9b069a2c40c97420"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f14b7de232347900daf39a27a2725b1"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a7f14b7de232347900daf39a27a2725b1">OptimizeCopyFn</a> = std::function&lt; <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>(<a class="el" href="classmlir_1_1PatternRewriter.html">PatternRewriter</a> &amp;, PadTensorOp, <a class="el" href="classmlir_1_1Value.html">Value</a>)&gt;</td></tr>
<tr class="separator:a7f14b7de232347900daf39a27a2725b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed2c8e52c82709202bade005c0609f77"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#aed2c8e52c82709202bade005c0609f77">FusableOpDependencesTy</a> = llvm::MapVector&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="structmlir_1_1linalg_1_1LinalgDependenceGraph_1_1LinalgDependenceGraphElem.html">LinalgDependenceGraph::LinalgDependenceGraphElem</a>, 1 &gt; &gt;</td></tr>
<tr class="separator:aed2c8e52c82709202bade005c0609f77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60a0b220b224fc8b91b37ee63b95a12f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a60a0b220b224fc8b91b37ee63b95a12f">ProcInfoCallBackFn</a> = std::function&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="structmlir_1_1linalg_1_1ProcInfo.html">ProcInfo</a>, 2 &gt;(<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="structmlir_1_1Range.html">Range</a> &gt; parallelLoopRanges)&gt;</td></tr>
<tr class="separator:a60a0b220b224fc8b91b37ee63b95a12f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43919709cf99a429d1b9e995f6cb555e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a43919709cf99a429d1b9e995f6cb555e">OneDimProcInfoCallBackFn</a> = std::function&lt; <a class="el" href="structmlir_1_1linalg_1_1ProcInfo.html">ProcInfo</a>(<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Location.html">Location</a> loc)&gt;</td></tr>
<tr class="separator:a43919709cf99a429d1b9e995f6cb555e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a98153087b663d0d7aa3ab0685cfaedaf"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a98153087b663d0d7aa3ab0685cfaedaf">LinalgLoweringType</a> { <a class="el" href="namespacemlir_1_1linalg.html#a98153087b663d0d7aa3ab0685cfaedafaaf6ba7cc968a74a4d611c3ab0148b33c">LinalgLoweringType::LibraryCall</a> = 0, 
<a class="el" href="namespacemlir_1_1linalg.html#a98153087b663d0d7aa3ab0685cfaedafa4b2257cb98694284507e77f34e73c2d8">LinalgLoweringType::Loops</a> = 1, 
<a class="el" href="namespacemlir_1_1linalg.html#a98153087b663d0d7aa3ab0685cfaedafa6d8bf0bdeaca5ef4693524bf04c4c877">LinalgLoweringType::AffineLoops</a> = 2, 
<a class="el" href="namespacemlir_1_1linalg.html#a98153087b663d0d7aa3ab0685cfaedafab92546344b4e3fa9b10c9472795297a7">LinalgLoweringType::ParallelLoops</a> = 3
 }<tr class="memdesc:a98153087b663d0d7aa3ab0685cfaedaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Linalg lowering patterns.  <a href="namespacemlir_1_1linalg.html#a98153087b663d0d7aa3ab0685cfaedaf">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a98153087b663d0d7aa3ab0685cfaedaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cdd229e1459c7e6ed2f9c7ee7168325"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a3cdd229e1459c7e6ed2f9c7ee7168325">LinalgTilingLoopType</a> { <a class="el" href="namespacemlir_1_1linalg.html#a3cdd229e1459c7e6ed2f9c7ee7168325a4b2257cb98694284507e77f34e73c2d8">LinalgTilingLoopType::Loops</a> = 0, 
<a class="el" href="namespacemlir_1_1linalg.html#a3cdd229e1459c7e6ed2f9c7ee7168325a6d8bf0bdeaca5ef4693524bf04c4c877">LinalgTilingLoopType::AffineLoops</a> = 1, 
<a class="el" href="namespacemlir_1_1linalg.html#a3cdd229e1459c7e6ed2f9c7ee7168325ab92546344b4e3fa9b10c9472795297a7">LinalgTilingLoopType::ParallelLoops</a> = 2, 
<a class="el" href="namespacemlir_1_1linalg.html#a3cdd229e1459c7e6ed2f9c7ee7168325a695eb12d246fdee4efda9a552f92406e">LinalgTilingLoopType::TiledLoops</a> = 3
 }<tr class="memdesc:a3cdd229e1459c7e6ed2f9c7ee7168325"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of loops to be generated during tiling.  <a href="namespacemlir_1_1linalg.html#a3cdd229e1459c7e6ed2f9c7ee7168325">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a3cdd229e1459c7e6ed2f9c7ee7168325"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7382d59369873eb3a9a9ddd571056982"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a7382d59369873eb3a9a9ddd571056982">DistributionMethod</a> { <a class="el" href="namespacemlir_1_1linalg.html#a7382d59369873eb3a9a9ddd571056982ad71670d62b238eaf063979407361034e">DistributionMethod::Cyclic</a> = 0, 
<a class="el" href="namespacemlir_1_1linalg.html#a7382d59369873eb3a9a9ddd571056982abab54876ff518ecd2d59b46fd3be9c0e">DistributionMethod::CyclicNumProcsGeNumIters</a> = 1, 
<a class="el" href="namespacemlir_1_1linalg.html#a7382d59369873eb3a9a9ddd571056982ad93606014b9a6b479ba0e6faa948540b">DistributionMethod::CyclicNumProcsEqNumIters</a> = 2
 }<tr class="memdesc:a7382d59369873eb3a9a9ddd571056982"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scheme used to distribute loops to processors.  <a href="namespacemlir_1_1linalg.html#a7382d59369873eb3a9a9ddd571056982">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a7382d59369873eb3a9a9ddd571056982"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a703d4f21c6f57b8c680dc20dd6928a61"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a703d4f21c6f57b8c680dc20dd6928a61">populateLinalgToStandardConversionPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:a703d4f21c6f57b8c680dc20dd6928a61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate the given list with patterns that convert from Linalg to Standard.  <a href="#a703d4f21c6f57b8c680dc20dd6928a61">More...</a><br /></td></tr>
<tr class="separator:a703d4f21c6f57b8c680dc20dd6928a61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67f3fb54af9cdc66ff265b44a17a5df4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a>, 4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a67f3fb54af9cdc66ff265b44a17a5df4">applyMapToValues</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> map, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> values)</td></tr>
<tr class="memdesc:a67f3fb54af9cdc66ff265b44a17a5df4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the values obtained by applying <code>map</code> to the list of values.  <a href="#a67f3fb54af9cdc66ff265b44a17a5df4">More...</a><br /></td></tr>
<tr class="separator:a67f3fb54af9cdc66ff265b44a17a5df4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5277093c168682f123f1e99d90461f0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#ab5277093c168682f123f1e99d90461f0">isaContractionOpInterface</a> (LinalgOp linalgOp)</td></tr>
<tr class="memdesc:ab5277093c168682f123f1e99d90461f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether <code>linalgOp</code> conforms to ContractionOpInterface.  <a href="#ab5277093c168682f123f1e99d90461f0">More...</a><br /></td></tr>
<tr class="separator:ab5277093c168682f123f1e99d90461f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9aac538302681e906bd4261c128d90e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemlir_1_1linalg.html#a949f3c7a426d9e0cfec01467631f8037">LoopRangeBuilder</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#af9aac538302681e906bd4261c128d90e">defaultLoopRangesBuilder</a> (LinalgOp op)</td></tr>
<tr class="memdesc:af9aac538302681e906bd4261c128d90e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide a very simple inference procedure to build the loop ranges from the op and its operands.  <a href="#af9aac538302681e906bd4261c128d90e">More...</a><br /></td></tr>
<tr class="separator:af9aac538302681e906bd4261c128d90e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a754ec5c5960c640563ddcd9727b77d87"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a754ec5c5960c640563ddcd9727b77d87">generateLibraryCallName</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:a754ec5c5960c640563ddcd9727b77d87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the name mangled library call name to disambiguate between different overloads at the C level.  <a href="#a754ec5c5960c640563ddcd9727b77d87">More...</a><br /></td></tr>
<tr class="separator:a754ec5c5960c640563ddcd9727b77d87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a962a46fba2ac497e30bb6d23fef35d1a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>, 4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a962a46fba2ac497e30bb6d23fef35d1a">makeAffineDimExprs</a> (<a class="el" href="classunsigned.html">unsigned</a> num, <a class="el" href="classunsigned.html">unsigned</a> &amp;startIdx, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context)</td></tr>
<tr class="memdesc:a962a46fba2ac497e30bb6d23fef35d1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>num</code> <a class="el" href="classmlir_1_1AffineDimExpr.html" title="A dimensional identifier appearing in an affine expression. ">AffineDimExpr</a> dimensions at positions [startIdx, startIdx + num) and increments <code>startIdx</code> to <code>startIdx + num</code>.  <a href="#a962a46fba2ac497e30bb6d23fef35d1a">More...</a><br /></td></tr>
<tr class="separator:a962a46fba2ac497e30bb6d23fef35d1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ddca37c4e3bf09cb06fc5197380bde3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a6ddca37c4e3bf09cb06fc5197380bde3">extractOrIdentityMap</a> (<a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt; maybeMap, <a class="el" href="classunsigned.html">unsigned</a> rank, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context)</td></tr>
<tr class="memdesc:a6ddca37c4e3bf09cb06fc5197380bde3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>maybeMap.get()</code> if <code>maybeMap</code> is set, otherwise returns the symbol-less identity map of <code>rank</code>.  <a href="#a6ddca37c4e3bf09cb06fc5197380bde3">More...</a><br /></td></tr>
<tr class="separator:a6ddca37c4e3bf09cb06fc5197380bde3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f8ea0aae80d24eeffa3fef8f1f08c43"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>, 4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a4f8ea0aae80d24eeffa3fef8f1f08c43">concat</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt; a, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt; b)</td></tr>
<tr class="memdesc:a4f8ea0aae80d24eeffa3fef8f1f08c43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the vector that is the concatenation of <code>a</code> and <code>b</code>.  <a href="#a4f8ea0aae80d24eeffa3fef8f1f08c43">More...</a><br /></td></tr>
<tr class="separator:a4f8ea0aae80d24eeffa3fef8f1f08c43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a504d0107ce313528b9b8b2ecefb43e38"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a504d0107ce313528b9b8b2ecefb43e38">getDimsOfType</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, StringRef iteratorTypeName, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt; &amp;res)</td></tr>
<tr class="memdesc:a504d0107ce313528b9b8b2ecefb43e38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the dims that are <code>iteratorTypeName</code> loops in the LinalgOp <code>op</code>.  <a href="#a504d0107ce313528b9b8b2ecefb43e38">More...</a><br /></td></tr>
<tr class="separator:a504d0107ce313528b9b8b2ecefb43e38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbc911548f9f0328faf5855ab880e7bc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#afbc911548f9f0328faf5855ab880e7bc">hoistRedundantVectorTransfers</a> (FuncOp func)</td></tr>
<tr class="memdesc:afbc911548f9f0328faf5855ab880e7bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hoist vector.transfer_read/vector.transfer_write on buffers pairs out of immediately enclosing scf::ForOp iteratively, if the following conditions are true:  <a href="#afbc911548f9f0328faf5855ab880e7bc">More...</a><br /></td></tr>
<tr class="separator:afbc911548f9f0328faf5855ab880e7bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a128bb6b2ac6de56efa82fb01ae3f258e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a128bb6b2ac6de56efa82fb01ae3f258e">hoistRedundantVectorTransfersOnTensor</a> (FuncOp func)</td></tr>
<tr class="memdesc:a128bb6b2ac6de56efa82fb01ae3f258e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same behavior as <code>hoistRedundantVectorTransfers</code> but works on tensors instead of buffers.  <a href="#a128bb6b2ac6de56efa82fb01ae3f258e">More...</a><br /></td></tr>
<tr class="separator:a128bb6b2ac6de56efa82fb01ae3f258e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0137dfe47aacce8f945d65064093cd2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#ad0137dfe47aacce8f945d65064093cd2">hoistPaddingOnTensors</a> (PadTensorOp opToHoist, int numLoops, PadTensorOp &amp;hoistedOp)</td></tr>
<tr class="memdesc:ad0137dfe47aacce8f945d65064093cd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mechanically hoist padding operations on tensors by <code>numLoops</code> into a new, generally larger tensor.  <a href="#ad0137dfe47aacce8f945d65064093cd2">More...</a><br /></td></tr>
<tr class="separator:ad0137dfe47aacce8f945d65064093cd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae949a412565c20b3d334a8d3a26acab3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#ae949a412565c20b3d334a8d3a26acab3">skipUnitDimReshape</a> (const <a class="el" href="classmlir_1_1OpResult.html">OpResult</a> &amp;producer, <a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> &amp;consumer)</td></tr>
<tr class="memdesc:ae949a412565c20b3d334a8d3a26acab3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default function to control reshape folding.  <a href="#ae949a412565c20b3d334a8d3a26acab3">More...</a><br /></td></tr>
<tr class="separator:ae949a412565c20b3d334a8d3a26acab3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09260a76a605cbb154f1a4d802feeea9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a09260a76a605cbb154f1a4d802feeea9">populateConvVectorizationPatterns</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &gt; &amp;patterns, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; tileSizes)</td></tr>
<tr class="memdesc:a09260a76a605cbb154f1a4d802feeea9"><td class="mdescLeft">&#160;</td><td class="mdescRight">[DEPRECATED] Populates patterns for vectorization of all ConvN-D ops.  <a href="#a09260a76a605cbb154f1a4d802feeea9">More...</a><br /></td></tr>
<tr class="separator:a09260a76a605cbb154f1a4d802feeea9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a891b8f2d145dcc3327ba55c7a49d44e4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a891b8f2d145dcc3327ba55c7a49d44e4">populateConvolutionVectorizationPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns, <a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a> benefit=1)</td></tr>
<tr class="memdesc:a891b8f2d145dcc3327ba55c7a49d44e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates patterns for vectorizing low-D convolution ops.  <a href="#a891b8f2d145dcc3327ba55c7a49d44e4">More...</a><br /></td></tr>
<tr class="separator:a891b8f2d145dcc3327ba55c7a49d44e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a49133ef595966377878adc42196f47"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a7a49133ef595966377878adc42196f47">populateElementwiseToLinalgConversionPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:a7a49133ef595966377878adc42196f47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate patterns that convert <code>ElementwiseMappable</code> ops to linalg parallel loops.  <a href="#a7a49133ef595966377878adc42196f47">More...</a><br /></td></tr>
<tr class="separator:a7a49133ef595966377878adc42196f47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b6b7bc78a3dd3530d45e50a15e48af5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a5b6b7bc78a3dd3530d45e50a15e48af5">populateFoldReshapeOpsByExpansionPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns, <a class="el" href="namespacemlir_1_1linalg.html#a7f0c7d5683991009cfddd7748b7f8d4d">ControlElementwiseOpsFusionFn</a> controlFoldingReshapes=<a class="el" href="namespacemlir_1_1linalg.html#ae949a412565c20b3d334a8d3a26acab3">skipUnitDimReshape</a>)</td></tr>
<tr class="memdesc:a5b6b7bc78a3dd3530d45e50a15e48af5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Patterns to fold an expanding (collapsing) tensor_reshape operation with its producer (consumer) generic operation by expanding the dimensionality of the loop in the generic op.  <a href="#a5b6b7bc78a3dd3530d45e50a15e48af5">More...</a><br /></td></tr>
<tr class="separator:a5b6b7bc78a3dd3530d45e50a15e48af5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83456e96c4abd883654638b15422f2f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a83456e96c4abd883654638b15422f2f7">populateFoldReshapeOpsByLinearizationPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:a83456e96c4abd883654638b15422f2f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Patterns to fold a collapsing (expanding) tensor_reshape operation with its producer (consumer) generic operation by linearizing the indexing map used to access the source (target) of the reshape operation in the generic operation.  <a href="#a83456e96c4abd883654638b15422f2f7">More...</a><br /></td></tr>
<tr class="separator:a83456e96c4abd883654638b15422f2f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaab9722666a91e7e3d5e93b24bb9f8f2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#aaab9722666a91e7e3d5e93b24bb9f8f2">populateFoldUnitDimsReshapeOpsByLinearizationPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:aaab9722666a91e7e3d5e93b24bb9f8f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Patterns to fold a collapsing (expanding) tensor_reshape operation with its producer (consumer) generic operation by linearizing the indexing map used to access the source (target) of the reshape operation in the generic operation.  <a href="#aaab9722666a91e7e3d5e93b24bb9f8f2">More...</a><br /></td></tr>
<tr class="separator:aaab9722666a91e7e3d5e93b24bb9f8f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af340607de92119a4db091ed375086bb0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#af340607de92119a4db091ed375086bb0">populateLinalgBufferizePatterns</a> (<a class="el" href="classmlir_1_1bufferization_1_1BufferizeTypeConverter.html">bufferization::BufferizeTypeConverter</a> &amp;converter, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:af340607de92119a4db091ed375086bb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates the given list with patterns to bufferize linalg ops.  <a href="#af340607de92119a4db091ed375086bb0">More...</a><br /></td></tr>
<tr class="separator:af340607de92119a4db091ed375086bb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f438ad194cd296b83dd3f3b4e68f82e"><td class="memItemLeft" align="right" valign="top">LinalgOp&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a9f438ad194cd296b83dd3f3b4e68f82e">createLinalgOpOnBuffers</a> (<a class="el" href="classmlir_1_1ConversionPatternRewriter.html">ConversionPatternRewriter</a> &amp;rewriter, LinalgOp linalgOp, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> inputs, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> outputs)</td></tr>
<tr class="memdesc:a9f438ad194cd296b83dd3f3b4e68f82e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create linalg op on buffers given the original tensor-based operation and the buffers for the outputs.  <a href="#a9f438ad194cd296b83dd3f3b4e68f82e">More...</a><br /></td></tr>
<tr class="separator:a9f438ad194cd296b83dd3f3b4e68f82e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1578d606ad73b93f532062fef0ce6574"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a1578d606ad73b93f532062fef0ce6574">populateFoldUnitExtentDimsPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:a1578d606ad73b93f532062fef0ce6574"><td class="mdescLeft">&#160;</td><td class="mdescRight">Patterns to fold unit-extent dimensions in operands/results of linalg ops on tensors.  <a href="#a1578d606ad73b93f532062fef0ce6574">More...</a><br /></td></tr>
<tr class="separator:a1578d606ad73b93f532062fef0ce6574"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc64a8c8a9ecf3de84383893d8e4ddc2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#acc64a8c8a9ecf3de84383893d8e4ddc2">populateInlineConstantOperandsPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:acc64a8c8a9ecf3de84383893d8e4ddc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Patterns that are used to inline constant operands into linalg generic ops.  <a href="#acc64a8c8a9ecf3de84383893d8e4ddc2">More...</a><br /></td></tr>
<tr class="separator:acc64a8c8a9ecf3de84383893d8e4ddc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a141726cc3e876dde26944874a419e36c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a141726cc3e876dde26944874a419e36c">populateTiledLoopToSCFPattern</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:a141726cc3e876dde26944874a419e36c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1Pattern.html" title="This class contains all of the data related to a pattern, but does not contain any methods or logic f...">Pattern</a> to convert TiledLoopOp to SCF loops.  <a href="#a141726cc3e876dde26944874a419e36c">More...</a><br /></td></tr>
<tr class="separator:a141726cc3e876dde26944874a419e36c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46f808101854ba4429cc752879269e28"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a46f808101854ba4429cc752879269e28">populateElementwiseOpsFusionPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns, <a class="el" href="structmlir_1_1linalg_1_1LinalgElementwiseFusionOptions.html">LinalgElementwiseFusionOptions</a> <a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>=<a class="el" href="structmlir_1_1linalg_1_1LinalgElementwiseFusionOptions.html">LinalgElementwiseFusionOptions</a>())</td></tr>
<tr class="memdesc:a46f808101854ba4429cc752879269e28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Patterns for fusing linalg operation on tensors.  <a href="#a46f808101854ba4429cc752879269e28">More...</a><br /></td></tr>
<tr class="separator:a46f808101854ba4429cc752879269e28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8660b99b3f1cd3f42085e6c6694b0a0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#ae8660b99b3f1cd3f42085e6c6694b0a0">populatePushReshapeOpsPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:ae8660b99b3f1cd3f42085e6c6694b0a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Patterns to push reshape op towards the end of the graph in order to expose more fusion opportunities.  <a href="#ae8660b99b3f1cd3f42085e6c6694b0a0">More...</a><br /></td></tr>
<tr class="separator:ae8660b99b3f1cd3f42085e6c6694b0a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52412776b72534e8955af53d7285530d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; <a class="el" href="structmlir_1_1linalg_1_1TiledLinalgOp.html">TiledLinalgOp</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a52412776b72534e8955af53d7285530d">tileLinalgOp</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, LinalgOp op, const <a class="el" href="structmlir_1_1linalg_1_1LinalgTilingOptions.html">LinalgTilingOptions</a> &amp;<a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>)</td></tr>
<tr class="separator:a52412776b72534e8955af53d7285530d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1124afb803ef915203368364f5525d43"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; <a class="el" href="structmlir_1_1linalg_1_1TiledAndFusedLinalgOps.html">TiledAndFusedLinalgOps</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a1124afb803ef915203368364f5525d43">tileAndFuseLinalgOps</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; LinalgOp &gt; ops, const <a class="el" href="classmlir_1_1linalg_1_1LinalgDependenceGraph.html">LinalgDependenceGraph</a> &amp;dependenceGraph, const <a class="el" href="structmlir_1_1linalg_1_1LinalgTilingOptions.html">LinalgTilingOptions</a> &amp;tilingOptions)</td></tr>
<tr class="separator:a1124afb803ef915203368364f5525d43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4223ee2d6488e478b0a9e86897094a9a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a4223ee2d6488e478b0a9e86897094a9a">interchangeGenericOp</a> (<a class="el" href="classmlir_1_1PatternRewriter.html">PatternRewriter</a> &amp;rewriter, GenericOp genericOp, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt; interchangeVector)</td></tr>
<tr class="memdesc:a4223ee2d6488e478b0a9e86897094a9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interchanges the <code>iterator_types</code> and <code>iterator_maps</code> dimensions and adapts the index accesses of <code>op</code>.  <a href="#a4223ee2d6488e478b0a9e86897094a9a">More...</a><br /></td></tr>
<tr class="separator:a4223ee2d6488e478b0a9e86897094a9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8554d3163fa39108815d5c8fe971b584"><td class="memItemLeft" align="right" valign="top">GenericOp&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a8554d3163fa39108815d5c8fe971b584">generalizeNamedOp</a> (<a class="el" href="classmlir_1_1PatternRewriter.html">PatternRewriter</a> &amp;rewriter, LinalgOp namedOp)</td></tr>
<tr class="memdesc:a8554d3163fa39108815d5c8fe971b584"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a GenericOp from the given named operation <code>namedOp</code>.  <a href="#a8554d3163fa39108815d5c8fe971b584">More...</a><br /></td></tr>
<tr class="separator:a8554d3163fa39108815d5c8fe971b584"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5f0e6199a06738cd8e8eae51311517b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; <a class="el" href="structmlir_1_1linalg_1_1PromotionInfo.html">PromotionInfo</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#ae5f0e6199a06738cd8e8eae51311517b">promoteSubviewAsNewBuffer</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, memref::SubViewOp subView, <a class="el" href="namespacemlir_1_1linalg.html#a15f98a29e8d8529d00b3b406f009767e">AllocBufferCallbackFn</a> allocationFn, <a class="el" href="classmlir_1_1DataLayout.html">DataLayout</a> &amp;layout)</td></tr>
<tr class="separator:ae5f0e6199a06738cd8e8eae51311517b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aede64ae3f89e52f6abd4ed07c884b078"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; LinalgOp &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#aede64ae3f89e52f6abd4ed07c884b078">promoteSubViews</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, LinalgOp op, <a class="el" href="structmlir_1_1linalg_1_1LinalgPromotionOptions.html">LinalgPromotionOptions</a> <a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>)</td></tr>
<tr class="memdesc:aede64ae3f89e52f6abd4ed07c884b078"><td class="mdescLeft">&#160;</td><td class="mdescRight">Promotes the <code>subViews</code> into a new buffer allocated at the insertion point <code>b</code>.  <a href="#aede64ae3f89e52f6abd4ed07c884b078">More...</a><br /></td></tr>
<tr class="separator:aede64ae3f89e52f6abd4ed07c884b078"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafecf344e928b95496d372d78ae592a0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#aafecf344e928b95496d372d78ae592a0">vectorizeLinalgOp</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;newResults)</td></tr>
<tr class="memdesc:aafecf344e928b95496d372d78ae592a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit a suitable vector form for a Linalg op with fully static shape.  <a href="#aafecf344e928b95496d372d78ae592a0">More...</a><br /></td></tr>
<tr class="separator:aafecf344e928b95496d372d78ae592a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0560d71ab93b47840620101f0a967e71"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; <a class="el" href="namespacemlir_1_1linalg.html#a4a9ca79033211e3e53e0eb25a8e9551b">LinalgLoops</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a0560d71ab93b47840620101f0a967e71">linalgOpToLoops</a> (<a class="el" href="classmlir_1_1PatternRewriter.html">PatternRewriter</a> &amp;rewriter, LinalgOp linalgOp)</td></tr>
<tr class="memdesc:a0560d71ab93b47840620101f0a967e71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emits a loop nest of <code>scf.for</code> with the proper body for <code>linalgOp</code>.  <a href="#a0560d71ab93b47840620101f0a967e71">More...</a><br /></td></tr>
<tr class="separator:a0560d71ab93b47840620101f0a967e71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80b030d0e1f67f25aabea28e8ff27087"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; <a class="el" href="namespacemlir_1_1linalg.html#a4a9ca79033211e3e53e0eb25a8e9551b">LinalgLoops</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a80b030d0e1f67f25aabea28e8ff27087">linalgOpToParallelLoops</a> (<a class="el" href="classmlir_1_1PatternRewriter.html">PatternRewriter</a> &amp;rewriter, LinalgOp linalgOp)</td></tr>
<tr class="memdesc:a80b030d0e1f67f25aabea28e8ff27087"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emits a loop nest of <code>scf.parallel</code> with the proper body for <code>linalgOp</code>.  <a href="#a80b030d0e1f67f25aabea28e8ff27087">More...</a><br /></td></tr>
<tr class="separator:a80b030d0e1f67f25aabea28e8ff27087"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a740346ce432cec25b0a0f13106745fff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; <a class="el" href="namespacemlir_1_1linalg.html#a4a9ca79033211e3e53e0eb25a8e9551b">LinalgLoops</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a740346ce432cec25b0a0f13106745fff">linalgOpToAffineLoops</a> (<a class="el" href="classmlir_1_1PatternRewriter.html">PatternRewriter</a> &amp;rewriter, LinalgOp linalgOp)</td></tr>
<tr class="memdesc:a740346ce432cec25b0a0f13106745fff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emits a loop nest of <code>affine.for</code> with the proper body for <code>linalgOp</code>.  <a href="#a740346ce432cec25b0a0f13106745fff">More...</a><br /></td></tr>
<tr class="separator:a740346ce432cec25b0a0f13106745fff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9af1c8a390189f7f1882bfd1181f8112"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a9af1c8a390189f7f1882bfd1181f8112">interchangeGenericOpPrecondition</a> (GenericOp genericOp, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt; interchangeVector)</td></tr>
<tr class="memdesc:a9af1c8a390189f7f1882bfd1181f8112"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emits a <code>generic</code> operation with the <code>indexing_maps</code> and <code>iterator_types</code> permutated according to <code>permutation</code>.  <a href="#a9af1c8a390189f7f1882bfd1181f8112">More...</a><br /></td></tr>
<tr class="separator:a9af1c8a390189f7f1882bfd1181f8112"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f2367adbb110b452ca67b7c33f40e6a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a2f2367adbb110b452ca67b7c33f40e6a">generalizeNamedOpPrecondition</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:a2f2367adbb110b452ca67b7c33f40e6a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structmlir_1_1linalg_1_1Generalize.html" title="Represent one application of createLinalgStrategyGeneralizePass. ">Generalize</a> named operations to generic operations.  <a href="#a2f2367adbb110b452ca67b7c33f40e6a">More...</a><br /></td></tr>
<tr class="separator:a2f2367adbb110b452ca67b7c33f40e6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a850b9fd11404efe17bca02011aff2e88"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a850b9fd11404efe17bca02011aff2e88">promoteSubviewsPrecondition</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="structmlir_1_1linalg_1_1LinalgPromotionOptions.html">LinalgPromotionOptions</a> <a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>)</td></tr>
<tr class="memdesc:a850b9fd11404efe17bca02011aff2e88"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structmlir_1_1linalg_1_1Promote.html" title="Represent one application of createLinalgStrategyPromotePass. ">Promote</a> std.subviews feeding linalg operations.  <a href="#a850b9fd11404efe17bca02011aff2e88">More...</a><br /></td></tr>
<tr class="separator:a850b9fd11404efe17bca02011aff2e88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a434bd78a651f6a42d01090db72bc039c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a434bd78a651f6a42d01090db72bc039c">vectorizeLinalgOpPrecondition</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:a434bd78a651f6a42d01090db72bc039c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrite a linalg.generic into a suitable vector.contraction op.  <a href="#a434bd78a651f6a42d01090db72bc039c">More...</a><br /></td></tr>
<tr class="separator:a434bd78a651f6a42d01090db72bc039c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae61503376ad6b88f0c35f8ce358dbc9e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#ae61503376ad6b88f0c35f8ce358dbc9e">getLinalgTilingCanonicalizationPatterns</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *ctx)</td></tr>
<tr class="memdesc:ae61503376ad6b88f0c35f8ce358dbc9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Canonicalization patterns relevant to apply after tiling patterns.  <a href="#ae61503376ad6b88f0c35f8ce358dbc9e">More...</a><br /></td></tr>
<tr class="separator:ae61503376ad6b88f0c35f8ce358dbc9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4701ad0fa2e34da0089a80135935f02e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a4701ad0fa2e34da0089a80135935f02e">populateLinalgTilingCanonicalizationPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="separator:a4701ad0fa2e34da0089a80135935f02e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a770981e996593487fafc3a47ac9c4be9"><td class="memTemplParams" colspan="2">template&lt;typename OpType , typename  = std::enable_if_t&lt;detect_has_get_operation_name&lt;OpType&gt;::value&gt;, typename  = void&gt; </td></tr>
<tr class="memitem:a770981e996593487fafc3a47ac9c4be9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a770981e996593487fafc3a47ac9c4be9">insertVectorizationPatternImpl</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patternList, <a class="el" href="structmlir_1_1linalg_1_1LinalgVectorizationOptions.html">linalg::LinalgVectorizationOptions</a> <a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>, <a class="el" href="structmlir_1_1linalg_1_1LinalgTransformationFilter.html">linalg::LinalgTransformationFilter</a> f)</td></tr>
<tr class="memdesc:a770981e996593487fafc3a47ac9c4be9"><td class="mdescLeft">&#160;</td><td class="mdescRight">SFINAE helper for single C++ op with a <code>getOperationName</code> method.  <a href="#a770981e996593487fafc3a47ac9c4be9">More...</a><br /></td></tr>
<tr class="separator:a770981e996593487fafc3a47ac9c4be9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b512a9592500c7fb570fea733d3591f"><td class="memTemplParams" colspan="2">template&lt;typename OpType , typename  = std::enable_if_t&lt;                               !detect_has_get_operation_name&lt;OpType&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:a7b512a9592500c7fb570fea733d3591f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a7b512a9592500c7fb570fea733d3591f">insertVectorizationPatternImpl</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patternList, <a class="el" href="structmlir_1_1linalg_1_1LinalgVectorizationOptions.html">linalg::LinalgVectorizationOptions</a> <a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>, <a class="el" href="structmlir_1_1linalg_1_1LinalgTransformationFilter.html">linalg::LinalgTransformationFilter</a> f)</td></tr>
<tr class="memdesc:a7b512a9592500c7fb570fea733d3591f"><td class="mdescLeft">&#160;</td><td class="mdescRight">SFINAE helper for single C++ class without a <code>getOperationName</code> method (e.g.  <a href="#a7b512a9592500c7fb570fea733d3591f">More...</a><br /></td></tr>
<tr class="separator:a7b512a9592500c7fb570fea733d3591f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6d3a5c3a62ba42651c654bac998b69e"><td class="memTemplParams" colspan="2">template&lt;typename... OpTypes&gt; </td></tr>
<tr class="memitem:ab6d3a5c3a62ba42651c654bac998b69e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#ab6d3a5c3a62ba42651c654bac998b69e">insertVectorizationPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patternList, <a class="el" href="structmlir_1_1linalg_1_1LinalgVectorizationOptions.html">linalg::LinalgVectorizationOptions</a> <a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>, <a class="el" href="structmlir_1_1linalg_1_1LinalgTransformationFilter.html">linalg::LinalgTransformationFilter</a> f=<a class="el" href="structmlir_1_1linalg_1_1LinalgTransformationFilter.html">linalg::LinalgTransformationFilter</a>())</td></tr>
<tr class="memdesc:ab6d3a5c3a62ba42651c654bac998b69e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variadic helper function to insert vectorization patterns for C++ ops.  <a href="#ab6d3a5c3a62ba42651c654bac998b69e">More...</a><br /></td></tr>
<tr class="separator:ab6d3a5c3a62ba42651c654bac998b69e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60cd962332e381639e396c646c82eb14"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a60cd962332e381639e396c646c82eb14">populateLinalgNamedOpsGeneralizationPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns, <a class="el" href="structmlir_1_1linalg_1_1LinalgTransformationFilter.html">LinalgTransformationFilter</a> filter=<a class="el" href="structmlir_1_1linalg_1_1LinalgTransformationFilter.html">LinalgTransformationFilter</a>())</td></tr>
<tr class="memdesc:a60cd962332e381639e396c646c82eb14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Linalg generalization patterns.  <a href="#a60cd962332e381639e396c646c82eb14">More...</a><br /></td></tr>
<tr class="separator:a60cd962332e381639e396c646c82eb14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c0dd1ffad2bc016481940518f493587"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a7c0dd1ffad2bc016481940518f493587">populateDecomposeConvolutionPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns, <a class="el" href="structmlir_1_1linalg_1_1LinalgTransformationFilter.html">LinalgTransformationFilter</a> filter=<a class="el" href="structmlir_1_1linalg_1_1LinalgTransformationFilter.html">LinalgTransformationFilter</a>(), <a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a> benefit=1)</td></tr>
<tr class="memdesc:a7c0dd1ffad2bc016481940518f493587"><td class="mdescLeft">&#160;</td><td class="mdescRight">Linalg decompose convolutions patterns.  <a href="#a7c0dd1ffad2bc016481940518f493587">More...</a><br /></td></tr>
<tr class="separator:a7c0dd1ffad2bc016481940518f493587"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bc8eeefb74502116e8a8a57d48369a5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a7bc8eeefb74502116e8a8a57d48369a5">populateLinalgDistributeTiledLoopPattern</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns, const <a class="el" href="structmlir_1_1linalg_1_1LinalgLoopDistributionOptions.html">LinalgLoopDistributionOptions</a> &amp;opts, const <a class="el" href="structmlir_1_1linalg_1_1LinalgTransformationFilter.html">LinalgTransformationFilter</a> &amp;marker)</td></tr>
<tr class="memdesc:a7bc8eeefb74502116e8a8a57d48369a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Linalg distribution patterns.  <a href="#a7bc8eeefb74502116e8a8a57d48369a5">More...</a><br /></td></tr>
<tr class="separator:a7bc8eeefb74502116e8a8a57d48369a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ec52ae2f00aed30bf2c0f20f019f6d2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a7ec52ae2f00aed30bf2c0f20f019f6d2">rewriteAsPaddedOp</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, LinalgOp opToPad, const <a class="el" href="namespacemlir_1_1linalg.html#a035c53b6c522327cbc4e96070564738a">PaddingValueComputationFunction</a> &amp;paddingFunc, const <a class="el" href="namespacemlir_1_1linalg.html#a96e2c72347bd9cc278b81c22fe13d35b">PaddingNoFoldComputationFunction</a> &amp;nofoldFunc, LinalgOp &amp;paddedOp)</td></tr>
<tr class="memdesc:a7ec52ae2f00aed30bf2c0f20f019f6d2"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structmlir_1_1linalg_1_1Pad.html" title="Represent one application of LinalgStrategyPadPass. ">Pad</a> the operands of <code>opToPad</code> to a static bounding box.  <a href="#a7ec52ae2f00aed30bf2c0f20f019f6d2">More...</a><br /></td></tr>
<tr class="separator:a7ec52ae2f00aed30bf2c0f20f019f6d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d99ec53d8d90c200b932f59c1633742"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a1d99ec53d8d90c200b932f59c1633742">populatePadTensorOpVectorizationPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns, <a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a> baseBenefit=1)</td></tr>
<tr class="memdesc:a1d99ec53d8d90c200b932f59c1633742"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates <code>patterns</code> with patterns that vectorize linalg.pad_tensor.  <a href="#a1d99ec53d8d90c200b932f59c1633742">More...</a><br /></td></tr>
<tr class="separator:a1d99ec53d8d90c200b932f59c1633742"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1f9f35146d8a5665c3960ce54d8fc74"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#ae1f9f35146d8a5665c3960ce54d8fc74">peelAndCanonicalizeTiledLoop</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, TiledLoopOp loopOp, int64_t idx, TiledLoopOp &amp;result)</td></tr>
<tr class="memdesc:ae1f9f35146d8a5665c3960ce54d8fc74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrite a TiledLoopOp with bounds/step that potentially do not divide evenly into a TiledLoopOp where the step divides the iteration space evenly, followed by another TiledLoopOp for the last (partial) iteration (if any).  <a href="#ae1f9f35146d8a5665c3960ce54d8fc74">More...</a><br /></td></tr>
<tr class="separator:ae1f9f35146d8a5665c3960ce54d8fc74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3b1b3bc58506cfc9153a49ab178cd38"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#ad3b1b3bc58506cfc9153a49ab178cd38">applyStagedPatterns</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1FrozenRewritePatternSet.html">FrozenRewritePatternSet</a> &gt; stage1Patterns, const <a class="el" href="classmlir_1_1FrozenRewritePatternSet.html">FrozenRewritePatternSet</a> &amp;stage2Patterns, <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>(<a class="el" href="classmlir_1_1Operation.html">Operation</a> *)&gt; stage3Lambda=nullptr)</td></tr>
<tr class="memdesc:ad3b1b3bc58506cfc9153a49ab178cd38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to allow applying rewrite patterns, interleaved with more global transformations, in a staged fashion:  <a href="#ad3b1b3bc58506cfc9153a49ab178cd38">More...</a><br /></td></tr>
<tr class="separator:ad3b1b3bc58506cfc9153a49ab178cd38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2af55e6383d5f7c643803c91f06d33e9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a2af55e6383d5f7c643803c91f06d33e9">isPermutation</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; permutation)</td></tr>
<tr class="memdesc:a2af55e6383d5f7c643803c91f06d33e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if <code>permutation</code> is a permutation of the range <code>[0, permutation.size())</code>.  <a href="#a2af55e6383d5f7c643803c91f06d33e9">More...</a><br /></td></tr>
<tr class="separator:a2af55e6383d5f7c643803c91f06d33e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19b1bb012cc125a3bc839bc839be5411"><td class="memTemplParams" colspan="2">template&lt;typename T , unsigned N&gt; </td></tr>
<tr class="memitem:a19b1bb012cc125a3bc839bc839be5411"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a19b1bb012cc125a3bc839bc839be5411">applyPermutationToVector</a> (<a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; T, N &gt; &amp;inVec, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; permutation)</td></tr>
<tr class="memdesc:a19b1bb012cc125a3bc839bc839be5411"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the permutation defined by <code>permutation</code> to <code>inVec</code>.  <a href="#a19b1bb012cc125a3bc839bc839be5411">More...</a><br /></td></tr>
<tr class="separator:a19b1bb012cc125a3bc839bc839be5411"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4f0310fab99c4db7d336dd602f56d1c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#ab4f0310fab99c4db7d336dd602f56d1c">createOrFoldDimOp</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Value.html">Value</a> source, int64_t dim)</td></tr>
<tr class="memdesc:ab4f0310fab99c4db7d336dd602f56d1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function that creates a memref::DimOp or tensor::DimOp depending on the type of <code>source</code>.  <a href="#ab4f0310fab99c4db7d336dd602f56d1c">More...</a><br /></td></tr>
<tr class="separator:ab4f0310fab99c4db7d336dd602f56d1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a756a0c2f5771e052c3d9f2b0dad15525"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a>, 4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a756a0c2f5771e052c3d9f2b0dad15525">getDynOperands</a> (<a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Value.html">Value</a> val, <a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b)</td></tr>
<tr class="memdesc:a756a0c2f5771e052c3d9f2b0dad15525"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an operation, retrieves the value of each dynamic dimension through constructing the necessary DimOp operators.  <a href="#a756a0c2f5771e052c3d9f2b0dad15525">More...</a><br /></td></tr>
<tr class="separator:a756a0c2f5771e052c3d9f2b0dad15525"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37b23c37eb6e528b8fc682d257680d8d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a37b23c37eb6e528b8fc682d257680d8d">getUpperBoundForIndex</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> <a class="el" href="InterfaceSupport_8h.html#a53ed1830bfcbea42b0e7b10281e03865">value</a>, <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &amp;boundMap, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;boundOperands)</td></tr>
<tr class="memdesc:a37b23c37eb6e528b8fc682d257680d8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes an upper bound for the result <code>value</code> of an index computation.  <a href="#a37b23c37eb6e528b8fc682d257680d8d">More...</a><br /></td></tr>
<tr class="separator:a37b23c37eb6e528b8fc682d257680d8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae14dff721dc992372b22b28ef1884ec3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#ae14dff721dc992372b22b28ef1884ec3">getConstantUpperBoundForIndex</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> <a class="el" href="InterfaceSupport_8h.html#a53ed1830bfcbea42b0e7b10281e03865">value</a>)</td></tr>
<tr class="memdesc:ae14dff721dc992372b22b28ef1884ec3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant upper bound for the result <code>value</code> of an index computation.  <a href="#ae14dff721dc992372b22b28ef1884ec3">More...</a><br /></td></tr>
<tr class="separator:ae14dff721dc992372b22b28ef1884ec3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae95c286789e27b94eadba9558405bee"><td class="memItemLeft" align="right" valign="top">tensor::ExtractSliceOp&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#aae95c286789e27b94eadba9558405bee">makeComposedExtractSliceOp</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Value.html">Value</a> source, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; offsets, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; sizes, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; strides)</td></tr>
<tr class="memdesc:aae95c286789e27b94eadba9558405bee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an ExtractSliceOp and, if <code>source</code> is defined by an ExtractSliceOp, fold it by adding the offsets.  <a href="#aae95c286789e27b94eadba9558405bee">More...</a><br /></td></tr>
<tr class="separator:aae95c286789e27b94eadba9558405bee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9edcaadd998bad20bfb048ad9570c93"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#aa9edcaadd998bad20bfb048ad9570c93">makeComposedPadHighOp</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, RankedTensorType type, <a class="el" href="classmlir_1_1Value.html">Value</a> source, <a class="el" href="classmlir_1_1Value.html">Value</a> pad, bool nofold)</td></tr>
<tr class="memdesc:aa9edcaadd998bad20bfb048ad9570c93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a PadTensorOp that pads <code>source</code> to the size of the statically sized <code>type</code> whose static sizes are assumed to be greater than the dynamic <code>source</code> size.  <a href="#aa9edcaadd998bad20bfb048ad9570c93">More...</a><br /></td></tr>
<tr class="separator:aa9edcaadd998bad20bfb048ad9570c93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a2959f54ccc7cabc35c9337f50c0734"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a1a2959f54ccc7cabc35c9337f50c0734">isProducerLastWriteOfView</a> (const <a class="el" href="classmlir_1_1linalg_1_1LinalgDependenceGraph.html">LinalgDependenceGraph</a> &amp;graph, LinalgOp consumer, <a class="el" href="classmlir_1_1Value.html">Value</a> consumedView, LinalgOp producer)</td></tr>
<tr class="memdesc:a1a2959f54ccc7cabc35c9337f50c0734"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the specific <code>producer</code> is the last write to exactly the whole <code>consumedView</code>.  <a href="#a1a2959f54ccc7cabc35c9337f50c0734">More...</a><br /></td></tr>
<tr class="separator:a1a2959f54ccc7cabc35c9337f50c0734"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bf6605778cf3f93537f2bc2e58da089"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a6bf6605778cf3f93537f2bc2e58da089">isFusableInto</a> (const <a class="el" href="classmlir_1_1linalg_1_1LinalgDependenceGraph.html">LinalgDependenceGraph</a> &amp;graph, LinalgOp consumer, <a class="el" href="classmlir_1_1Value.html">Value</a> consumedView, LinalgOp producer)</td></tr>
<tr class="memdesc:a6bf6605778cf3f93537f2bc2e58da089"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether fusing the specific <code>producer</code> of the <code>consumedView</code> is feasible.  <a href="#a6bf6605778cf3f93537f2bc2e58da089">More...</a><br /></td></tr>
<tr class="separator:a6bf6605778cf3f93537f2bc2e58da089"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f1e20eaab30a94f36bfc76893f7199b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a7f1e20eaab30a94f36bfc76893f7199b">computeTileOffsets</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> ivs, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> tileSizes)</td></tr>
<tr class="memdesc:a7f1e20eaab30a94f36bfc76893f7199b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute tile offsets, given a list of loop <code>ivs</code> and <code>tileSizes</code>.  <a href="#a7f1e20eaab30a94f36bfc76893f7199b">More...</a><br /></td></tr>
<tr class="separator:a7f1e20eaab30a94f36bfc76893f7199b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad316c017a79db35cf486ca98aa4b9560"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#ad316c017a79db35cf486ca98aa4b9560">computeTileSizes</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> ivs, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> tileSizes, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; sizeBounds)</td></tr>
<tr class="memdesc:ad316c017a79db35cf486ca98aa4b9560"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute tile sizes, given a list of loop <code>ivs</code>, <code>tileSizes</code> and dimension sizes (<code>sizeBounds</code>).  <a href="#ad316c017a79db35cf486ca98aa4b9560">More...</a><br /></td></tr>
<tr class="separator:ad316c017a79db35cf486ca98aa4b9560"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a625c1d98cff00c9d77d2efc29d597bda"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a625c1d98cff00c9d77d2efc29d597bda">makeTiledShape</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Value.html">Value</a> valueToTile, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> tileSizes, <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> map, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> lbs, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> ubs, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> subShapeSizes)</td></tr>
<tr class="memdesc:a625c1d98cff00c9d77d2efc29d597bda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an extract_slice/subview op for a single <code>valueToTile</code> with <code>builder</code>.  <a href="#a625c1d98cff00c9d77d2efc29d597bda">More...</a><br /></td></tr>
<tr class="separator:a625c1d98cff00c9d77d2efc29d597bda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77f6409a20cf9ca1db0996f6f3dd4f53"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a>, 4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a77f6409a20cf9ca1db0996f6f3dd4f53">makeTiledShapes</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, LinalgOp linalgOp, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; valuesToTile, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> ivs, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> tileSizes, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; sizeBounds)</td></tr>
<tr class="memdesc:a77f6409a20cf9ca1db0996f6f3dd4f53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates extract_slice/subview ops for all <code>valuesToTile</code> of the given <code>linalgOp</code> with <code>builder</code>, assuming <code>linalgOp</code> is being fused into a loop nest for tiling with the given induction variables <code>ivs</code> and tile sizes <code>tileSizes</code>.  <a href="#a77f6409a20cf9ca1db0996f6f3dd4f53">More...</a><br /></td></tr>
<tr class="separator:a77f6409a20cf9ca1db0996f6f3dd4f53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add0783ce371beb4ea9e8af9f35578d92"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#add0783ce371beb4ea9e8af9f35578d92">addTileLoopIvsToIndexOpResults</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, LinalgOp tiledOp, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; ivs)</td></tr>
<tr class="memdesc:add0783ce371beb4ea9e8af9f35578d92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add the tile loop induction variables <code>ivs</code> to the IndexOp results found in the body of the <code>tiledOp</code> to account for the tile offset.  <a href="#add0783ce371beb4ea9e8af9f35578d92">More...</a><br /></td></tr>
<tr class="separator:add0783ce371beb4ea9e8af9f35578d92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13ad74083992ed8c5b3e804e513bdd29"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemlir_1_1linalg.html#aed2c8e52c82709202bade005c0609f77">FusableOpDependencesTy</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a13ad74083992ed8c5b3e804e513bdd29">findAllFusableDependences</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; LinalgOp &gt; ops, const <a class="el" href="classmlir_1_1linalg_1_1LinalgDependenceGraph.html">LinalgDependenceGraph</a> &amp;dependenceGraph)</td></tr>
<tr class="memdesc:a13ad74083992ed8c5b3e804e513bdd29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find all dependences that are fusable.  <a href="#a13ad74083992ed8c5b3e804e513bdd29">More...</a><br /></td></tr>
<tr class="separator:a13ad74083992ed8c5b3e804e513bdd29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac672c972a368ddbac2083e6cdfc9b5fc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; <a class="el" href="structmlir_1_1linalg_1_1FusionInfo.html">FusionInfo</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#ac672c972a368ddbac2083e6cdfc9b5fc">fuseProducerOfBuffer</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> &amp;consumerOpOperand, const <a class="el" href="classmlir_1_1linalg_1_1LinalgDependenceGraph.html">LinalgDependenceGraph</a> &amp;graph)</td></tr>
<tr class="memdesc:ac672c972a368ddbac2083e6cdfc9b5fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fuses producer into consumer if the producer is structurally feasible and the fusion would not violate dependencies.  <a href="#ac672c972a368ddbac2083e6cdfc9b5fc">More...</a><br /></td></tr>
<tr class="separator:ac672c972a368ddbac2083e6cdfc9b5fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13c5cf1a47f0bf5b6405224845ff8d83"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; <a class="el" href="structmlir_1_1linalg_1_1FusionInfo.html">FusionInfo</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a13c5cf1a47f0bf5b6405224845ff8d83">fuseProducerOfTensor</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> &amp;consumerOpOperand)</td></tr>
<tr class="memdesc:a13c5cf1a47f0bf5b6405224845ff8d83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tensor counterpart of <code>fuseProducerOfBuffer</code>.  <a href="#a13c5cf1a47f0bf5b6405224845ff8d83">More...</a><br /></td></tr>
<tr class="separator:a13c5cf1a47f0bf5b6405224845ff8d83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7195637d33a1cf8133bc32a219adf6b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; <a class="el" href="structmlir_1_1linalg_1_1FusionInfo.html">FusionInfo</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#aa7195637d33a1cf8133bc32a219adf6b">fuseProducerOfTensor</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1OpResult.html">OpResult</a> producerOpResult, <a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> &amp;consumerOpOperand)</td></tr>
<tr class="memdesc:aa7195637d33a1cf8133bc32a219adf6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tensor counterpart of <code>fuseProducerOfBuffer</code>.  <a href="#aa7195637d33a1cf8133bc32a219adf6b">More...</a><br /></td></tr>
<tr class="separator:aa7195637d33a1cf8133bc32a219adf6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00668a5d2c737d9304a098899567bd4a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; <a class="el" href="classmlir_1_1linalg_1_1TileLoopNest.html">TileLoopNest</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a00668a5d2c737d9304a098899567bd4a">tileConsumerAndFuseProducers</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, LinalgOp consumerOp, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; tileSizes, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; tileInterchange)</td></tr>
<tr class="memdesc:a00668a5d2c737d9304a098899567bd4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tiles <code>consumerOp</code> and fuses its dependencies if possible.  <a href="#a00668a5d2c737d9304a098899567bd4a">More...</a><br /></td></tr>
<tr class="separator:a00668a5d2c737d9304a098899567bd4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb173d5edf56a08ed3610924312dd364"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#aeb173d5edf56a08ed3610924312dd364">updateBoundsForCyclicDistribution</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Value.html">Value</a> procId, <a class="el" href="classmlir_1_1Value.html">Value</a> nprocs, <a class="el" href="classmlir_1_1Value.html">Value</a> &amp;lb, <a class="el" href="classmlir_1_1Value.html">Value</a> &amp;ub, <a class="el" href="classmlir_1_1Value.html">Value</a> &amp;step)</td></tr>
<tr class="memdesc:aeb173d5edf56a08ed3610924312dd364"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the <code>lb</code>, <code>ub</code> and <code>step</code> to get per processor <code>lb</code>, <code>ub</code> and <code>step</code>.  <a href="#aeb173d5edf56a08ed3610924312dd364">More...</a><br /></td></tr>
<tr class="separator:aeb173d5edf56a08ed3610924312dd364"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e61b04f528d6ebbe05496f4d6ea4a0e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a1e61b04f528d6ebbe05496f4d6ea4a0e">generateParallelLoopNest</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> lbs, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> ubs, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> steps, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt; iteratorTypes, <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="classvoid.html">void</a>(<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;, <a class="el" href="classmlir_1_1Location.html">Location</a>, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>)&gt; bodyBuilderFn, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;ivStorage, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="namespacemlir_1_1linalg.html#a7382d59369873eb3a9a9ddd571056982">DistributionMethod</a> &gt; distributionMethod={})</td></tr>
<tr class="memdesc:a1e61b04f528d6ebbe05496f4d6ea4a0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a loop nest consisting of scf.parallel and scf.for, depending on the `iteratorTypes.  <a href="#a1e61b04f528d6ebbe05496f4d6ea4a0e">More...</a><br /></td></tr>
<tr class="separator:a1e61b04f528d6ebbe05496f4d6ea4a0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecfe567e2b9c460d7be8232a83c1417e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#aecfe567e2b9c460d7be8232a83c1417e">fullyComposeAndAffineApply</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> expr, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> operands)</td></tr>
<tr class="separator:aecfe567e2b9c460d7be8232a83c1417e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a15f98a29e8d8529d00b3b406f009767e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15f98a29e8d8529d00b3b406f009767e">&#9670;&nbsp;</a></span>AllocBufferCallbackFn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir_1_1linalg.html#a15f98a29e8d8529d00b3b406f009767e">mlir::linalg::AllocBufferCallbackFn</a> = typedef std::function&lt;<a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt;<a class="el" href="classmlir_1_1Value.html">Value</a>&gt;( <a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, memref::SubViewOp subView, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt;<a class="el" href="classmlir_1_1Value.html">Value</a>&gt; boundingSubViewSize, <a class="el" href="classmlir_1_1DataLayout.html">DataLayout</a> &amp;layout)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback function type used to perform the allocation for the promoted <code>subView</code>. </p>
<p>In <code>boundingSubViewsize</code> a best attempt is made to find the smallest constant value for the size of the buffer needed for each dimension. If that is not possible, contains the dynamic size of the subview. The call back should return the buffer to use. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l00258">258</a> of file <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8h_source.html">Transforms.h</a>.</p>

</div>
</div>
<a id="a7f0c7d5683991009cfddd7748b7f8d4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f0c7d5683991009cfddd7748b7f8d4d">&#9670;&nbsp;</a></span>ControlElementwiseOpsFusionFn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir_1_1linalg.html#a7f0c7d5683991009cfddd7748b7f8d4d">mlir::linalg::ControlElementwiseOpsFusionFn</a> = typedef std::function&lt;bool(const <a class="el" href="classmlir_1_1OpResult.html">OpResult</a> &amp;producer, <a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> &amp;consumer)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function type which is used to control when to stop fusion. </p>
<p>It is expected that <a class="el" href="classmlir_1_1OpOperand.html" title="This class represents an operand of an operation. ">OpOperand</a> is not modified in the callback. The <a class="el" href="classmlir_1_1OpOperand.html" title="This class represents an operand of an operation. ">OpOperand</a> is not marked as const to allow callers to use non-const methods. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l00066">66</a> of file <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8h_source.html">Transforms.h</a>.</p>

</div>
</div>
<a id="aa49994e2aab61b35167972384684cf24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa49994e2aab61b35167972384684cf24">&#9670;&nbsp;</a></span>CopyCallbackFn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir_1_1linalg.html#aa49994e2aab61b35167972384684cf24">mlir::linalg::CopyCallbackFn</a> = typedef std::function&lt;<a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>(<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Value.html">Value</a> src, <a class="el" href="classmlir_1_1Value.html">Value</a> dst)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback function type used to insert copy from original subview to subview of the promoted region for the read operands/subview of promoted region to original subview for the results. </p>
<p>The copy has to happen from <code>src</code> to <code>dst</code>. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l00270">270</a> of file <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8h_source.html">Transforms.h</a>.</p>

</div>
</div>
<a id="a3d7afb284c4be072a74a24eeb71cc985"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d7afb284c4be072a74a24eeb71cc985">&#9670;&nbsp;</a></span>DeallocBufferCallbackFn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir_1_1linalg.html#a3d7afb284c4be072a74a24eeb71cc985">mlir::linalg::DeallocBufferCallbackFn</a> = typedef std::function&lt;<a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>(<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Value.html">Value</a> buffer)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback function type used to deallocate the buffers used to hold the promoted subview. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l00263">263</a> of file <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8h_source.html">Transforms.h</a>.</p>

</div>
</div>
<a id="a4ba4b4e6dc3c816c9b069a2c40c97420"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ba4b4e6dc3c816c9b069a2c40c97420">&#9670;&nbsp;</a></span>detect_has_get_operation_name</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir_1_1linalg.html#a4ba4b4e6dc3c816c9b069a2c40c97420">mlir::linalg::detect_has_get_operation_name</a> = typedef llvm::is_detected&lt;<a class="el" href="namespacemlir_1_1linalg.html#a54b1e68a26156715923bbc38afddff82">has_get_operation_name</a>, T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l01069">1069</a> of file <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8h_source.html">Transforms.h</a>.</p>

</div>
</div>
<a id="aed2c8e52c82709202bade005c0609f77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed2c8e52c82709202bade005c0609f77">&#9670;&nbsp;</a></span>FusableOpDependencesTy</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir_1_1linalg.html#aed2c8e52c82709202bade005c0609f77">mlir::linalg::FusableOpDependencesTy</a> = typedef llvm::MapVector&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;<a class="el" href="structmlir_1_1linalg_1_1LinalgDependenceGraph_1_1LinalgDependenceGraphElem.html">LinalgDependenceGraph::LinalgDependenceGraphElem</a>, 1&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8h_source.html#l00199">199</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8h_source.html">Utils.h</a>.</p>

</div>
</div>
<a id="a54b1e68a26156715923bbc38afddff82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54b1e68a26156715923bbc38afddff82">&#9670;&nbsp;</a></span>has_get_operation_name</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir_1_1linalg.html#a54b1e68a26156715923bbc38afddff82">mlir::linalg::has_get_operation_name</a> = typedef decltype(T::getOperationName())</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Trait to check if T provides a <code>getOperationName</code> method. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l01066">1066</a> of file <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8h_source.html">Transforms.h</a>.</p>

</div>
</div>
<a id="a4a9ca79033211e3e53e0eb25a8e9551b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a9ca79033211e3e53e0eb25a8e9551b">&#9670;&nbsp;</a></span>LinalgLoops</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir_1_1linalg.html#a4a9ca79033211e3e53e0eb25a8e9551b">mlir::linalg::LinalgLoops</a> = typedef <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;<a class="el" href="classmlir_1_1Operation.html">Operation</a> *, 4&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l00045">45</a> of file <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8h_source.html">Transforms.h</a>.</p>

</div>
</div>
<a id="a949f3c7a426d9e0cfec01467631f8037"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a949f3c7a426d9e0cfec01467631f8037">&#9670;&nbsp;</a></span>LoopRangeBuilder</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir_1_1linalg.html#a949f3c7a426d9e0cfec01467631f8037">mlir::linalg::LoopRangeBuilder</a> = typedef std::function&lt;<a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;<a class="el" href="structmlir_1_1Range.html">Range</a>, 4&gt;(<a class="el" href="classmlir_1_1ImplicitLocOpBuilder.html">ImplicitLocOpBuilder</a>)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="LinalgOps_8h_source.html#l00042">42</a> of file <a class="el" href="LinalgOps_8h_source.html">LinalgOps.h</a>.</p>

</div>
</div>
<a id="a43919709cf99a429d1b9e995f6cb555e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43919709cf99a429d1b9e995f6cb555e">&#9670;&nbsp;</a></span>OneDimProcInfoCallBackFn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir_1_1linalg.html#a43919709cf99a429d1b9e995f6cb555e">mlir::linalg::OneDimProcInfoCallBackFn</a> = typedef std::function&lt;<a class="el" href="structmlir_1_1linalg_1_1ProcInfo.html">ProcInfo</a>(<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Location.html">Location</a> loc)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8h_source.html#l00358">358</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8h_source.html">Utils.h</a>.</p>

</div>
</div>
<a id="a7f14b7de232347900daf39a27a2725b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f14b7de232347900daf39a27a2725b1">&#9670;&nbsp;</a></span>OptimizeCopyFn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir_1_1linalg.html#a7f14b7de232347900daf39a27a2725b1">mlir::linalg::OptimizeCopyFn</a> = typedef std::function&lt;<a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>(<a class="el" href="classmlir_1_1PatternRewriter.html">PatternRewriter</a> &amp;, PadTensorOp, <a class="el" href="classmlir_1_1Value.html">Value</a>)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l01217">1217</a> of file <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8h_source.html">Transforms.h</a>.</p>

</div>
</div>
<a id="afaf3af3f2e3d6690f81118bf194fb0a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afaf3af3f2e3d6690f81118bf194fb0a4">&#9670;&nbsp;</a></span>PaddingHoistComputationFunction</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir_1_1linalg.html#afaf3af3f2e3d6690f81118bf194fb0a4">mlir::linalg::PaddingHoistComputationFunction</a> = typedef std::function&lt;int64_t(<a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> &amp;)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback returning the number of loops to hoist the pad tensor operation defining the given <a class="el" href="classmlir_1_1OpOperand.html" title="This class represents an operand of an operation. ">OpOperand</a>. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l00479">479</a> of file <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8h_source.html">Transforms.h</a>.</p>

</div>
</div>
<a id="a96e2c72347bd9cc278b81c22fe13d35b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96e2c72347bd9cc278b81c22fe13d35b">&#9670;&nbsp;</a></span>PaddingNoFoldComputationFunction</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir_1_1linalg.html#a96e2c72347bd9cc278b81c22fe13d35b">mlir::linalg::PaddingNoFoldComputationFunction</a> = typedef std::function&lt;bool(<a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> &amp;)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback returning true if the pad tensor operation defining the given <a class="el" href="classmlir_1_1OpOperand.html" title="This class represents an operand of an operation. ">OpOperand</a> shall be marked as nofold to enable packing. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l00475">475</a> of file <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8h_source.html">Transforms.h</a>.</p>

</div>
</div>
<a id="a035c53b6c522327cbc4e96070564738a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a035c53b6c522327cbc4e96070564738a">&#9670;&nbsp;</a></span>PaddingValueComputationFunction</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir_1_1linalg.html#a035c53b6c522327cbc4e96070564738a">mlir::linalg::PaddingValueComputationFunction</a> = typedef std::function&lt;<a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt;<a class="el" href="classmlir_1_1Value.html">Value</a>&gt;(<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;, <a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> &amp;)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback returning the padding value to use for a given <a class="el" href="classmlir_1_1OpOperand.html" title="This class represents an operand of an operation. ">OpOperand</a> or failure for no padding. </p>
<p>This should be a function of both the operation and the operand type. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l00471">471</a> of file <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8h_source.html">Transforms.h</a>.</p>

</div>
</div>
<a id="a60a0b220b224fc8b91b37ee63b95a12f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60a0b220b224fc8b91b37ee63b95a12f">&#9670;&nbsp;</a></span>ProcInfoCallBackFn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir_1_1linalg.html#a60a0b220b224fc8b91b37ee63b95a12f">mlir::linalg::ProcInfoCallBackFn</a> = typedef std::function&lt;<a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;<a class="el" href="structmlir_1_1linalg_1_1ProcInfo.html">ProcInfo</a>, 2&gt;( <a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt;<a class="el" href="structmlir_1_1Range.html">Range</a>&gt; parallelLoopRanges)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8h_source.html#l00356">356</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8h_source.html">Utils.h</a>.</p>

</div>
</div>
<a id="a730df0415b8172eb93f8f7b346e04440"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a730df0415b8172eb93f8f7b346e04440">&#9670;&nbsp;</a></span>TileSizeComputationFunction</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir_1_1linalg.html#a730df0415b8172eb93f8f7b346e04440">mlir::linalg::TileSizeComputationFunction</a> = typedef std::function&lt;<a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;<a class="el" href="classmlir_1_1Value.html">Value</a>, 4&gt;(<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l00465">465</a> of file <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8h_source.html">Transforms.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a7382d59369873eb3a9a9ddd571056982"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7382d59369873eb3a9a9ddd571056982">&#9670;&nbsp;</a></span>DistributionMethod</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacemlir_1_1linalg.html#a7382d59369873eb3a9a9ddd571056982">mlir::linalg::DistributionMethod</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scheme used to distribute loops to processors. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a7382d59369873eb3a9a9ddd571056982ad71670d62b238eaf063979407361034e"></a>Cyclic&#160;</td><td class="fielddoc"><p>Cyclic distribution where no assumption is made about the dynamic relationship between number of processors and number of iterations of the distributed loop. </p>
<p>Distributes the following loop</p>
<p>scf.parallel (iv) = (lb) to (ub) step (step)</p>
<p>to</p>
<p>scf.parallel(iv)= (lb + procId * step) to (ub) step (step * nprocs) </p>
</td></tr>
<tr><td class="fieldname"><a id="a7382d59369873eb3a9a9ddd571056982abab54876ff518ecd2d59b46fd3be9c0e"></a>CyclicNumProcsGeNumIters&#160;</td><td class="fielddoc"><p>Cyclic distribution where the number of processors can be assumed to be more than or equal to the number of iterations of the distributed loop. </p>
<p>In such cases, a simple in-bounds check is enough (instead of materializing a loop). Distributes the following loop</p>
<p>scf.parallel (iv) = (lb) to (ub) step (step)</p>
<p>to</p>
<p>iv = lb + procId * step cond = arith.cmpi "slt", iv, ub scf.if cond { ... } </p>
</td></tr>
<tr><td class="fieldname"><a id="a7382d59369873eb3a9a9ddd571056982ad93606014b9a6b479ba0e6faa948540b"></a>CyclicNumProcsEqNumIters&#160;</td><td class="fielddoc"><p>Cyclic distribution where the number of processors can be assumed to be equal to the number of iterations of the distributed loop. </p>
<p>In such cases, no bounds check is needed. Distributes the following loop</p>
<p>scf.parallel (iv) = (lb) to (ub) step (step)</p>
<p>to</p>
<p>iv = lb + procId * step </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8h_source.html#l00309">309</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8h_source.html">Utils.h</a>.</p>

</div>
</div>
<a id="a98153087b663d0d7aa3ab0685cfaedaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98153087b663d0d7aa3ab0685cfaedaf">&#9670;&nbsp;</a></span>LinalgLoweringType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacemlir_1_1linalg.html#a98153087b663d0d7aa3ab0685cfaedaf">mlir::linalg::LinalgLoweringType</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Linalg lowering patterns. </p>
<p>Apply the <code>linalgLowerOpToLoops</code> transformation as a pattern. <code>filter</code> controls LinalgTransformMarker matching and update when specified. See <code>linalgLowerOpToLoops</code> for more details. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a98153087b663d0d7aa3ab0685cfaedafaaf6ba7cc968a74a4d611c3ab0148b33c"></a>LibraryCall&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a98153087b663d0d7aa3ab0685cfaedafa4b2257cb98694284507e77f34e73c2d8"></a>Loops&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a98153087b663d0d7aa3ab0685cfaedafa6d8bf0bdeaca5ef4693524bf04c4c877"></a>AffineLoops&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a98153087b663d0d7aa3ab0685cfaedafab92546344b4e3fa9b10c9472795297a7"></a>ParallelLoops&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l01112">1112</a> of file <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8h_source.html">Transforms.h</a>.</p>

</div>
</div>
<a id="a3cdd229e1459c7e6ed2f9c7ee7168325"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cdd229e1459c7e6ed2f9c7ee7168325">&#9670;&nbsp;</a></span>LinalgTilingLoopType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacemlir_1_1linalg.html#a3cdd229e1459c7e6ed2f9c7ee7168325">mlir::linalg::LinalgTilingLoopType</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The type of loops to be generated during tiling. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a3cdd229e1459c7e6ed2f9c7ee7168325a4b2257cb98694284507e77f34e73c2d8"></a>Loops&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a3cdd229e1459c7e6ed2f9c7ee7168325a6d8bf0bdeaca5ef4693524bf04c4c877"></a>AffineLoops&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a3cdd229e1459c7e6ed2f9c7ee7168325ab92546344b4e3fa9b10c9472795297a7"></a>ParallelLoops&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a3cdd229e1459c7e6ed2f9c7ee7168325a695eb12d246fdee4efda9a552f92406e"></a>TiledLoops&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8h_source.html#l00137">137</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8h_source.html">Utils.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="add0783ce371beb4ea9e8af9f35578d92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add0783ce371beb4ea9e8af9f35578d92">&#9670;&nbsp;</a></span>addTileLoopIvsToIndexOpResults()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::linalg::addTileLoopIvsToIndexOpResults </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LinalgOp&#160;</td>
          <td class="paramname"><em>tiledOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td>
          <td class="paramname"><em>ivs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add the tile loop induction variables <code>ivs</code> to the IndexOp results found in the body of the <code>tiledOp</code> to account for the tile offset. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00903">903</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineExpr_8h_source.html#l00328">mlir::bindDims()</a>, <a class="el" href="Builders_8h_source.html#l00054">mlir::Builder::getContext()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00714">mlir::makeComposedAffineApply()</a>, and <a class="el" href="Builders_8h_source.html#l00345">mlir::OpBuilder::setInsertionPointAfter()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Fusion_8cpp_source.html#l00172">fuse()</a>, <a class="el" href="FusionOnTensors_8cpp_source.html#l00128">getTiledProducer()</a>, and <a class="el" href="Tiling_8cpp_source.html#l00130">transformIndexOps()</a>.</p>

</div>
</div>
<a id="a67f3fb54af9cdc66ff265b44a17a5df4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67f3fb54af9cdc66ff265b44a17a5df4">&#9670;&nbsp;</a></span>applyMapToValues()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a>, 4 &gt; mlir::linalg::applyMapToValues </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the values obtained by applying <code>map</code> to the list of values. </p>

<p class="definition">Definition at line <a class="el" href="LinalgInterfaces_8cpp_source.html#l00434">434</a> of file <a class="el" href="LinalgInterfaces_8cpp_source.html">LinalgInterfaces.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="LinalgOps_8cpp_source.html#l01625">getCollapsedOutputDimFromInputShape()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l01676">getExpandedOutputDimFromInputShape()</a>, <a class="el" href="Tiling_8cpp_source.html#l00052">makeTiledLoopRanges()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00719">makeTiledShape()</a>, <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8cpp_source.html#l00135">mlir::linalg::LinalgTilingOptions::scalarizeDynamicDims()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l01039">verify()</a>, and <a class="el" href="LinalgInterfaces_8cpp_source.html#l00527">HasAffineDimExprVisitor::visitSymbolExpr()</a>.</p>

</div>
</div>
<a id="a19b1bb012cc125a3bc839bc839be5411"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19b1bb012cc125a3bc839bc839be5411">&#9670;&nbsp;</a></span>applyPermutationToVector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , unsigned N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::linalg::applyPermutationToVector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>inVec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>permutation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply the permutation defined by <code>permutation</code> to <code>inVec</code>. </p>
<p>Element <code>i</code> in <code>inVec</code> is mapped to location <code>j = permutation[i]</code>. E.g.: for an input vector `inVec = ['a', 'b', 'c']<code>and a permutation vector </code>permutation = [2, 0, 1]<code>, this function leaves</code>inVec = ['c', 'a', 'b']`. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8h_source.html#l00041">41</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8h_source.html">Utils.h</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00160">createOrFoldDimOp()</a>, <a class="el" href="Matchers_8h_source.html#l00206">mlir::detail::enumerate()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00265">getConstantUpperBoundForIndex()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00170">getDynOperands()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00180">getUpperBoundForIndex()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00283">makeComposedExtractSliceOp()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00325">makeComposedPadHighOp()</a>, and <a class="el" href="InterfaceSupport_8h_source.html#l00161">value</a>.</p>

<p class="reference">Referenced by <a class="el" href="Interchange_8cpp_source.html#l00046">interchangeGenericOp()</a>, <a class="el" href="FusionOnTensors_8cpp_source.html#l00409">tileConsumerAndFuseProducers()</a>, and <a class="el" href="Tiling_8cpp_source.html#l00156">tileLinalgOpImpl()</a>.</p>

</div>
</div>
<a id="ad3b1b3bc58506cfc9153a49ab178cd38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3b1b3bc58506cfc9153a49ab178cd38">&#9670;&nbsp;</a></span>applyStagedPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::linalg::applyStagedPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1FrozenRewritePatternSet.html">FrozenRewritePatternSet</a> &gt;&#160;</td>
          <td class="paramname"><em>stage1Patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1FrozenRewritePatternSet.html">FrozenRewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>stage2Patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>(<a class="el" href="classmlir_1_1Operation.html">Operation</a> *)&gt;&#160;</td>
          <td class="paramname"><em>stage3Lambda</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper function to allow applying rewrite patterns, interleaved with more global transformations, in a staged fashion: </p>
<ol type="1">
<li>the first stage consists of a list of <a class="el" href="classmlir_1_1FrozenRewritePatternSet.html" title="This class represents a frozen set of patterns that can be processed by a pattern applicator...">FrozenRewritePatternSet</a>. Each <a class="el" href="classmlir_1_1FrozenRewritePatternSet.html" title="This class represents a frozen set of patterns that can be processed by a pattern applicator...">FrozenRewritePatternSet</a> in this list is applied once, in order.</li>
<li>the second stage consists of a single OwningRewritePattern that is applied greedily until convergence.</li>
<li>the third stage consists of applying a lambda, generally used for non-local transformation effects. This allows creating custom fused transformations where patterns can be ordered and applied at a finer granularity than a sequence of traditional compiler passes. </li>
</ol>

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8cpp_source.html#l00714">714</a> of file <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8cpp_source.html">Transforms.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8cpp_source.html#l00372">mlir::applyPatternsAndFoldGreedily()</a>, <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8cpp_source.html#l00042">DBGS</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">mlir::failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">mlir::success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l01343">mlir::linalg::ConvOpVectorization&lt; ConvOp, N &gt;::ConvOpVectorization()</a>.</p>

</div>
</div>
<a id="a7f1e20eaab30a94f36bfc76893f7199b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f1e20eaab30a94f36bfc76893f7199b">&#9670;&nbsp;</a></span>computeTileOffsets()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; mlir::linalg::computeTileOffsets </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>ivs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>tileSizes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute tile offsets, given a list of loop <code>ivs</code> and <code>tileSizes</code>. </p>
<p>In case a tile size is zero (i.e., no tiling), the corresponding offset is also zero. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00828">828</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8h_source.html#l00424">mlir::OpBuilder::create()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00079">isTiled()</a>, and <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00044">isZero()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00858">makeTiledShapes()</a>, and <a class="el" href="Tiling_8cpp_source.html#l00339">tilePadTensorOp()</a>.</p>

</div>
</div>
<a id="ad316c017a79db35cf486ca98aa4b9560"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad316c017a79db35cf486ca98aa4b9560">&#9670;&nbsp;</a></span>computeTileSizes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; mlir::linalg::computeTileSizes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>ivs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>tileSizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td>
          <td class="paramname"><em>sizeBounds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute tile sizes, given a list of loop <code>ivs</code>, <code>tileSizes</code> and dimension sizes (<code>sizeBounds</code>). </p>
<p>In case a tile size is zero (i.e., no tiling), the corresponding result size is the corresponding value from <code>sizeBounds</code>. Note: The returned tile sizes are closed intervals. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00843">843</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00710">fullyComposeAndAffineApply()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00489">mlir::getAffineDimExpr()</a>, <a class="el" href="Builders_8h_source.html#l00054">mlir::Builder::getContext()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00079">isTiled()</a>, and <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00044">isZero()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00858">makeTiledShapes()</a>, and <a class="el" href="Tiling_8cpp_source.html#l00339">tilePadTensorOp()</a>.</p>

</div>
</div>
<a id="a4f8ea0aae80d24eeffa3fef8f1f08c43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f8ea0aae80d24eeffa3fef8f1f08c43">&#9670;&nbsp;</a></span>concat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>, 4 &gt; mlir::linalg::concat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the vector that is the concatenation of <code>a</code> and <code>b</code>. </p>

<p class="definition">Definition at line <a class="el" href="LinalgOps_8cpp_source.html#l02654">2654</a> of file <a class="el" href="LinalgOps_8cpp_source.html">LinalgOps.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="Simplex_8cpp_source.html#l00664">mlir::Simplex::makeProduct()</a>.</p>

</div>
</div>
<a id="a9f438ad194cd296b83dd3f3b4e68f82e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f438ad194cd296b83dd3f3b4e68f82e">&#9670;&nbsp;</a></span>createLinalgOpOnBuffers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LinalgOp mlir::linalg::createLinalgOpOnBuffers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ConversionPatternRewriter.html">ConversionPatternRewriter</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LinalgOp&#160;</td>
          <td class="paramname"><em>linalgOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>inputs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>outputs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create linalg op on buffers given the original tensor-based operation and the buffers for the outputs. </p>

<p class="definition">Definition at line <a class="el" href="Linalg_2Transforms_2Bufferize_8cpp_source.html#l00082">82</a> of file <a class="el" href="Linalg_2Transforms_2Bufferize_8cpp_source.html">Bufferize.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectConversion_8h_source.html#l00783">mlir::ConversionTarget::addDynamicallyLegalDialect()</a>, <a class="el" href="DialectConversion_8h_source.html#l00711">mlir::ConversionTarget::addDynamicallyLegalOp()</a>, <a class="el" href="DialectConversion_8h_source.html#l00732">mlir::ConversionTarget::addIllegalOp()</a>, <a class="el" href="DialectConversion_8h_source.html#l00770">mlir::ConversionTarget::addLegalDialect()</a>, <a class="el" href="Linalg_2Transforms_2Bufferize_8cpp_source.html#l00039">allocateBuffersForResults()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l03261">mlir::applyPartialConversion()</a>, <a class="el" href="Linalg_2Transforms_2Bufferize_8cpp_source.html#l00030">cloneMemref()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l02939">mlir::TypeConverter::convertType()</a>, <a class="el" href="Builders_8h_source.html#l00424">mlir::OpBuilder::create()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">mlir::failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>, <a class="el" href="Value_8h_source.html#l00119">mlir::Value::getType()</a>, <a class="el" href="DialectConversion_8h_source.html#l00368">mlir::ConversionPattern::getTypeConverter()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l01613">mlir::ConversionPatternRewriter::inlineRegionBefore()</a>, <a class="el" href="Types_8h_source.html#l00234">mlir::Type::isa()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l02995">mlir::TypeConverter::isLegal()</a>, <a class="el" href="DialectConversion_8h_source.html#l00422">mlir::OpConversionPattern&lt; SourceOp &gt;::matchAndRewrite()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l01672">mlir::ConversionPatternRewriter::notifyMatchFailure()</a>, <a class="el" href="Linalg_2Transforms_2Bufferize_8cpp_source.html#l00348">populateLinalgBufferizePatterns()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l01510">mlir::ConversionPatternRewriter::replaceOp()</a>, <a class="el" href="PatternMatch_8h_source.html#l00739">mlir::RewriterBase::replaceOpWithNewOp()</a>, <a class="el" href="LogicalResult_8h_source.html#l00056">mlir::success()</a>, and <a class="el" href="InterfaceSupport_8h_source.html#l00161">value</a>.</p>

</div>
</div>
<a id="ab4f0310fab99c4db7d336dd602f56d1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4f0310fab99c4db7d336dd602f56d1c">&#9670;&nbsp;</a></span>createOrFoldDimOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> mlir::linalg::createOrFoldDimOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>dim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper function that creates a memref::DimOp or tensor::DimOp depending on the type of <code>source</code>. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00160">160</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8h_source.html#l00438">mlir::OpBuilder::createOrFold()</a>, <a class="el" href="Value_8h_source.html#l00119">mlir::Value::getType()</a>, and <a class="el" href="Types_8h_source.html#l00234">mlir::Type::isa()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8h_source.html#l00041">applyPermutationToVector()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l02012">createInBoundsCond()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l02139">createSubViewIntersection()</a>, <a class="el" href="Fusion_8cpp_source.html#l00172">fuse()</a>, <a class="el" href="Sparsification_8cpp_source.html#l00497">genBuffers()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00170">getDynOperands()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00719">makeTiledShape()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l03302">MaterializeTransferMask&lt; ConcreteOp &gt;::matchAndRewrite()</a>, and <a class="el" href="LinalgInterfaces_8cpp_source.html#l00527">HasAffineDimExprVisitor::visitSymbolExpr()</a>.</p>

</div>
</div>
<a id="af9aac538302681e906bd4261c128d90e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9aac538302681e906bd4261c128d90e">&#9670;&nbsp;</a></span>defaultLoopRangesBuilder()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemlir_1_1linalg.html#a949f3c7a426d9e0cfec01467631f8037">LoopRangeBuilder</a> mlir::linalg::defaultLoopRangesBuilder </td>
          <td>(</td>
          <td class="paramtype">LinalgOp&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provide a very simple inference procedure to build the loop ranges from the op and its operands. </p>
<p>This only works with permutation affine maps and patterns of the form <code>(m, n)[s] -&gt; (m + n - s floordiv 2)</code>. A more advanced Tensor-Comprehension like inference is possible but has proven to be ambiguous in unfavorable case. As a consequence, we relax the default behavior very conservatively and provide an op-specified hook so that Linalg ops may override the behavior. </p>

</div>
</div>
<a id="a6ddca37c4e3bf09cb06fc5197380bde3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ddca37c4e3bf09cb06fc5197380bde3">&#9670;&nbsp;</a></span>extractOrIdentityMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> mlir::linalg::extractOrIdentityMap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt;&#160;</td>
          <td class="paramname"><em>maybeMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>maybeMap.get()</code> if <code>maybeMap</code> is set, otherwise returns the symbol-less identity map of <code>rank</code>. </p>

<p class="definition">Definition at line <a class="el" href="LinalgOps_8cpp_source.html#l02634">2634</a> of file <a class="el" href="LinalgOps_8cpp_source.html">LinalgOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="MLIRContext_8cpp_source.html#l00932">mlir::AffineMap::get()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00244">mlir::AffineMap::getMultiDimIdentityMap()</a>.</p>

</div>
</div>
<a id="a13ad74083992ed8c5b3e804e513bdd29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13ad74083992ed8c5b3e804e513bdd29">&#9670;&nbsp;</a></span>findAllFusableDependences()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemlir_1_1linalg.html#aed2c8e52c82709202bade005c0609f77">FusableOpDependencesTy</a> mlir::linalg::findAllFusableDependences </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; LinalgOp &gt;&#160;</td>
          <td class="paramname"><em>ops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1linalg_1_1LinalgDependenceGraph.html">LinalgDependenceGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>dependenceGraph</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find all dependences that are fusable. </p>

<p class="definition">Definition at line <a class="el" href="Fusion_8cpp_source.html#l00722">722</a> of file <a class="el" href="Fusion_8cpp_source.html">Fusion.cpp</a>.</p>

<p class="reference">References <a class="el" href="Fusion_8cpp_source.html#l00335">findFusableProducer()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Fusion_8cpp_source.html#l00875">tileAndFuseLinalgOpsImpl()</a>.</p>

</div>
</div>
<a id="aecfe567e2b9c460d7be8232a83c1417e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecfe567e2b9c460d7be8232a83c1417e">&#9670;&nbsp;</a></span>fullyComposeAndAffineApply()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classmlir_1_1Value.html">Value</a> mlir::linalg::fullyComposeAndAffineApply </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>operands</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00710">710</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineOps_8cpp_source.html#l00853">mlir::canonicalizeMapAndOperands()</a>, <a class="el" href="Builders_8h_source.html#l00438">mlir::OpBuilder::createOrFold()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00705">mlir::fullyComposeAffineMapAndOperands()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00235">mlir::AffineMap::inferFromExprList()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00843">computeTileSizes()</a>, and <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00719">makeTiledShape()</a>.</p>

</div>
</div>
<a id="ac672c972a368ddbac2083e6cdfc9b5fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac672c972a368ddbac2083e6cdfc9b5fc">&#9670;&nbsp;</a></span>fuseProducerOfBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; <a class="el" href="structmlir_1_1linalg_1_1FusionInfo.html">FusionInfo</a> &gt; mlir::linalg::fuseProducerOfBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> &amp;&#160;</td>
          <td class="paramname"><em>consumerOpOperand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1linalg_1_1LinalgDependenceGraph.html">LinalgDependenceGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fuses producer into consumer if the producer is structurally feasible and the fusion would not violate dependencies. </p>
<p>Implements the fusion part of the "tileAndFuse on buffers" transformation and thus requires the <code>consumerOpOperand</code> to be a <code>subview</code> op (generally obtained by applying the tiling transformation). </p>

<p class="definition">Definition at line <a class="el" href="Fusion_8cpp_source.html#l00393">393</a> of file <a class="el" href="Fusion_8cpp_source.html">Fusion.cpp</a>.</p>

<p class="reference">References <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>, <a class="el" href="Fusion_8cpp_source.html#l00335">findFusableProducer()</a>, <a class="el" href="Fusion_8cpp_source.html#l00172">fuse()</a>, <a class="el" href="UseDefLists_8h_source.html#l00133">mlir::IROperand&lt; DerivedT, IRValueT &gt;::get()</a>, <a class="el" href="Value_8cpp_source.html#l00020">mlir::Value::getDefiningOp()</a>, <a class="el" href="UseDefLists_8h_source.html#l00037">mlir::detail::IROperandBase::getOwner()</a>, <a class="el" href="Value_8cpp_source.html#l00048">mlir::Value::getParentBlock()</a>, and <a class="el" href="Builders_8h_source.html#l00331">mlir::OpBuilder::setInsertionPoint()</a>.</p>

</div>
</div>
<a id="a13c5cf1a47f0bf5b6405224845ff8d83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13c5cf1a47f0bf5b6405224845ff8d83">&#9670;&nbsp;</a></span>fuseProducerOfTensor() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; <a class="el" href="structmlir_1_1linalg_1_1FusionInfo.html">FusionInfo</a> &gt; mlir::linalg::fuseProducerOfTensor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> &amp;&#160;</td>
          <td class="paramname"><em>consumerOpOperand</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tensor counterpart of <code>fuseProducerOfBuffer</code>. </p>
<p>This implements the fusion part of the "tileAndFuse on tensors" transformation and thus requires the <code>consumerOpOperand</code> to be a <code>extract_slice</code> op (generally obtained by applying the tiling transformation). </p>

<p class="definition">Definition at line <a class="el" href="Fusion_8cpp_source.html#l00463">463</a> of file <a class="el" href="Fusion_8cpp_source.html">Fusion.cpp</a>.</p>

<p class="reference">References <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>, <a class="el" href="UseDefLists_8h_source.html#l00133">mlir::IROperand&lt; DerivedT, IRValueT &gt;::get()</a>, and <a class="el" href="Fusion_8cpp_source.html#l00438">getProducerOfTensor()</a>.</p>

</div>
</div>
<a id="aa7195637d33a1cf8133bc32a219adf6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7195637d33a1cf8133bc32a219adf6b">&#9670;&nbsp;</a></span>fuseProducerOfTensor() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; <a class="el" href="structmlir_1_1linalg_1_1FusionInfo.html">FusionInfo</a> &gt; mlir::linalg::fuseProducerOfTensor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpResult.html">OpResult</a>&#160;</td>
          <td class="paramname"><em>producerOpResult</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> &amp;&#160;</td>
          <td class="paramname"><em>consumerOpOperand</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tensor counterpart of <code>fuseProducerOfBuffer</code>. </p>
<p>This implements the fusion part of the "tileAndFuse on tensors" transformation and thus requires the <code>consumerOpOperand</code> to be a <code>extract_slice</code> op (generally obtained by applying the tiling transformation). Assumes <code>producerOfTensor</code> is a Linalg op that produces <code>consumerOpOperand</code>. </p>

<p class="definition">Definition at line <a class="el" href="Fusion_8cpp_source.html#l00475">475</a> of file <a class="el" href="Fusion_8cpp_source.html">Fusion.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8h_source.html#l00424">mlir::OpBuilder::create()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>, <a class="el" href="Fusion_8cpp_source.html#l00172">fuse()</a>, <a class="el" href="UseDefLists_8h_source.html#l00133">mlir::IROperand&lt; DerivedT, IRValueT &gt;::get()</a>, <a class="el" href="Value_8cpp_source.html#l00020">mlir::Value::getDefiningOp()</a>, <a class="el" href="UseDefLists_8h_source.html#l00037">mlir::detail::IROperandBase::getOwner()</a>, <a class="el" href="Value_8h_source.html#l00434">mlir::OpResult::getOwner()</a>, <a class="el" href="Value_8cpp_source.html#l00048">mlir::Value::getParentBlock()</a>, <a class="el" href="Value_8h_source.html#l00437">mlir::OpResult::getResultNumber()</a>, <a class="el" href="Value_8h_source.html#l00119">mlir::Value::getType()</a>, <a class="el" href="UseDefLists_8h_source.html#l00136">mlir::IROperand&lt; DerivedT, IRValueT &gt;::set()</a>, and <a class="el" href="Builders_8h_source.html#l00331">mlir::OpBuilder::setInsertionPoint()</a>.</p>

</div>
</div>
<a id="a8554d3163fa39108815d5c8fe971b584"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8554d3163fa39108815d5c8fe971b584">&#9670;&nbsp;</a></span>generalizeNamedOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GenericOp mlir::linalg::generalizeNamedOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1PatternRewriter.html">PatternRewriter</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LinalgOp&#160;</td>
          <td class="paramname"><em>namedOp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a GenericOp from the given named operation <code>namedOp</code>. </p>
<p>Assumes <code>namedOp</code> is not a GenericOp and has a region builder. </p>

<p class="definition">Definition at line <a class="el" href="Generalization_8cpp_source.html#l00043">43</a> of file <a class="el" href="Generalization_8cpp_source.html">Generalization.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8cpp_source.html#l00372">mlir::applyPatternsAndFoldGreedily()</a>, <a class="el" href="Builders_8h_source.html#l00424">mlir::OpBuilder::create()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00338">mlir::RewriterBase::inlineRegionBefore()</a>, and <a class="el" href="Generalization_8cpp_source.html#l00080">populateLinalgNamedOpsGeneralizationPatterns()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8cpp_source.html#l00640">mlir::linalg::LinalgGeneralizationPattern::matchAndRewrite()</a>.</p>

</div>
</div>
<a id="a2f2367adbb110b452ca67b7c33f40e6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f2367adbb110b452ca67b7c33f40e6a">&#9670;&nbsp;</a></span>generalizeNamedOpPrecondition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::linalg::generalizeNamedOpPrecondition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structmlir_1_1linalg_1_1Generalize.html" title="Represent one application of createLinalgStrategyGeneralizePass. ">Generalize</a> named operations to generic operations. </p>

<p class="definition">Definition at line <a class="el" href="Generalization_8cpp_source.html#l00032">32</a> of file <a class="el" href="Generalization_8cpp_source.html">Generalization.cpp</a>.</p>

<p class="reference">References <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">mlir::success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8cpp_source.html#l00640">mlir::linalg::LinalgGeneralizationPattern::matchAndRewrite()</a>.</p>

</div>
</div>
<a id="a754ec5c5960c640563ddcd9727b77d87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a754ec5c5960c640563ddcd9727b77d87">&#9670;&nbsp;</a></span>generateLibraryCallName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string mlir::linalg::generateLibraryCallName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the name mangled library call name to disambiguate between different overloads at the C level. </p>
<p>The name mangling scheme is basic and uses MLIR type names:</p><ol type="1">
<li>form a string which is the concatenation of the linalg op name with all the operand type names, separate by underscores;</li>
<li>drop the <code>linalg.</code> prefix, and the <code>&lt;</code>, <code>&gt;</code>, <code>?</code> symbols from the type. Assumes <code>op</code> is a LinalgOp.</li>
</ol>
<p>Examples:</p>
<ol type="1">
<li>linalg.fill(f, A) : f32, memref&lt;f32&gt; name mangles into <code>linalg_fill_f32_viewf32</code></li>
<li>linalg.dot A, B, C : (memref&lt;?xf32, stride_specification&gt;, memref&lt;?xf32, stride_specification&gt;, memref&lt;f32&gt;) name mangles into <code>linalg_dot_viewxf32_viewxf32_viewf32</code></li>
<li>linalg.matmul(...) : memref&lt;?x?xf32, stride_specification&gt;, memref&lt;?x?xf32, stride_specification&gt;, memref&lt;?x?xf32, stride_specification&gt; name mangles into <code>linalg_matmul_viewxxf32_viewxxf32_viewxxf32</code> </li>
</ol>

<p class="definition">Definition at line <a class="el" href="LinalgOps_8cpp_source.html#l02683">2683</a> of file <a class="el" href="LinalgOps_8cpp_source.html">LinalgOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgOps_8cpp_source.html#l02662">appendMangledType()</a>, <a class="el" href="Operation_8h_source.html#l00057">mlir::Operation::getName()</a>, <a class="el" href="Operation_8h_source.html#l00266">mlir::Operation::getOperandTypes()</a>, and <a class="el" href="OperationSupport_8h_source.html#l00182">mlir::OperationName::getStringRef()</a>.</p>

</div>
</div>
<a id="a1e61b04f528d6ebbe05496f4d6ea4a0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e61b04f528d6ebbe05496f4d6ea4a0e">&#9670;&nbsp;</a></span>generateParallelLoopNest()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classvoid.html">void</a> mlir::linalg::generateParallelLoopNest </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>lbs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>ubs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>steps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt;&#160;</td>
          <td class="paramname"><em>iteratorTypes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="classvoid.html">void</a>(<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;, <a class="el" href="classmlir_1_1Location.html">Location</a>, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>)&gt;&#160;</td>
          <td class="paramname"><em>bodyBuilderFn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>ivStorage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="namespacemlir_1_1linalg.html#a7382d59369873eb3a9a9ddd571056982">DistributionMethod</a> &gt;&#160;</td>
          <td class="paramname"><em>distributionMethod</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates a loop nest consisting of scf.parallel and scf.for, depending on the `iteratorTypes. </p>
<p>` Consecutive parallel loops create a single scf.parallel operation; each sequential loop creates a new scf.for operation. The body of the innermost loop is populated by <code>bodyBuilderFn</code> that accepts a range of induction variables for all loops. <code>ivStorage</code> is used to store the partial list of induction variables. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00530">530</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2StandardOps_2Utils_2Utils_8cpp_source.html#l00072">mlir::ArithBuilder::_and()</a>, <a class="el" href="Dialect_2SCF_2SCF_8cpp_source.html#l00486">mlir::scf::buildLoopNest()</a>, <a class="el" href="Builders_8h_source.html#l00424">mlir::OpBuilder::create()</a>, <a class="el" href="namespacemlir_1_1linalg.html#a7382d59369873eb3a9a9ddd571056982ad71670d62b238eaf063979407361034e">Cyclic</a>, <a class="el" href="namespacemlir_1_1linalg.html#a7382d59369873eb3a9a9ddd571056982ad93606014b9a6b479ba0e6faa948540b">CyclicNumProcsEqNumIters</a>, <a class="el" href="namespacemlir_1_1linalg.html#a7382d59369873eb3a9a9ddd571056982abab54876ff518ecd2d59b46fd3be9c0e">CyclicNumProcsGeNumIters</a>, <a class="el" href="StructuredOpsUtils_8h_source.html#l00081">mlir::isParallelIterator()</a>, and <a class="el" href="Dialect_2StandardOps_2Utils_2Utils_8cpp_source.html#l00090">mlir::ArithBuilder::slt()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00645">mlir::linalg::GenerateLoopNest&lt; LoopTy &gt;::doit()</a>.</p>

</div>
</div>
<a id="ae14dff721dc992372b22b28ef1884ec3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae14dff721dc992372b22b28ef1884ec3">&#9670;&nbsp;</a></span>getConstantUpperBoundForIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; int64_t &gt; mlir::linalg::getConstantUpperBoundForIndex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a constant upper bound for the result <code>value</code> of an index computation. </p>
<p>Calls <code>getUpperBoundForIndex</code> and returns a constant upper bound if the result of <code>boundMap</code> is a constant expression and failure otherwise.</p>
<p>Example: </p><div class="fragment"><div class="line">%0 = affine.min affine.map&lt;(d0) -&gt; (40, d0)&gt; (%d0)</div><div class="line">%1 = affine.apply affine.map&lt;(d0) -&gt; (d0 + 2)&gt; (%0)</div></div><!-- fragment --><p> getConstantUpperBoundForIndex(%1) returns 42 (boundsMap = affine.map&lt;() -&gt; (42)&gt;) </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00265">265</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00311">mlir::AffineMap::getResults()</a>, and <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00180">getUpperBoundForIndex()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8h_source.html#l00041">applyPermutationToVector()</a>, <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8cpp_source.html#l00165">padOperandToSmallestStaticBoundingBox()</a>, and <a class="el" href="Promotion_8cpp_source.html#l00214">promoteSubviewAsNewBuffer()</a>.</p>

</div>
</div>
<a id="a504d0107ce313528b9b8b2ecefb43e38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a504d0107ce313528b9b8b2ecefb43e38">&#9670;&nbsp;</a></span>getDimsOfType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::linalg::getDimsOfType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>iteratorTypeName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>res</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the dims that are <code>iteratorTypeName</code> loops in the LinalgOp <code>op</code>. </p>
<p>Assumes <code>op</code> is a LinalgOp. </p>

<p class="definition">Definition at line <a class="el" href="LinalgOps_8cpp_source.html#l02619">2619</a> of file <a class="el" href="LinalgOps_8cpp_source.html">LinalgOps.cpp</a>.</p>

</div>
</div>
<a id="a756a0c2f5771e052c3d9f2b0dad15525"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a756a0c2f5771e052c3d9f2b0dad15525">&#9670;&nbsp;</a></span>getDynOperands()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a>, 4 &gt; mlir::linalg::getDynOperands </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given an operation, retrieves the value of each dynamic dimension through constructing the necessary DimOp operators. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00170">170</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Types_8h_source.html#l00250">mlir::Type::cast()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00160">createOrFoldDimOp()</a>, <a class="el" href="Matchers_8h_source.html#l00206">mlir::detail::enumerate()</a>, <a class="el" href="Value_8h_source.html#l00119">mlir::Value::getType()</a>, and <a class="el" href="IR_2BuiltinTypes_8h_source.html#l00073">mlir::ShapedType::kDynamicSize</a>.</p>

<p class="reference">Referenced by <a class="el" href="Linalg_2Transforms_2Bufferize_8cpp_source.html#l00039">allocateBuffersForResults()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8h_source.html#l00041">applyPermutationToVector()</a>, and <a class="el" href="Linalg_2Transforms_2Bufferize_8cpp_source.html#l00030">cloneMemref()</a>.</p>

</div>
</div>
<a id="ae61503376ad6b88f0c35f8ce358dbc9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae61503376ad6b88f0c35f8ce358dbc9e">&#9670;&nbsp;</a></span>getLinalgTilingCanonicalizationPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> mlir::linalg::getLinalgTilingCanonicalizationPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Canonicalization patterns relevant to apply after tiling patterns. </p>
<p>These are applied automatically by the tiling pass but need to be applied manually when tiling is called programmatically. </p>

<p class="definition">Definition at line <a class="el" href="Tiling_8cpp_source.html#l00463">463</a> of file <a class="el" href="Tiling_8cpp_source.html">Tiling.cpp</a>.</p>

<p class="reference">References <a class="el" href="Tiling_8cpp_source.html#l00469">populateLinalgTilingCanonicalizationPatterns()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Tiling_8cpp_source.html#l00508">applyExtractSliceOfPadTensorSwapPattern()</a>, and <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l00589">mlir::linalg::LinalgTilingOptions::setPeeledLoops()</a>.</p>

</div>
</div>
<a id="a37b23c37eb6e528b8fc682d257680d8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37b23c37eb6e528b8fc682d257680d8d">&#9670;&nbsp;</a></span>getUpperBoundForIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::linalg::getUpperBoundForIndex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &amp;&#160;</td>
          <td class="paramname"><em>boundMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundOperands</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes an upper bound for the result <code>value</code> of an index computation. </p>
<p>Translates AffineMinOps and AffineApplyOps along the use-def chains of the index computation to affine constraints and projects out intermediate values. The method sets <code>boundMap</code> to an affine map that given <code>boundOperands</code> evaluates to an upper bound for the index computation.</p>
<p>Example: </p><div class="fragment"><div class="line">%dim0 = dim %<a class="code" href="namespacetensor.html">tensor</a>, %c0</div><div class="line">%dim1 = dim %<a class="code" href="namespacetensor.html">tensor</a>, %c1</div><div class="line">%0 = affine.min affine.map&lt;(d0) -&gt; (40, d0)&gt; (%dim0)</div><div class="line">%1 = affine.apply affine.map&lt;(d0, d1) -&gt; (d0 + d1)&gt; (%0, %dim1)</div></div><!-- fragment --><p> getUpperBoundForIndex(%1, boundMap, boundOperands) set the output parameters to:</p><ul>
<li>boundMap = affine.map&lt;(d0) -&gt; (d0 + 40)&gt;</li>
<li>boundOperands = [dim1] </li>
</ul>

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00180">180</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8cpp_source.html#l02452">mlir::FlatAffineValueConstraints::addBound()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00309">mlir::FlatAffineValueConstraints::appendDimId()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00853">mlir::canonicalizeMapAndOperands()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00556">mlir::FlatAffineValueConstraints::composeMap()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02424">mlir::FlatAffineValueConstraints::computeAlignedMap()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02600">mlir::FlatAffineValueConstraints::containsId()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">mlir::failed()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02588">mlir::FlatAffineValueConstraints::findId()</a>, <a class="el" href="AffineStructures_8h_source.html#l00869">mlir::FlatAffineValueConstraints::getAllValues()</a>, <a class="el" href="SliceAnalysis_8cpp_source.html#l00112">mlir::getBackwardSlice()</a>, <a class="el" href="Value_8h_source.html#l00122">mlir::Value::getContext()</a>, <a class="el" href="Value_8cpp_source.html#l00020">mlir::Value::getDefiningOp()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00244">mlir::AffineMap::getMultiDimIdentityMap()</a>, <a class="el" href="AffineStructures_8h_source.html#l00354">mlir::FlatAffineConstraints::getNumDimIds()</a>, <a class="el" href="Operation_8h_source.html#l00247">mlir::Operation::getOperands()</a>, <a class="el" href="Operation_8h_source.html#l00284">mlir::Operation::getResults()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02181">mlir::FlatAffineConstraints::getSliceBounds()</a>, <a class="el" href="Value_8h_source.html#l00119">mlir::Value::getType()</a>, <a class="el" href="Types_8cpp_source.html#l00028">mlir::Type::isIndex()</a>, <a class="el" href="AffineStructures_8h_source.html#l00216">mlir::FlatAffineConstraints::UB</a>, and <a class="el" href="InterfaceSupport_8h_source.html#l00161">value</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8h_source.html#l00041">applyPermutationToVector()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00265">getConstantUpperBoundForIndex()</a>, and <a class="el" href="HoistPadding_8cpp_source.html#l00322">HoistingAnalysis::getPackedTensorSizes()</a>.</p>

</div>
</div>
<a id="ad0137dfe47aacce8f945d65064093cd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0137dfe47aacce8f945d65064093cd2">&#9670;&nbsp;</a></span>hoistPaddingOnTensors()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; mlir::linalg::hoistPaddingOnTensors </td>
          <td>(</td>
          <td class="paramtype">PadTensorOp&#160;</td>
          <td class="paramname"><em>opToHoist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numLoops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PadTensorOp &amp;&#160;</td>
          <td class="paramname"><em>hoistedOp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mechanically hoist padding operations on tensors by <code>numLoops</code> into a new, generally larger tensor. </p>
<p>This achieves packing of multiple padding ops into a larger tensor. On success, <code>padTensorOp</code> is replaced by the cloned version in the packing loop so the caller can continue reasoning about the padding operation.</p>
<h1>Example in pseudo-mlir: </h1>
<p>If hoistPaddingOnTensors is called with <code>nLoops</code> = 2 on the following IR. </p><div class="fragment"><div class="line">scf.for (%i, %<a class="code" href="unionj.html">j</a>, %k)</div><div class="line">  %st0 = <a class="code" href="namespacetensor.html">tensor</a>.extract_slice f(%i, %k) : ... to <a class="code" href="namespacetensor.html">tensor</a>&lt;?x?xf32&gt;</div><div class="line">  %0 = <a class="code" href="namespacelinalg.html">linalg</a>.pad_tensor %st0 low[0, 0] high[...] {</div><div class="line">  ^bb0( ... ):</div><div class="line">    <a class="code" href="namespacelinalg.html">linalg</a>.yield %pad</div><div class="line">  } : <a class="code" href="namespacetensor.html">tensor</a>&lt;?x?xf32&gt; to <a class="code" href="namespacetensor.html">tensor</a>&lt;4x8xf32&gt;</div><div class="line">  compute(%0)</div></div><!-- fragment --><p>IR resembling the following is produced:</p>
<div class="fragment"><div class="line">scf.for (%i) {</div><div class="line">  %packed_init = <a class="code" href="namespacelinalg.html">linalg</a>.init_tensor range(%<a class="code" href="unionj.html">j</a>) : <a class="code" href="namespacetensor.html">tensor</a>&lt;?x4x8xf32&gt;</div><div class="line">  %packed = scf.for (%k) iter_args(%p : %packed_init) {</div><div class="line">    %st0 = <a class="code" href="namespacetensor.html">tensor</a>.extract_slice f(%i, %k) : ... to <a class="code" href="namespacetensor.html">tensor</a>&lt;?x?xf32&gt;</div><div class="line">    %0 = <a class="code" href="namespacelinalg.html">linalg</a>.pad_tensor %st0 low[0, 0] high[...] {</div><div class="line">    ^bb0( ... ):</div><div class="line">      <a class="code" href="namespacelinalg.html">linalg</a>.yield %pad</div><div class="line">    } : <a class="code" href="namespacetensor.html">tensor</a>&lt;?x?xf32&gt; to <a class="code" href="namespacetensor.html">tensor</a>&lt;4x8xf32&gt;</div><div class="line">    %1 = <a class="code" href="namespacetensor.html">tensor</a>.insert_slice %0 ...</div><div class="line">        : <a class="code" href="namespacetensor.html">tensor</a>&lt;4x8xf32&gt; to <a class="code" href="namespacetensor.html">tensor</a>&lt;?x4x8xf32&gt;</div><div class="line">    scf.yield %1: <a class="code" href="namespacetensor.html">tensor</a>&lt;?x4x8xf32&gt;</div><div class="line">  } -&gt; <a class="code" href="namespacetensor.html">tensor</a>&lt;?x4x8xf32&gt;</div><div class="line">  scf.for (%<a class="code" href="unionj.html">j</a>, %k) {</div><div class="line">    %st0 = <a class="code" href="namespacetensor.html">tensor</a>.extract_slice %packed [%k, 0, 0][1, 4, 8][1, 1, 1] :</div><div class="line">             tensor&lt;?x4x8xf32&gt; to tensor&lt;4x8xf32&gt;</div><div class="line">    compute(%st0)</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="HoistPadding_8cpp_source.html#l00376">376</a> of file <a class="el" href="HoistPadding_8cpp_source.html">HoistPadding.cpp</a>.</p>

<p class="reference">References <a class="el" href="HoistPadding_8cpp_source.html#l00069">HoistingAnalysis::backwardSlice</a>, <a class="el" href="HoistPadding_8cpp_source.html#l00360">buildLoopIterationCount()</a>, <a class="el" href="HoistPadding_8cpp_source.html#l00035">DBGS</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>, <a class="el" href="namespacemlir_1_1scf.html#a7e4957ac11a0c4d95f6a1494c808b392">mlir::scf::getForInductionVarOwner()</a>, <a class="el" href="HoistPadding_8cpp_source.html#l00322">HoistingAnalysis::getPackedTensorSizes()</a>, <a class="el" href="IR_2BuiltinTypes_8h_source.html#l00138">mlir::ShapedType::isDynamic()</a>, <a class="el" href="HoistPadding_8cpp_source.html#l00058">HoistingAnalysis::isValid()</a>, <a class="el" href="IR_2BuiltinTypes_8h_source.html#l00073">mlir::ShapedType::kDynamicSize</a>, <a class="el" href="BlockAndValueMapping_8h_source.html#l00066">mlir::BlockAndValueMapping::lookup()</a>, <a class="el" href="BlockAndValueMapping_8h_source.html#l00059">mlir::BlockAndValueMapping::lookupOrDefault()</a>, <a class="el" href="BlockAndValueMapping_8h_source.html#l00030">mlir::BlockAndValueMapping::map()</a>, <a class="el" href="HoistPadding_8cpp_source.html#l00065">HoistingAnalysis::outermostEnclosingForOp</a>, and <a class="el" href="HoistPadding_8cpp_source.html#l00076">HoistingAnalysis::packingLoops</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8cpp_source.html#l00491">mlir::linalg::LinalgPaddingPattern::matchAndRewrite()</a>.</p>

</div>
</div>
<a id="afbc911548f9f0328faf5855ab880e7bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbc911548f9f0328faf5855ab880e7bc">&#9670;&nbsp;</a></span>hoistRedundantVectorTransfers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::linalg::hoistRedundantVectorTransfers </td>
          <td>(</td>
          <td class="paramtype">FuncOp&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Hoist vector.transfer_read/vector.transfer_write on buffers pairs out of immediately enclosing scf::ForOp iteratively, if the following conditions are true: </p>
<ol type="1">
<li>The two ops access the same memref with the same indices.</li>
<li>All operands are invariant under the enclosing scf::ForOp.</li>
<li>No uses of the memref either dominate the transfer_read or are dominated by the transfer_write (i.e. no aliasing between the write and the read across the loop) To improve hoisting opportunities, call the <code>moveLoopInvariantCode</code> helper function on the candidate loop above which to hoist. Hoisting the transfers results in scf::ForOp yielding the value that originally transited through memory. </li>
</ol>

<p class="definition">Definition at line <a class="el" href="Hoisting_8cpp_source.html#l00393">393</a> of file <a class="el" href="Hoisting_8cpp_source.html">Hoisting.cpp</a>.</p>

<p class="reference">References <a class="el" href="Visitors_8h_source.html#l00051">mlir::WalkResult::advance()</a>, <a class="el" href="Dialect_2SCF_2Transforms_2Utils_8cpp_source.html#l00025">mlir::cloneWithNewYields()</a>, <a class="el" href="Hoisting_8cpp_source.html#l00038">DBGS</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">mlir::failed()</a>, <a class="el" href="SliceAnalysis_8cpp_source.html#l00051">mlir::getForwardSlice()</a>, <a class="el" href="Visitors_8h_source.html#l00050">mlir::WalkResult::interrupt()</a>, <a class="el" href="LoopInvariantCodeMotion_8cpp_source.html#l00078">mlir::moveLoopInvariantCode()</a>, and <a class="el" href="Dominance_8h_source.html#l00130">mlir::DominanceInfo::properlyDominates()</a>.</p>

</div>
</div>
<a id="a128bb6b2ac6de56efa82fb01ae3f258e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a128bb6b2ac6de56efa82fb01ae3f258e">&#9670;&nbsp;</a></span>hoistRedundantVectorTransfersOnTensor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::linalg::hoistRedundantVectorTransfersOnTensor </td>
          <td>(</td>
          <td class="paramtype">FuncOp&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same behavior as <code>hoistRedundantVectorTransfers</code> but works on tensors instead of buffers. </p>

<p class="definition">Definition at line <a class="el" href="Hoisting_8cpp_source.html#l00341">341</a> of file <a class="el" href="Hoisting_8cpp_source.html">Hoisting.cpp</a>.</p>

<p class="reference">References <a class="el" href="Visitors_8h_source.html#l00051">mlir::WalkResult::advance()</a>, <a class="el" href="GreedyPatternRewriteDriver_8cpp_source.html#l00372">mlir::applyPatternsAndFoldGreedily()</a>, <a class="el" href="Hoisting_8cpp_source.html#l00038">DBGS</a>, <a class="el" href="Matchers_8h_source.html#l00206">mlir::detail::enumerate()</a>, <a class="el" href="Hoisting_8cpp_source.html#l00099">findMatchingTransferRead()</a>, <a class="el" href="Hoisting_8cpp_source.html#l00223">getLoopInvariantTransferWriteOpDefining()</a>, <a class="el" href="Operation_8h_source.html#l00257">mlir::Operation::getOpOperand()</a>, <a class="el" href="Hoisting_8cpp_source.html#l00261">hoistReadWrite()</a>, <a class="el" href="Visitors_8h_source.html#l00050">mlir::WalkResult::interrupt()</a>, and <a class="el" href="Hoisting_8cpp_source.html#l00162">tensorChunkAccessedByUnknownOp()</a>.</p>

</div>
</div>
<a id="a770981e996593487fafc3a47ac9c4be9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a770981e996593487fafc3a47ac9c4be9">&#9670;&nbsp;</a></span>insertVectorizationPatternImpl() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OpType , typename  = std::enable_if_t&lt;detect_has_get_operation_name&lt;OpType&gt;::value&gt;, typename  = void&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::linalg::insertVectorizationPatternImpl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patternList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1linalg_1_1LinalgVectorizationOptions.html">linalg::LinalgVectorizationOptions</a>&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1linalg_1_1LinalgTransformationFilter.html">linalg::LinalgTransformationFilter</a>&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SFINAE helper for single C++ op with a <code>getOperationName</code> method. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l01076">1076</a> of file <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8h_source.html">Transforms.h</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00928">mlir::RewritePatternSet::add()</a>, <a class="el" href="PatternMatch_8h_source.html#l00904">mlir::RewritePatternSet::getContext()</a>, and <a class="el" href="PassManagerOptions_8cpp_source.html#l00083">options</a>.</p>

</div>
</div>
<a id="a7b512a9592500c7fb570fea733d3591f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b512a9592500c7fb570fea733d3591f">&#9670;&nbsp;</a></span>insertVectorizationPatternImpl() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OpType , typename  = std::enable_if_t&lt;                               !detect_has_get_operation_name&lt;OpType&gt;::value&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::linalg::insertVectorizationPatternImpl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patternList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1linalg_1_1LinalgVectorizationOptions.html">linalg::LinalgVectorizationOptions</a>&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1linalg_1_1LinalgTransformationFilter.html">linalg::LinalgTransformationFilter</a>&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SFINAE helper for single C++ class without a <code>getOperationName</code> method (e.g. </p>
<p>an <a class="el" href="classmlir_1_1OpInterface.html" title="This class represents the base of an operation interface. ">OpInterface</a>). </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l01087">1087</a> of file <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8h_source.html">Transforms.h</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00928">mlir::RewritePatternSet::add()</a>, <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l00446">mlir::linalg::LinalgTransformationFilter::addOpFilter()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00904">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="ab6d3a5c3a62ba42651c654bac998b69e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6d3a5c3a62ba42651c654bac998b69e">&#9670;&nbsp;</a></span>insertVectorizationPatterns()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... OpTypes&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::linalg::insertVectorizationPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patternList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1linalg_1_1LinalgVectorizationOptions.html">linalg::LinalgVectorizationOptions</a>&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1linalg_1_1LinalgTransformationFilter.html">linalg::LinalgTransformationFilter</a>&#160;</td>
          <td class="paramname"><em>f</em> = <code><a class="el" href="structmlir_1_1linalg_1_1LinalgTransformationFilter.html">linalg::LinalgTransformationFilter</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Variadic helper function to insert vectorization patterns for C++ ops. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l01096">1096</a> of file <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8h_source.html">Transforms.h</a>.</p>

<p class="reference">References <a class="el" href="PassManagerOptions_8cpp_source.html#l00083">options</a>.</p>

</div>
</div>
<a id="a4223ee2d6488e478b0a9e86897094a9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4223ee2d6488e478b0a9e86897094a9a">&#9670;&nbsp;</a></span>interchangeGenericOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::linalg::interchangeGenericOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1PatternRewriter.html">PatternRewriter</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GenericOp&#160;</td>
          <td class="paramname"><em>genericOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt;&#160;</td>
          <td class="paramname"><em>interchangeVector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interchanges the <code>iterator_types</code> and <code>iterator_maps</code> dimensions and adapts the index accesses of <code>op</code>. </p>
<p>This is an in-place transformation controlled by <code>interchangeVector</code>. An empty vector is interpreted as the identity permutation and the transformation returns early.</p>
<p>E.g. the permutation <code>(i,j,k) -&gt; (j,k,i)</code> is expressed with <code>interchangeVector = [1,2,0]</code>. All values in <code>interchangeVector</code> must be integers, in the range 0..<code>op.rank</code> without duplications (i.e. <code>[1,1,2]</code> is an invalid permutation). </p>

<p class="definition">Definition at line <a class="el" href="Interchange_8cpp_source.html#l00046">46</a> of file <a class="el" href="Interchange_8cpp_source.html">Interchange.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8h_source.html#l00041">applyPermutationToVector()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00444">mlir::AffineMap::compose()</a>, <a class="el" href="Builders_8h_source.html#l00424">mlir::OpBuilder::create()</a>, <a class="el" href="StructuredOpsUtils_8h_source.html#l00050">mlir::getIndexingMapsAttrName()</a>, <a class="el" href="StructuredOpsUtils_8h_source.html#l00054">mlir::getIteratorTypesAttrName()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00205">mlir::AffineMap::getPermutationMap()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00519">mlir::AffineMap::getSubMap()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00673">mlir::inversePermutation()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00267">mlir::AffineMap::isEmpty()</a>, <a class="el" href="PatternMatch_8h_source.html#l00739">mlir::RewriterBase::replaceOpWithNewOp()</a>, and <a class="el" href="Builders_8h_source.html#l00331">mlir::OpBuilder::setInsertionPoint()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8cpp_source.html#l00612">mlir::linalg::GenericOpInterchangePattern::matchAndRewrite()</a>.</p>

</div>
</div>
<a id="a9af1c8a390189f7f1882bfd1181f8112"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9af1c8a390189f7f1882bfd1181f8112">&#9670;&nbsp;</a></span>interchangeGenericOpPrecondition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::linalg::interchangeGenericOpPrecondition </td>
          <td>(</td>
          <td class="paramtype">GenericOp&#160;</td>
          <td class="paramname"><em>genericOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt;&#160;</td>
          <td class="paramname"><em>interchangeVector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emits a <code>generic</code> operation with the <code>indexing_maps</code> and <code>iterator_types</code> permutated according to <code>permutation</code>. </p>

<p class="definition">Definition at line <a class="el" href="Interchange_8cpp_source.html#l00033">33</a> of file <a class="el" href="Interchange_8cpp_source.html">Interchange.cpp</a>.</p>

<p class="reference">References <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00205">mlir::AffineMap::getPermutationMap()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00673">mlir::inversePermutation()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">mlir::success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8cpp_source.html#l00612">mlir::linalg::GenericOpInterchangePattern::matchAndRewrite()</a>.</p>

</div>
</div>
<a id="ab5277093c168682f123f1e99d90461f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5277093c168682f123f1e99d90461f0">&#9670;&nbsp;</a></span>isaContractionOpInterface()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::linalg::isaContractionOpInterface </td>
          <td>(</td>
          <td class="paramtype">LinalgOp&#160;</td>
          <td class="paramname"><em>linalgOp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks whether <code>linalgOp</code> conforms to ContractionOpInterface. </p>

<p class="definition">Definition at line <a class="el" href="LinalgInterfaces_8cpp_source.html#l00121">121</a> of file <a class="el" href="LinalgInterfaces_8cpp_source.html">LinalgInterfaces.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgInterfaces_8cpp_source.html#l00102">isContractionInterfaceImpl()</a>, and <a class="el" href="LinalgInterfaces_8cpp.html#a3546ee41e42cffd5aaddbac11c2ea109a505a83f220c02df2f85c3810cd9ceb38">Success</a>.</p>

</div>
</div>
<a id="a6bf6605778cf3f93537f2bc2e58da089"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bf6605778cf3f93537f2bc2e58da089">&#9670;&nbsp;</a></span>isFusableInto()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::linalg::isFusableInto </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1linalg_1_1LinalgDependenceGraph.html">LinalgDependenceGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LinalgOp&#160;</td>
          <td class="paramname"><em>consumer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>consumedView</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LinalgOp&#160;</td>
          <td class="paramname"><em>producer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks whether fusing the specific <code>producer</code> of the <code>consumedView</code> is feasible. </p>
<p>This checks <code>producer</code> is the last write of <code>consumedView</code> and that no interleaved dependence would be violated (RAW, WAR or WAW). </p>

<p class="definition">Definition at line <a class="el" href="Fusion_8cpp_source.html#l00311">311</a> of file <a class="el" href="Fusion_8cpp_source.html">Fusion.cpp</a>.</p>

<p class="reference">References <a class="el" href="DependenceAnalysis_8cpp_source.html#l00214">mlir::linalg::LinalgDependenceGraph::findCoveringDependences()</a>, and <a class="el" href="Fusion_8cpp_source.html#l00287">isProducerLastWriteOfView()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Fusion_8cpp_source.html#l00335">findFusableProducer()</a>.</p>

</div>
</div>
<a id="a2af55e6383d5f7c643803c91f06d33e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2af55e6383d5f7c643803c91f06d33e9">&#9670;&nbsp;</a></span>isPermutation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::linalg::isPermutation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>permutation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if <code>permutation</code> is a permutation of the range <code>[0, permutation.size())</code>. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00145">145</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8cpp_source.html#l00553">mlir::linalg::LinalgTileAndFuseTensorOpsPattern::matchAndRewrite()</a>, and <a class="el" href="FusionOnTensors_8cpp_source.html#l00409">tileConsumerAndFuseProducers()</a>.</p>

</div>
</div>
<a id="a1a2959f54ccc7cabc35c9337f50c0734"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a2959f54ccc7cabc35c9337f50c0734">&#9670;&nbsp;</a></span>isProducerLastWriteOfView()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::linalg::isProducerLastWriteOfView </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1linalg_1_1LinalgDependenceGraph.html">LinalgDependenceGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LinalgOp&#160;</td>
          <td class="paramname"><em>consumer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>consumedView</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LinalgOp&#160;</td>
          <td class="paramname"><em>producer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks whether the specific <code>producer</code> is the last write to exactly the whole <code>consumedView</code>. </p>
<p>This checks structural dominance, that the dependence is a RAW without any interleaved write to any piece of <code>consumedView</code>. </p>

<p class="definition">Definition at line <a class="el" href="Fusion_8cpp_source.html#l00287">287</a> of file <a class="el" href="Fusion_8cpp_source.html">Fusion.cpp</a>.</p>

<p class="reference">References <a class="el" href="DependenceAnalysis_8cpp_source.html#l00221">mlir::linalg::LinalgDependenceGraph::findCoveringWrites()</a>, and <a class="el" href="Fusion_8cpp_source.html#l00266">isStructurallyFusableProducer()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Fusion_8cpp_source.html#l00311">isFusableInto()</a>.</p>

</div>
</div>
<a id="a740346ce432cec25b0a0f13106745fff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a740346ce432cec25b0a0f13106745fff">&#9670;&nbsp;</a></span>linalgOpToAffineLoops()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; <a class="el" href="namespacemlir_1_1linalg.html#a4a9ca79033211e3e53e0eb25a8e9551b">LinalgLoops</a> &gt; mlir::linalg::linalgOpToAffineLoops </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1PatternRewriter.html">PatternRewriter</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LinalgOp&#160;</td>
          <td class="paramname"><em>linalgOp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emits a loop nest of <code>affine.for</code> with the proper body for <code>linalgOp</code>. </p>

<p class="definition">Definition at line <a class="el" href="Loops_8cpp_source.html#l00551">551</a> of file <a class="el" href="Loops_8cpp_source.html">Loops.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l01129">mlir::linalg::LinalgLoweringPattern&lt; OpTy &gt;::matchAndRewrite()</a>.</p>

</div>
</div>
<a id="a0560d71ab93b47840620101f0a967e71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0560d71ab93b47840620101f0a967e71">&#9670;&nbsp;</a></span>linalgOpToLoops()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; <a class="el" href="namespacemlir_1_1linalg.html#a4a9ca79033211e3e53e0eb25a8e9551b">LinalgLoops</a> &gt; mlir::linalg::linalgOpToLoops </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1PatternRewriter.html">PatternRewriter</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LinalgOp&#160;</td>
          <td class="paramname"><em>linalgOp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emits a loop nest of <code>scf.for</code> with the proper body for <code>linalgOp</code>. </p>

<p class="definition">Definition at line <a class="el" href="Loops_8cpp_source.html#l00557">557</a> of file <a class="el" href="Loops_8cpp_source.html">Loops.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l01129">mlir::linalg::LinalgLoweringPattern&lt; OpTy &gt;::matchAndRewrite()</a>.</p>

</div>
</div>
<a id="a80b030d0e1f67f25aabea28e8ff27087"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80b030d0e1f67f25aabea28e8ff27087">&#9670;&nbsp;</a></span>linalgOpToParallelLoops()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; <a class="el" href="namespacemlir_1_1linalg.html#a4a9ca79033211e3e53e0eb25a8e9551b">LinalgLoops</a> &gt; mlir::linalg::linalgOpToParallelLoops </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1PatternRewriter.html">PatternRewriter</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LinalgOp&#160;</td>
          <td class="paramname"><em>linalgOp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emits a loop nest of <code>scf.parallel</code> with the proper body for <code>linalgOp</code>. </p>

<p class="definition">Definition at line <a class="el" href="Loops_8cpp_source.html#l00564">564</a> of file <a class="el" href="Loops_8cpp_source.html">Loops.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l01129">mlir::linalg::LinalgLoweringPattern&lt; OpTy &gt;::matchAndRewrite()</a>.</p>

</div>
</div>
<a id="a962a46fba2ac497e30bb6d23fef35d1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a962a46fba2ac497e30bb6d23fef35d1a">&#9670;&nbsp;</a></span>makeAffineDimExprs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>, 4 &gt; mlir::linalg::makeAffineDimExprs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a> &amp;&#160;</td>
          <td class="paramname"><em>startIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>num</code> <a class="el" href="classmlir_1_1AffineDimExpr.html" title="A dimensional identifier appearing in an affine expression. ">AffineDimExpr</a> dimensions at positions [startIdx, startIdx + num) and increments <code>startIdx</code> to <code>startIdx + num</code>. </p>

<p class="definition">Definition at line <a class="el" href="LinalgOps_8cpp_source.html#l02645">2645</a> of file <a class="el" href="LinalgOps_8cpp_source.html">LinalgOps.cpp</a>.</p>

</div>
</div>
<a id="aae95c286789e27b94eadba9558405bee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae95c286789e27b94eadba9558405bee">&#9670;&nbsp;</a></span>makeComposedExtractSliceOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tensor::ExtractSliceOp mlir::linalg::makeComposedExtractSliceOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>strides</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an ExtractSliceOp and, if <code>source</code> is defined by an ExtractSliceOp, fold it by adding the offsets. </p>
<p>Example: </p><div class="fragment"><div class="line">%0 = <a class="code" href="namespacetensor.html">tensor</a>.extract_slice %arg0[3, 4][3, 32][1, 1] : tensor&lt;64x64xf32&gt; to</div><div class="line">                                                       tensor&lt;3x32xf32&gt;</div><div class="line">%1 = <a class="code" href="namespacetensor.html">tensor</a>.extract_slice %0[0, 5][3, 4][1, 1] : tensor&lt;3x32xf32&gt; to</div><div class="line">                                                   tensor&lt;3x4xf32&gt;</div></div><!-- fragment --><p> folds into: </p><div class="fragment"><div class="line">%1 = <a class="code" href="namespacetensor.html">tensor</a>.extract_slice %arg0[3, 9][3, 4][1, 1] : tensor&lt;64x64xf32&gt; to</div><div class="line">                                                      tensor&lt;3x4xf32&gt;</div></div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00283">283</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineExpr_8h_source.html#l00328">mlir::bindDims()</a>, <a class="el" href="Builders_8h_source.html#l00424">mlir::OpBuilder::create()</a>, <a class="el" href="Matchers_8h_source.html#l00206">mlir::detail::enumerate()</a>, <a class="el" href="StaticValueUtils_8cpp_source.html#l00069">mlir::getConstantIntValue()</a>, <a class="el" href="Builders_8h_source.html#l00054">mlir::Builder::getContext()</a>, <a class="el" href="Value_8cpp_source.html#l00020">mlir::Value::getDefiningOp()</a>, <a class="el" href="Dialect_2StandardOps_2Utils_2Utils_8cpp_source.html#l00054">mlir::getValueOrCreateConstantIndexOp()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l00714">mlir::makeComposedAffineApply()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8h_source.html#l00041">applyPermutationToVector()</a>, and <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00719">makeTiledShape()</a>.</p>

</div>
</div>
<a id="aa9edcaadd998bad20bfb048ad9570c93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9edcaadd998bad20bfb048ad9570c93">&#9670;&nbsp;</a></span>makeComposedPadHighOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> mlir::linalg::makeComposedPadHighOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RankedTensorType&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>pad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>nofold</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a PadTensorOp that pads <code>source</code> to the size of the statically sized <code>type</code> whose static sizes are assumed to be greater than the dynamic <code>source</code> size. </p>
<p>The padding introduces trailing <code>pad</code> values until the target size is met. If <code>source</code> is defined by one or more LinalgOps that have been padded with the same value and sizes, return their padded result instead of creating a PadTensorOp.</p>
<p>Example: </p><div class="fragment"><div class="line">%0 = <a class="code" href="namespacetensor.html">tensor</a>.extract_slice %arg0 [%iv0, %iv1] [%sz0, %sz1]</div><div class="line">%1 = <a class="code" href="namespacelinalg.html">linalg</a>.pad_tensor %0 low[0, 0] high[...] { <a class="code" href="namespacelinalg.html">linalg</a>.yield %cst }</div><div class="line">%2 = <a class="code" href="namespacelinalg.html">linalg</a>.matmul ins(...) outs(%1)</div><div class="line">%3 = <a class="code" href="namespacetensor.html">tensor</a>.extract_slice %2 [0, 0] [%sz0, %sz1]</div></div><!-- fragment --><p> makeComposedPadHighOp(source=%3, pad=cst) returns %2 makeComposedPadHighOp(source=%3, pad=other_cst) returns %4 </p><div class="fragment"><div class="line">%4 = <a class="code" href="namespacelinalg.html">linalg</a>.pad_tensor %3 low[0, 0] high[...] { <a class="code" href="namespacelinalg.html">linalg</a>.yield %other_cst }</div></div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00325">325</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Value_8h_source.html#l00109">mlir::Value::cast()</a>, <a class="el" href="StaticValueUtils_8cpp_source.html#l00069">mlir::getConstantIntValue()</a>, <a class="el" href="Value_8cpp_source.html#l00020">mlir::Value::getDefiningOp()</a>, <a class="el" href="Value_8h_source.html#l00437">mlir::OpResult::getResultNumber()</a>, <a class="el" href="StaticValueUtils_8cpp_source.html#l00088">mlir::isEqualConstantIntOrValue()</a>, <a class="el" href="Matchers_8h_source.html#l00231">mlir::m_Constant()</a>, and <a class="el" href="Matchers_8h_source.html#l00266">mlir::matchPattern()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8h_source.html#l00041">applyPermutationToVector()</a>, and <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8cpp_source.html#l00165">padOperandToSmallestStaticBoundingBox()</a>.</p>

</div>
</div>
<a id="a625c1d98cff00c9d77d2efc29d597bda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a625c1d98cff00c9d77d2efc29d597bda">&#9670;&nbsp;</a></span>makeTiledShape()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> mlir::linalg::makeTiledShape </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>valueToTile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>tileSizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>lbs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>ubs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>subShapeSizes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an extract_slice/subview op for a single <code>valueToTile</code> with <code>builder</code>. </p>
<p>This new operation extracts a tile of <code>valueToTile</code>, starting at offsets <code>lbs</code> and with sizes <code>subShapeSizes</code>. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00719">719</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgInterfaces_8cpp_source.html#l00434">applyMapToValues()</a>, <a class="el" href="IR_2AffineExpr_8h_source.html#l00328">mlir::bindDims()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00853">mlir::canonicalizeMapAndOperands()</a>, <a class="el" href="Builders_8h_source.html#l00424">mlir::OpBuilder::create()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00160">createOrFoldDimOp()</a>, <a class="el" href="Types_8h_source.html#l00244">mlir::Type::dyn_cast()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00705">mlir::fullyComposeAffineMapAndOperands()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00710">fullyComposeAndAffineApply()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00499">mlir::getAffineSymbolExpr()</a>, <a class="el" href="StaticValueUtils_8cpp_source.html#l00054">mlir::getAsOpFoldResult()</a>, <a class="el" href="Builders_8h_source.html#l00054">mlir::Builder::getContext()</a>, <a class="el" href="Builders_8cpp_source.html#l00099">mlir::Builder::getIndexAttr()</a>, <a class="el" href="Builders_8cpp_source.html#l00052">mlir::Builder::getIndexType()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00519">mlir::AffineMap::getSubMap()</a>, <a class="el" href="Value_8h_source.html#l00119">mlir::Value::getType()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00235">mlir::AffineMap::inferFromExprList()</a>, <a class="el" href="IR_2BuiltinTypes_8h_source.html#l00138">mlir::ShapedType::isDynamic()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00079">isTiled()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00714">mlir::makeComposedAffineApply()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00283">makeComposedExtractSliceOp()</a>, and <a class="el" href="Arithmetic_8h_source.html#l00085">mlir::arith::ConstantIndexOp::value()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00858">makeTiledShapes()</a>, and <a class="el" href="Tiling_8cpp_source.html#l00339">tilePadTensorOp()</a>.</p>

</div>
</div>
<a id="a77f6409a20cf9ca1db0996f6f3dd4f53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77f6409a20cf9ca1db0996f6f3dd4f53">&#9670;&nbsp;</a></span>makeTiledShapes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a>, 4 &gt; mlir::linalg::makeTiledShapes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LinalgOp&#160;</td>
          <td class="paramname"><em>linalgOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td>
          <td class="paramname"><em>valuesToTile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>ivs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>tileSizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td>
          <td class="paramname"><em>sizeBounds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates extract_slice/subview ops for all <code>valuesToTile</code> of the given <code>linalgOp</code> with <code>builder</code>, assuming <code>linalgOp</code> is being fused into a loop nest for tiling with the given induction variables <code>ivs</code> and tile sizes <code>tileSizes</code>. </p>
<p><code>sizeBounds</code> are the iteration space bounds for <em>all</em> the implicit loops in <code>linalgOp</code>.</p>
<p>Note that a constant zero in <code>tileSizes</code> means no tiling at that implicit loop. The number of non-zero values in <code>tileSizes</code> should be equal to the number of values in <code>ivs</code>. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00858">858</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00828">computeTileOffsets()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00843">computeTileSizes()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00079">isTiled()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00044">isZero()</a>, and <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00719">makeTiledShape()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Fusion_8cpp_source.html#l00172">fuse()</a>, and <a class="el" href="FusionOnTensors_8cpp_source.html#l00128">getTiledProducer()</a>.</p>

</div>
</div>
<a id="ae1f9f35146d8a5665c3960ce54d8fc74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1f9f35146d8a5665c3960ce54d8fc74">&#9670;&nbsp;</a></span>peelAndCanonicalizeTiledLoop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::linalg::peelAndCanonicalizeTiledLoop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TiledLoopOp&#160;</td>
          <td class="paramname"><em>loopOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TiledLoopOp &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rewrite a TiledLoopOp with bounds/step that potentially do not divide evenly into a TiledLoopOp where the step divides the iteration space evenly, followed by another TiledLoopOp for the last (partial) iteration (if any). </p>
<p>This transformation is called "loop peeling".</p>
<p>This function peels the <code>idx</code>-th loop of the TiledLoopOp. To tile all loops in the loop nest, this function must be called multiple times.</p>
<p>After loop peeling, this function tries to simplify/canonicalize affine.min and affine.max ops in the body of the two TiledLoopOps. For more details, refer to <code><a class="el" href="namespacemlir_1_1scf.html#a16c1901dd11dac0edafe28fb81a765b0" title="Rewrite a for loop with bounds/step that potentially do not divide evenly into a for loop where the s...">mlir::scf::peelAndCanonicalizeForLoop</a></code>.</p>
<p>The return value indicates whether the loop was rewritten or not. Loops are not rewritten if:</p><ul>
<li>Loop step size is 1 or</li>
<li>Loop bounds and step size are static, and step already divides the iteration space evenly.</li>
</ul>
<p>Note: This function rewrites the given TiledLoopOp in-place and clones the TileLoopOp operation for the last iteration. It replaces all uses of the unpeeled TiledLoopOp with the results of the newly generated TiledLoopOp. </p>

<p class="definition">Definition at line <a class="el" href="Loops_8cpp_source.html#l00499">499</a> of file <a class="el" href="Loops_8cpp_source.html">Loops.cpp</a>.</p>

<p class="reference">References <a class="el" href="LogicalResult_8h_source.html#l00072">mlir::failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>, <a class="el" href="Loops_8cpp_source.html#l00430">peelTiledLoop()</a>, <a class="el" href="Loops_8cpp_source.html#l00482">rewriteAffineOpAfterPeeling()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">mlir::success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l01343">mlir::linalg::ConvOpVectorization&lt; ConvOp, N &gt;::ConvOpVectorization()</a>, and <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8cpp_source.html#l00307">peelLoop()</a>.</p>

</div>
</div>
<a id="a891b8f2d145dcc3327ba55c7a49d44e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a891b8f2d145dcc3327ba55c7a49d44e4">&#9670;&nbsp;</a></span>populateConvolutionVectorizationPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::linalg::populateConvolutionVectorizationPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a>&#160;</td>
          <td class="paramname"><em>benefit</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates patterns for vectorizing low-D convolution ops. </p>
<p>This is a step in progressive lowering for convolution ops, it assume high-D convolution ops were decomposed previously. </p>

<p class="definition">Definition at line <a class="el" href="Vectorization_8cpp_source.html#l01774">1774</a> of file <a class="el" href="Vectorization_8cpp_source.html">Vectorization.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00928">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00904">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="a09260a76a605cbb154f1a4d802feeea9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09260a76a605cbb154f1a4d802feeea9">&#9670;&nbsp;</a></span>populateConvVectorizationPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::linalg::populateConvVectorizationPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>tileSizes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>[DEPRECATED] Populates patterns for vectorization of all ConvN-D ops. </p>

<p class="definition">Definition at line <a class="el" href="Vectorization_8cpp_source.html#l01187">1187</a> of file <a class="el" href="Vectorization_8cpp_source.html">Vectorization.cpp</a>.</p>

</div>
</div>
<a id="a7c0dd1ffad2bc016481940518f493587"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c0dd1ffad2bc016481940518f493587">&#9670;&nbsp;</a></span>populateDecomposeConvolutionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::linalg::populateDecomposeConvolutionPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1linalg_1_1LinalgTransformationFilter.html">LinalgTransformationFilter</a>&#160;</td>
          <td class="paramname"><em>filter</em> = <code><a class="el" href="structmlir_1_1linalg_1_1LinalgTransformationFilter.html">LinalgTransformationFilter</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a>&#160;</td>
          <td class="paramname"><em>benefit</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Linalg decompose convolutions patterns. </p>
<p>Populates patterns to decompose high-D convolution ops into low-D ones. This is a step in progressive lowering for convolution ops, afterwards we can vectorize the low-D convolution ops. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8cpp_source.html#l01099">1099</a> of file <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8cpp_source.html">Transforms.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00928">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00904">mlir::RewritePatternSet::getContext()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l01129">mlir::linalg::LinalgLoweringPattern&lt; OpTy &gt;::matchAndRewrite()</a>.</p>

</div>
</div>
<a id="a46f808101854ba4429cc752879269e28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46f808101854ba4429cc752879269e28">&#9670;&nbsp;</a></span>populateElementwiseOpsFusionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::linalg::populateElementwiseOpsFusionPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1linalg_1_1LinalgElementwiseFusionOptions.html">LinalgElementwiseFusionOptions</a>&#160;</td>
          <td class="paramname"><em>options</em> = <code><a class="el" href="structmlir_1_1linalg_1_1LinalgElementwiseFusionOptions.html">LinalgElementwiseFusionOptions</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Patterns for fusing linalg operation on tensors. </p>

<p class="definition">Definition at line <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l01764">1764</a> of file <a class="el" href="ElementwiseOpFusion_8cpp_source.html">ElementwiseOpFusion.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00928">mlir::RewritePatternSet::add()</a>, <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l00126">mlir::linalg::LinalgElementwiseFusionOptions::controlElementwiseOpsFusionFn</a>, <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l00114">mlir::linalg::LinalgElementwiseFusionOptions::controlFoldingReshapesFn</a>, <a class="el" href="PatternMatch_8h_source.html#l00904">mlir::RewritePatternSet::getContext()</a>, and <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l01755">populateFoldReshapeOpsByExpansionPatterns()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l00132">mlir::linalg::LinalgElementwiseFusionOptions::setControlElementwiseOpsFusionFn()</a>, and <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l01606">skipUnitDimReshape()</a>.</p>

</div>
</div>
<a id="a7a49133ef595966377878adc42196f47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a49133ef595966377878adc42196f47">&#9670;&nbsp;</a></span>populateElementwiseToLinalgConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::linalg::populateElementwiseToLinalgConversionPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populate patterns that convert <code>ElementwiseMappable</code> ops to linalg parallel loops. </p>

<p class="definition">Definition at line <a class="el" href="ElementwiseToLinalg_8cpp_source.html#l00119">119</a> of file <a class="el" href="ElementwiseToLinalg_8cpp_source.html">ElementwiseToLinalg.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00928">mlir::RewritePatternSet::add()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l03261">mlir::applyPartialConversion()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">mlir::failed()</a>, <a class="el" href="PatternMatch_8h_source.html#l00904">mlir::RewritePatternSet::getContext()</a>, <a class="el" href="ElementwiseToLinalg_8cpp_source.html#l00021">isElementwiseMappableOpOnRankedTensors()</a>, and <a class="el" href="DialectConversion_8h_source.html#l00798">mlir::ConversionTarget::markUnknownOpDynamicallyLegal()</a>.</p>

</div>
</div>
<a id="a5b6b7bc78a3dd3530d45e50a15e48af5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b6b7bc78a3dd3530d45e50a15e48af5">&#9670;&nbsp;</a></span>populateFoldReshapeOpsByExpansionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::linalg::populateFoldReshapeOpsByExpansionPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir_1_1linalg.html#a7f0c7d5683991009cfddd7748b7f8d4d">ControlElementwiseOpsFusionFn</a>&#160;</td>
          <td class="paramname"><em>controlFoldingReshapes</em> = <code><a class="el" href="namespacemlir_1_1linalg.html#ae949a412565c20b3d334a8d3a26acab3">skipUnitDimReshape</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Patterns to fold an expanding (collapsing) tensor_reshape operation with its producer (consumer) generic operation by expanding the dimensionality of the loop in the generic op. </p>

<p class="definition">Definition at line <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l01755">1755</a> of file <a class="el" href="ElementwiseOpFusion_8cpp_source.html">ElementwiseOpFusion.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00928">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00904">mlir::RewritePatternSet::getContext()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l01764">populateElementwiseOpsFusionPatterns()</a>.</p>

</div>
</div>
<a id="a83456e96c4abd883654638b15422f2f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83456e96c4abd883654638b15422f2f7">&#9670;&nbsp;</a></span>populateFoldReshapeOpsByLinearizationPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::linalg::populateFoldReshapeOpsByLinearizationPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Patterns to fold a collapsing (expanding) tensor_reshape operation with its producer (consumer) generic operation by linearizing the indexing map used to access the source (target) of the reshape operation in the generic operation. </p>

<p class="definition">Definition at line <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l01735">1735</a> of file <a class="el" href="ElementwiseOpFusion_8cpp_source.html">ElementwiseOpFusion.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00928">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00904">mlir::RewritePatternSet::getContext()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l01606">skipUnitDimReshape()</a>.</p>

</div>
</div>
<a id="aaab9722666a91e7e3d5e93b24bb9f8f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaab9722666a91e7e3d5e93b24bb9f8f2">&#9670;&nbsp;</a></span>populateFoldUnitDimsReshapeOpsByLinearizationPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::linalg::populateFoldUnitDimsReshapeOpsByLinearizationPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Patterns to fold a collapsing (expanding) tensor_reshape operation with its producer (consumer) generic operation by linearizing the indexing map used to access the source (target) of the reshape operation in the generic operation. </p>
<p>The patterns are applied only when the tensor reshape involved is collapsing (introducing) unit-extent dimensions. </p>

<p class="definition">Definition at line <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l01745">1745</a> of file <a class="el" href="ElementwiseOpFusion_8cpp_source.html">ElementwiseOpFusion.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00928">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00904">mlir::RewritePatternSet::getContext()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l01606">skipUnitDimReshape()</a>.</p>

</div>
</div>
<a id="a1578d606ad73b93f532062fef0ce6574"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1578d606ad73b93f532062fef0ce6574">&#9670;&nbsp;</a></span>populateFoldUnitExtentDimsPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::linalg::populateFoldUnitExtentDimsPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Patterns to fold unit-extent dimensions in operands/results of linalg ops on tensors. </p>
<p>Patterns that are used to canonicalize the use of unit-extent dims for broadcasting.</p>

<p class="definition">Definition at line <a class="el" href="DropUnitDims_8cpp_source.html#l00545">545</a> of file <a class="el" href="DropUnitDims_8cpp_source.html">DropUnitDims.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00928">mlir::RewritePatternSet::add()</a>, <a class="el" href="GreedyPatternRewriteDriver_8cpp_source.html#l00372">mlir::applyPatternsAndFoldGreedily()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00904">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="acc64a8c8a9ecf3de84383893d8e4ddc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc64a8c8a9ecf3de84383893d8e4ddc2">&#9670;&nbsp;</a></span>populateInlineConstantOperandsPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::linalg::populateInlineConstantOperandsPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Patterns that are used to inline constant operands into linalg generic ops. </p>

<p class="definition">Definition at line <a class="el" href="InlineScalarOperands_8cpp_source.html#l00090">90</a> of file <a class="el" href="InlineScalarOperands_8cpp_source.html">InlineScalarOperands.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00928">mlir::RewritePatternSet::add()</a>, <a class="el" href="GreedyPatternRewriteDriver_8cpp_source.html#l00372">mlir::applyPatternsAndFoldGreedily()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00904">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="af340607de92119a4db091ed375086bb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af340607de92119a4db091ed375086bb0">&#9670;&nbsp;</a></span>populateLinalgBufferizePatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::linalg::populateLinalgBufferizePatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1bufferization_1_1BufferizeTypeConverter.html">bufferization::BufferizeTypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>converter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates the given list with patterns to bufferize linalg ops. </p>

<p class="definition">Definition at line <a class="el" href="Linalg_2Transforms_2Bufferize_8cpp_source.html#l00348">348</a> of file <a class="el" href="Linalg_2Transforms_2Bufferize_8cpp_source.html">Bufferize.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00928">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00904">mlir::RewritePatternSet::getContext()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Linalg_2Transforms_2Bufferize_8cpp_source.html#l00082">createLinalgOpOnBuffers()</a>.</p>

</div>
</div>
<a id="a7bc8eeefb74502116e8a8a57d48369a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bc8eeefb74502116e8a8a57d48369a5">&#9670;&nbsp;</a></span>populateLinalgDistributeTiledLoopPattern()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::linalg::populateLinalgDistributeTiledLoopPattern </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1linalg_1_1LinalgLoopDistributionOptions.html">LinalgLoopDistributionOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>opts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1linalg_1_1LinalgTransformationFilter.html">LinalgTransformationFilter</a> &amp;&#160;</td>
          <td class="paramname"><em>marker</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Linalg distribution patterns. </p>
<p>Populates <code>patterns</code> with patterns to distribute linalg.tiled_loop. </p>

<p class="definition">Definition at line <a class="el" href="Distribution_8cpp_source.html#l00081">81</a> of file <a class="el" href="Distribution_8cpp_source.html">Distribution.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00928">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00904">mlir::RewritePatternSet::getContext()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l01129">mlir::linalg::LinalgLoweringPattern&lt; OpTy &gt;::matchAndRewrite()</a>.</p>

</div>
</div>
<a id="a60cd962332e381639e396c646c82eb14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60cd962332e381639e396c646c82eb14">&#9670;&nbsp;</a></span>populateLinalgNamedOpsGeneralizationPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::linalg::populateLinalgNamedOpsGeneralizationPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1linalg_1_1LinalgTransformationFilter.html">LinalgTransformationFilter</a>&#160;</td>
          <td class="paramname"><em>filter</em> = <code><a class="el" href="structmlir_1_1linalg_1_1LinalgTransformationFilter.html">LinalgTransformationFilter</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Linalg generalization patterns. </p>
<p>Populates <code>patterns</code> with patterns to convert spec-generated named ops to linalg.generic ops. </p>

<p class="definition">Definition at line <a class="el" href="Generalization_8cpp_source.html#l00080">80</a> of file <a class="el" href="Generalization_8cpp_source.html">Generalization.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00928">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00904">mlir::RewritePatternSet::getContext()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Generalization_8cpp_source.html#l00043">generalizeNamedOp()</a>, and <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l01129">mlir::linalg::LinalgLoweringPattern&lt; OpTy &gt;::matchAndRewrite()</a>.</p>

</div>
</div>
<a id="a4701ad0fa2e34da0089a80135935f02e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4701ad0fa2e34da0089a80135935f02e">&#9670;&nbsp;</a></span>populateLinalgTilingCanonicalizationPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::linalg::populateLinalgTilingCanonicalizationPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Tiling_8cpp_source.html#l00469">469</a> of file <a class="el" href="Tiling_8cpp_source.html">Tiling.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00904">mlir::RewritePatternSet::getContext()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Tiling_8cpp_source.html#l00463">getLinalgTilingCanonicalizationPatterns()</a>, and <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l00589">mlir::linalg::LinalgTilingOptions::setPeeledLoops()</a>.</p>

</div>
</div>
<a id="a703d4f21c6f57b8c680dc20dd6928a61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a703d4f21c6f57b8c680dc20dd6928a61">&#9670;&nbsp;</a></span>populateLinalgToStandardConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::linalg::populateLinalgToStandardConversionPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populate the given list with patterns that convert from Linalg to Standard. </p>

<p class="definition">Definition at line <a class="el" href="LinalgToStandard_8cpp_source.html#l00165">165</a> of file <a class="el" href="LinalgToStandard_8cpp_source.html">LinalgToStandard.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00928">mlir::RewritePatternSet::add()</a>, <a class="el" href="DialectConversion_8h_source.html#l00770">mlir::ConversionTarget::addLegalDialect()</a>, <a class="el" href="DialectConversion_8h_source.html#l00699">mlir::ConversionTarget::addLegalOp()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l03281">mlir::applyFullConversion()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">mlir::failed()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00904">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="a1d99ec53d8d90c200b932f59c1633742"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d99ec53d8d90c200b932f59c1633742">&#9670;&nbsp;</a></span>populatePadTensorOpVectorizationPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::linalg::populatePadTensorOpVectorizationPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a>&#160;</td>
          <td class="paramname"><em>baseBenefit</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates <code>patterns</code> with patterns that vectorize linalg.pad_tensor. </p>
<p>These patterns are meant to apply in a complementary fashion. Benefits are used to encode a certain ordering of pattern application. To avoid scattering magic constants throughout the code base, the patterns must be added with this function. <code>baseBenefit</code> can be used to offset the benefit of all PadTensorOp vectorization patterns by a certain value. </p>

<p class="definition">Definition at line <a class="el" href="Vectorization_8cpp_source.html#l01078">1078</a> of file <a class="el" href="Vectorization_8cpp_source.html">Vectorization.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00928">mlir::RewritePatternSet::add()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00023">mlir::PatternBenefit::getBenefit()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00904">mlir::RewritePatternSet::getContext()</a>.</p>

</div>
</div>
<a id="ae8660b99b3f1cd3f42085e6c6694b0a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8660b99b3f1cd3f42085e6c6694b0a0">&#9670;&nbsp;</a></span>populatePushReshapeOpsPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::linalg::populatePushReshapeOpsPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Patterns to push reshape op towards the end of the graph in order to expose more fusion opportunities. </p>

<p class="definition">Definition at line <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l01781">1781</a> of file <a class="el" href="ElementwiseOpFusion_8cpp_source.html">ElementwiseOpFusion.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00928">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00904">mlir::RewritePatternSet::getContext()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l00132">mlir::linalg::LinalgElementwiseFusionOptions::setControlElementwiseOpsFusionFn()</a>.</p>

</div>
</div>
<a id="a141726cc3e876dde26944874a419e36c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a141726cc3e876dde26944874a419e36c">&#9670;&nbsp;</a></span>populateTiledLoopToSCFPattern()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::linalg::populateTiledLoopToSCFPattern </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classmlir_1_1Pattern.html" title="This class contains all of the data related to a pattern, but does not contain any methods or logic f...">Pattern</a> to convert TiledLoopOp to SCF loops. </p>

<p class="definition">Definition at line <a class="el" href="Loops_8cpp_source.html#l00526">526</a> of file <a class="el" href="Loops_8cpp_source.html">Loops.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00928">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00904">mlir::RewritePatternSet::getContext()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Loops_8cpp_source.html#l00197">linalgOpToLoopsImpl()</a>.</p>

</div>
</div>
<a id="ae5f0e6199a06738cd8e8eae51311517b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5f0e6199a06738cd8e8eae51311517b">&#9670;&nbsp;</a></span>promoteSubviewAsNewBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; <a class="el" href="structmlir_1_1linalg_1_1PromotionInfo.html">PromotionInfo</a> &gt; mlir::linalg::promoteSubviewAsNewBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">memref::SubViewOp&#160;</td>
          <td class="paramname"><em>subView</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir_1_1linalg.html#a15f98a29e8d8529d00b3b406f009767e">AllocBufferCallbackFn</a>&#160;</td>
          <td class="paramname"><em>allocationFn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DataLayout.html">DataLayout</a> &amp;&#160;</td>
          <td class="paramname"><em>layout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Promotion_8cpp_source.html#l00214">214</a> of file <a class="el" href="Promotion_8cpp_source.html">Promotion.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8h_source.html#l00424">mlir::OpBuilder::create()</a>, <a class="el" href="Builders_8h_source.html#l00438">mlir::OpBuilder::createOrFold()</a>, <a class="el" href="Matchers_8h_source.html#l00206">mlir::detail::enumerate()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">mlir::failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00265">getConstantUpperBoundForIndex()</a>, and <a class="el" href="Builders_8cpp_source.html#l00099">mlir::Builder::getIndexAttr()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Promotion_8cpp_source.html#l00252">promoteSubViews()</a>.</p>

</div>
</div>
<a id="aede64ae3f89e52f6abd4ed07c884b078"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aede64ae3f89e52f6abd4ed07c884b078">&#9670;&nbsp;</a></span>promoteSubViews()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; LinalgOp &gt; mlir::linalg::promoteSubViews </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LinalgOp&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1linalg_1_1LinalgPromotionOptions.html">LinalgPromotionOptions</a>&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Promotes the <code>subViews</code> into a new buffer allocated at the insertion point <code>b</code>. </p>
<p>Promotion occurs in 3 steps:</p><ol type="1">
<li>Create a new buffer for a full tile (i.e. not clipped at the boundary).</li>
<li>Take a full view on the buffer.</li>
<li>Take a partial slice of the full view in step 2. and copy into it. Infers statically sized buffers from subViews unless <code>dynamicBuffers</code> is true.</li>
</ol>
<p>Returns the modified linalg op (the modification happens in place) as well as all the copy ops created. </p>

<p class="definition">Definition at line <a class="el" href="Promotion_8cpp_source.html#l00382">382</a> of file <a class="el" href="Promotion_8cpp_source.html">Promotion.cpp</a>.</p>

<p class="reference">References <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00286">mlir::DataLayout::closest()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8cpp_source.html#l00665">mlir::linalg::LinalgBasePromotionPattern::matchAndRewrite()</a>, and <a class="el" href="Promotion_8cpp_source.html#l00308">promoteSubViews()</a>.</p>

</div>
</div>
<a id="a850b9fd11404efe17bca02011aff2e88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a850b9fd11404efe17bca02011aff2e88">&#9670;&nbsp;</a></span>promoteSubviewsPrecondition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::linalg::promoteSubviewsPrecondition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1linalg_1_1LinalgPromotionOptions.html">LinalgPromotionOptions</a>&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structmlir_1_1linalg_1_1Promote.html" title="Represent one application of createLinalgStrategyPromotePass. ">Promote</a> std.subviews feeding linalg operations. </p>

<p class="definition">Definition at line <a class="el" href="Promotion_8cpp_source.html#l00360">360</a> of file <a class="el" href="Promotion_8cpp_source.html">Promotion.cpp</a>.</p>

<p class="reference">References <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>, <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l00274">mlir::linalg::LinalgPromotionOptions::operandsToPromote</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">mlir::success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8cpp_source.html#l00665">mlir::linalg::LinalgBasePromotionPattern::matchAndRewrite()</a>.</p>

</div>
</div>
<a id="a7ec52ae2f00aed30bf2c0f20f019f6d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ec52ae2f00aed30bf2c0f20f019f6d2">&#9670;&nbsp;</a></span>rewriteAsPaddedOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &gt; mlir::linalg::rewriteAsPaddedOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LinalgOp&#160;</td>
          <td class="paramname"><em>opToPad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacemlir_1_1linalg.html#a035c53b6c522327cbc4e96070564738a">PaddingValueComputationFunction</a> &amp;&#160;</td>
          <td class="paramname"><em>paddingFunc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacemlir_1_1linalg.html#a96e2c72347bd9cc278b81c22fe13d35b">PaddingNoFoldComputationFunction</a> &amp;&#160;</td>
          <td class="paramname"><em>nofoldFunc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LinalgOp &amp;&#160;</td>
          <td class="paramname"><em>paddedOp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structmlir_1_1linalg_1_1Pad.html" title="Represent one application of LinalgStrategyPadPass. ">Pad</a> the operands of <code>opToPad</code> to a static bounding box. </p>
<p>Use <code>paddingFunc</code> and <code>nofoldFunc</code> to set the padding value and the nofold attribute of the introduced PadTensorOps, respectively. Update <code>paddedOp</code> to the cloned statically shaped operation and return the extracted dynamically shaped results. If padding fails, return failure. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8cpp_source.html#l00221">221</a> of file <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8cpp_source.html">Transforms.cpp</a>.</p>

<p class="reference">References <a class="el" href="Types_8h_source.html#l00250">mlir::Type::cast()</a>, <a class="el" href="Builders_8h_source.html#l00424">mlir::OpBuilder::create()</a>, <a class="el" href="Matchers_8h_source.html#l00206">mlir::detail::enumerate()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">mlir::failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>, <a class="el" href="StaticValueUtils_8cpp_source.html#l00054">mlir::getAsOpFoldResult()</a>, <a class="el" href="Builders_8cpp_source.html#l00099">mlir::Builder::getIndexAttr()</a>, <a class="el" href="Value_8h_source.html#l00119">mlir::Value::getType()</a>, <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8cpp_source.html#l00165">padOperandToSmallestStaticBoundingBox()</a>, and <a class="el" href="Builders_8h_source.html#l00345">mlir::OpBuilder::setInsertionPointAfter()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8cpp_source.html#l00491">mlir::linalg::LinalgPaddingPattern::matchAndRewrite()</a>.</p>

</div>
</div>
<a id="ae949a412565c20b3d334a8d3a26acab3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae949a412565c20b3d334a8d3a26acab3">&#9670;&nbsp;</a></span>skipUnitDimReshape()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::linalg::skipUnitDimReshape </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1OpResult.html">OpResult</a> &amp;&#160;</td>
          <td class="paramname"><em>producer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> &amp;&#160;</td>
          <td class="paramname"><em>consumer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default function to control reshape folding. </p>
<p>Skips folding unit dimension reshapes. </p>

<p class="definition">Definition at line <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l01606">1606</a> of file <a class="el" href="ElementwiseOpFusion_8cpp_source.html">ElementwiseOpFusion.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8cpp_source.html#l00372">mlir::applyPatternsAndFoldGreedily()</a>, <a class="el" href="PatternMatch_8h_source.html#l00781">mlir::RewriterBase::cancelRootUpdate()</a>, <a class="el" href="Builders_8h_source.html#l00424">mlir::OpBuilder::create()</a>, <a class="el" href="Builders_8h_source.html#l00438">mlir::OpBuilder::createOrFold()</a>, <a class="el" href="Types_8h_source.html#l00244">mlir::Type::dyn_cast()</a>, <a class="el" href="Matchers_8h_source.html#l00206">mlir::detail::enumerate()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>, <a class="el" href="PatternMatch_8h_source.html#l00777">mlir::RewriterBase::finalizeRootUpdate()</a>, <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l01596">fuseElementwiseOps()</a>, <a class="el" href="Operation_8h_source.html#l00099">mlir::Operation::getContext()</a>, <a class="el" href="Value_8cpp_source.html#l00020">mlir::Value::getDefiningOp()</a>, <a class="el" href="UseDefLists_8h_source.html#l00037">mlir::detail::IROperandBase::getOwner()</a>, <a class="el" href="Value_8h_source.html#l00434">mlir::OpResult::getOwner()</a>, <a class="el" href="Operation_8h_source.html#l00423">mlir::Operation::getRegions()</a>, <a class="el" href="Value_8h_source.html#l00119">mlir::Value::getType()</a>, <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l00421">isUnitDimExpansionOnly()</a>, <a class="el" href="IR_2BuiltinTypes_8h_source.html#l00073">mlir::ShapedType::kDynamicSize</a>, <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l01764">populateElementwiseOpsFusionPatterns()</a>, <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l01735">populateFoldReshapeOpsByLinearizationPatterns()</a>, <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l01745">populateFoldUnitDimsReshapeOpsByLinearizationPatterns()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00244">mlir::RewriterBase::replaceOp()</a>, <a class="el" href="PatternMatch_8h_source.html#l00772">mlir::RewriterBase::startRootUpdate()</a>, <a class="el" href="LogicalResult_8h_source.html#l00056">mlir::success()</a>, and <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00029">mlir::GreedyRewriteConfig::useTopDownTraversal</a>.</p>

</div>
</div>
<a id="a1124afb803ef915203368364f5525d43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1124afb803ef915203368364f5525d43">&#9670;&nbsp;</a></span>tileAndFuseLinalgOps()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; <a class="el" href="structmlir_1_1linalg_1_1TiledAndFusedLinalgOps.html">TiledAndFusedLinalgOps</a> &gt; mlir::linalg::tileAndFuseLinalgOps </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; LinalgOp &gt;&#160;</td>
          <td class="paramname"><em>ops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1linalg_1_1LinalgDependenceGraph.html">LinalgDependenceGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>dependenceGraph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1linalg_1_1LinalgTilingOptions.html">LinalgTilingOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>tilingOptions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Fusion_8cpp_source.html#l00943">943</a> of file <a class="el" href="Fusion_8cpp_source.html">Fusion.cpp</a>.</p>

<p class="reference">References <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>, <a class="el" href="namespacemlir_1_1linalg.html#a98153087b663d0d7aa3ab0685cfaedafa4b2257cb98694284507e77f34e73c2d8">Loops</a>, <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l00561">mlir::linalg::LinalgTilingOptions::loopType</a>, <a class="el" href="namespacemlir_1_1linalg.html#a98153087b663d0d7aa3ab0685cfaedafab92546344b4e3fa9b10c9472795297a7">ParallelLoops</a>, <a class="el" href="Fusion_8cpp_source.html#l00875">tileAndFuseLinalgOpsImpl()</a>, and <a class="el" href="namespacemlir_1_1linalg.html#a3cdd229e1459c7e6ed2f9c7ee7168325a695eb12d246fdee4efda9a552f92406e">TiledLoops</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8cpp_source.html#l00392">mlir::linalg::LinalgBaseTileAndFusePattern::matchAndRewrite()</a>.</p>

</div>
</div>
<a id="a00668a5d2c737d9304a098899567bd4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00668a5d2c737d9304a098899567bd4a">&#9670;&nbsp;</a></span>tileConsumerAndFuseProducers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; <a class="el" href="classmlir_1_1linalg_1_1TileLoopNest.html">TileLoopNest</a> &gt; mlir::linalg::tileConsumerAndFuseProducers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LinalgOp&#160;</td>
          <td class="paramname"><em>consumerOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>tileSizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>tileInterchange</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tiles <code>consumerOp</code> and fuses its dependencies if possible. </p>
<p>Uses the <code>tileSizes</code> and <code>tileInterchange</code> parameters to control the tiling. </p>

<p class="definition">Definition at line <a class="el" href="FusionOnTensors_8cpp_source.html#l00409">409</a> of file <a class="el" href="FusionOnTensors_8cpp_source.html">FusionOnTensors.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8h_source.html#l00041">applyPermutationToVector()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">mlir::failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>, <a class="el" href="FusionOnTensors_8cpp_source.html#l00318">mlir::linalg::TileLoopNest::fuseProducer()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8h_source.html#l00258">mlir::linalg::TileLoopNest::getRootOp()</a>, <a class="el" href="StructuredOpsUtils_8h_source.html#l00081">mlir::isParallelIterator()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00145">isPermutation()</a>, and <a class="el" href="FusionOnTensors_8cpp_source.html#l00273">mlir::linalg::TileLoopNest::tileRootOp()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8h_source.html#l00264">mlir::linalg::TileLoopNest::getLoopOps()</a>, and <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8cpp_source.html#l00553">mlir::linalg::LinalgTileAndFuseTensorOpsPattern::matchAndRewrite()</a>.</p>

</div>
</div>
<a id="a52412776b72534e8955af53d7285530d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52412776b72534e8955af53d7285530d">&#9670;&nbsp;</a></span>tileLinalgOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; <a class="el" href="structmlir_1_1linalg_1_1TiledLinalgOp.html">TiledLinalgOp</a> &gt; mlir::linalg::tileLinalgOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LinalgOp&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1linalg_1_1LinalgTilingOptions.html">LinalgTilingOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Tiling_8cpp_source.html#l00322">322</a> of file <a class="el" href="Tiling_8cpp_source.html">Tiling.cpp</a>.</p>

<p class="reference">References <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>, <a class="el" href="namespacemlir_1_1linalg.html#a98153087b663d0d7aa3ab0685cfaedafa4b2257cb98694284507e77f34e73c2d8">Loops</a>, <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8h_source.html#l00561">mlir::linalg::LinalgTilingOptions::loopType</a>, <a class="el" href="PassManagerOptions_8cpp_source.html#l00083">options</a>, <a class="el" href="namespacemlir_1_1linalg.html#a98153087b663d0d7aa3ab0685cfaedafab92546344b4e3fa9b10c9472795297a7">ParallelLoops</a>, and <a class="el" href="namespacemlir_1_1linalg.html#a3cdd229e1459c7e6ed2f9c7ee7168325a695eb12d246fdee4efda9a552f92406e">TiledLoops</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8cpp_source.html#l00392">mlir::linalg::LinalgBaseTileAndFusePattern::matchAndRewrite()</a>, <a class="el" href="FusionOnTensors_8cpp_source.html#l00273">mlir::linalg::TileLoopNest::tileRootOp()</a>, and <a class="el" href="Fusion_8cpp_source.html#l00780">tileRootOperation()</a>.</p>

</div>
</div>
<a id="aeb173d5edf56a08ed3610924312dd364"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb173d5edf56a08ed3610924312dd364">&#9670;&nbsp;</a></span>updateBoundsForCyclicDistribution()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::linalg::updateBoundsForCyclicDistribution </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>procId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>nprocs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a> &amp;&#160;</td>
          <td class="paramname"><em>lb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a> &amp;&#160;</td>
          <td class="paramname"><em>ub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a> &amp;&#160;</td>
          <td class="paramname"><em>step</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update the <code>lb</code>, <code>ub</code> and <code>step</code> to get per processor <code>lb</code>, <code>ub</code> and <code>step</code>. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00510">510</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineExpr_8h_source.html#l00328">mlir::bindDims()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00499">mlir::getAffineSymbolExpr()</a>, <a class="el" href="Builders_8h_source.html#l00054">mlir::Builder::getContext()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l00714">mlir::makeComposedAffineApply()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00645">mlir::linalg::GenerateLoopNest&lt; LoopTy &gt;::doit()</a>.</p>

</div>
</div>
<a id="aafecf344e928b95496d372d78ae592a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafecf344e928b95496d372d78ae592a0">&#9670;&nbsp;</a></span>vectorizeLinalgOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::linalg::vectorizeLinalgOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>newResults</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emit a suitable vector form for a Linalg op with fully static shape. </p>

<p class="definition">Definition at line <a class="el" href="Vectorization_8cpp_source.html#l00631">631</a> of file <a class="el" href="Vectorization_8cpp_source.html">Vectorization.cpp</a>.</p>

<p class="reference">References <a class="el" href="LogicalResult_8h_source.html#l00072">mlir::failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>, <a class="el" href="Operation_8h_source.html#l00284">mlir::Operation::getResults()</a>, <a class="el" href="Vectorization_8cpp_source.html#l00046">LDBG</a>, <a class="el" href="LogicalResult_8h_source.html#l00056">mlir::success()</a>, <a class="el" href="Vectorization_8cpp_source.html#l00480">vectorizeAsLinalgGeneric()</a>, <a class="el" href="Vectorization_8cpp_source.html#l01739">vectorizeConvolution()</a>, and <a class="el" href="Vectorization_8cpp_source.html#l00602">vectorizeLinalgOpPrecondition()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Linalg_2Transforms_2Transforms_8cpp_source.html#l00697">mlir::linalg::LinalgBaseVectorizationPattern::matchAndRewrite()</a>.</p>

</div>
</div>
<a id="a434bd78a651f6a42d01090db72bc039c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a434bd78a651f6a42d01090db72bc039c">&#9670;&nbsp;</a></span>vectorizeLinalgOpPrecondition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::linalg::vectorizeLinalgOpPrecondition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rewrite a linalg.generic into a suitable vector.contraction op. </p>

<p class="definition">Definition at line <a class="el" href="Vectorization_8cpp_source.html#l00602">602</a> of file <a class="el" href="Vectorization_8cpp_source.html">Vectorization.cpp</a>.</p>

<p class="reference">References <a class="el" href="Vectorization_8cpp_source.html#l00579">allIndexingsAreProjectedPermutation()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">mlir::failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>, <a class="el" href="Vectorization_8cpp_source.html#l00443">isElementwise()</a>, <a class="el" href="Vectorization_8cpp_source.html#l00046">LDBG</a>, <a class="el" href="Vectorization_8cpp_source.html#l00587">reductionPreconditions()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">mlir::success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Vectorization_8cpp_source.html#l00631">vectorizeLinalgOp()</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Dec 6 2021 20:34:12 for MLIR by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
